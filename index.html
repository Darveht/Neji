<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Naruto Characters 3D - Pixel Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body,html{
      margin:0;padding:0;width:100%;height:100%;
      overflow:hidden;
      background:#0a0a0a;
      font-family: 'Press Start 2P', cursive;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    h2, h3 {
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.3);
      color: #00ffff;
    }

    p {
      font-size: 8px;
      line-height: 1.6;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
    }

    @media (max-width: 600px) {
      h2 { font-size: 12px; }
      h3 { font-size: 10px; }
      p { font-size: 6px; }
      
      .characters-grid {
        grid-template-columns: 1fr;
        gap: 15px;
        padding: 0 10px;
      }
      
      .char-card {
        max-width: 100%;
        padding: 15px;
      }
      
      .char-img {
        height: 120px;
      }
    }

    @media (max-width: 900px) and (min-width: 601px) {
      .characters-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Estilo Soul Knight pixel para la interfaz */
    .char-card {
      background: 
        linear-gradient(45deg, #1a1a2e 25%, transparent 25%),
        linear-gradient(-45deg, #1a1a2e 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #1a1a2e 75%),
        linear-gradient(-45deg, transparent 75%, #1a1a2e 75%);
      background-size: 4px 4px;
      background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
      border: 3px solid #00ffff;
      box-shadow: 
        0 0 0 1px #000,
        0 0 0 4px #00ffff,
        0 0 10px #00ffff,
        inset 0 0 10px rgba(0,255,255,0.2);
      transition: all 0.1s steps(3);
    }

    .char-card:hover {
      transform: scale(1.1);
      border-color: #ffff00;
      box-shadow: 
        0 0 0 1px #000,
        0 0 0 4px #ffff00,
        0 0 20px #ffff00,
        inset 0 0 10px rgba(255,255,0,0.3);
      background-color: rgba(255,255,0,0.1);
    }

    .action-btn {
      background: 
        repeating-conic-gradient(from 0deg, #1a1a2e 0deg 90deg, #2d2d4a 90deg 180deg);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-family: 'Press Start 2P', cursive;
      font-size: 8px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 1px 1px 0px #000, 2px 2px 0px rgba(0,255,255,0.5);
      transition: all 0.1s steps(2);
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000,
        0 0 5px rgba(0,255,255,0.5);
    }

    .action-btn:active {
      background: #00ffff;
      color: #000;
      transform: translate(1px, 1px);
      box-shadow: 
        0 0 0 1px #000,
        1px 1px 0px #000;
    }

    #loading {
      background: 
        radial-gradient(circle at 25% 25%, #ff0080 2px, transparent 2px),
        radial-gradient(circle at 75% 75%, #00ff80 2px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a1a1a 50%);
      background-size: 16px 16px, 16px 16px, 8px 8px;
      font-family: 'Press Start 2P', cursive;
    }

    #loading h2 {
      color: #00ffff;
      font-size: 16px;
      animation: pixel-blink 1s steps(2) infinite;
    }

    @keyframes pixel-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    #loading-bar {
      border: 3px solid #00ffff;
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #1a1a1a 2px, #1a1a1a 4px);
      box-shadow: 
        0 0 0 1px #000,
        0 0 10px rgba(0,255,255,0.5),
        inset 0 0 5px rgba(0,0,0,0.5);
    }

    #loading-progress {
      background: 
        repeating-linear-gradient(90deg, 
          #00ffff 0px, #00ffff 4px, 
          #0080ff 4px, #0080ff 8px,
          #8000ff 8px, #8000ff 12px,
          #ff0080 12px, #ff0080 16px);
      box-shadow: 0 0 5px rgba(0,255,255,0.8);
      image-rendering: pixelated;
    }

    .player-heart {
      width: 12px;
      height: 12px;
      background: 
        conic-gradient(from 45deg, #ff0040 0deg 90deg, #ff4080 90deg 180deg, #ff0040 180deg 270deg, #800020 270deg 360deg);
      clip-path: polygon(50% 10%, 80% 30%, 100% 60%, 50% 100%, 0% 60%, 20% 30%);
      image-rendering: pixelated;
      box-shadow: 
        1px 1px 0px #000,
        0 0 3px rgba(255,0,64,0.8);
    }

    .player-heart.heart-empty {
      background: 
        conic-gradient(from 45deg, #404040 0deg 90deg, #606060 90deg 180deg, #404040 180deg 270deg, #202020 270deg 360deg);
      box-shadow: 1px 1px 0px #000;
    }

    #player-level {
      font-size: 8px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000, 2px 2px 0px rgba(255,255,0,0.5);
      margin-top: 8px;
    }

    #video-intro {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #credits-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      padding: 20px;
      animation: fadeInCredits 2s ease-in-out;
    }

    #credits-overlay h1 {
      font-size: 24px;
      color: #ff4500;
      text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5);
      margin-bottom: 10px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    #credits-overlay h2 {
      font-size: 16px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-bottom: 30px;
    }

    #credits-overlay p {
      font-size: 10px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
      margin: 8px 0;
      line-height: 1.4;
    }

    #skip-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,69,0,0.8);
      color: #fff;
      padding: 10px 15px;
      border: 2px solid #fff;
      font-size: 8px;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #skip-button:hover {
      background: rgba(255,255,0,0.8);
      color: #000;
      transform: scale(1.1);
    }

    @keyframes fadeInCredits {
      0% { opacity: 0; transform: translateY(50px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes pixelGlow {
      0%, 100% { text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5); }
      50% { text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,255,0,0.8), 0 0 10px #ff4500; }
    }

    /* Pantalla de cr√©ditos Glam Works */
    #glam-credits {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(45deg, #000000 25%, #1a1a1a 25%),
        linear-gradient(-45deg, #000000 25%, #1a1a1a 25%),
        linear-gradient(45deg, #1a1a1a 75%, #000000 75%),
        linear-gradient(-45deg, #1a1a1a 75%, #000000 75%);
      background-size: 16px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    #glam-logo {
      text-align: center;
      animation: glamAppear 3s ease-in-out;
    }

    #glam-logo h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 32px;
      color: #FFD700;
      text-shadow: 
        3px 3px 0px #000,
        6px 6px 0px rgba(255,215,0,0.5),
        0 0 20px #FFD700;
      margin: 0;
      letter-spacing: 4px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    .glam-subtitle {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-top: 20px;
      letter-spacing: 2px;
    }

    #glam-skip {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,215,0,0.8);
      color: #000;
      padding: 10px 15px;
      border: 2px solid #FFD700;
      font-size: 8px;
      font-family: 'Press Start 2P', cursive;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #glam-skip:hover {
      background: rgba(0,255,255,0.8);
      border-color: #00ffff;
      transform: scale(1.1);
    }

    @keyframes glamAppear {
      0% { opacity: 0; transform: scale(0.5) rotate(-10deg); }
      50% { opacity: 1; transform: scale(1.1) rotate(2deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }

    /* Estilos para video personalizado */
    #video-credits-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      padding: 20px;
      animation: fadeInCredits 2s ease-in-out;
    }

    #video-credits-overlay h1 {
      font-size: 24px;
      color: #ff4500;
      text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5);
      margin-bottom: 10px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    #video-credits-overlay h2 {
      font-size: 16px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-bottom: 30px;
    }

    #video-credits-overlay p {
      font-size: 10px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
      margin: 8px 0;
      line-height: 1.4;
    }

    #video-skip-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,69,0,0.8);
      color: #fff;
      padding: 10px 15px;
      border: 2px solid #fff;
      font-size: 8px;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #video-skip-button:hover {
      background: rgba(255,255,0,0.8);
      color: #000;
      transform: scale(1.1);
    }

    #intro-screen {
      background: 
        radial-gradient(circle at 20% 80%, #ff0080 2px, transparent 3px),
        radial-gradient(circle at 80% 20%, #00ff80 2px, transparent 3px),
        radial-gradient(circle at 40% 40%, #0080ff 1px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a0a1a 50%);
      background-size: 32px 32px, 32px 32px, 16px 16px, 8px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #naruto-logo-container {
      max-width: 80%;
      max-height: 80%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #naruto-logo {
      max-width: 100%;
      max-height: 400px;
      width: auto;
      height: auto;
      filter: 
        drop-shadow(2px 2px 0px #000)
        drop-shadow(4px 4px 0px #ff4500)
        drop-shadow(0 0 10px #ff4500);
      animation: pixel-pulse 2s steps(4) infinite;
      image-rendering: pixelated;
    }

    @keyframes pixel-pulse {
      0% { transform: scale(1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff4500); }
      25% { transform: scale(1.05); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ffff00); }
      50% { transform: scale(1.1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #00ffff); }
      75% { transform: scale(1.05); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff0080); }
      100% { transform: scale(1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff4500); }
    }

    @keyframes pixel-rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    canvas{
      display:block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    #char-select{
      position:fixed;width:100%;height:100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255,0,128,0.1) 2px, transparent 3px),
        radial-gradient(circle at 75% 75%, rgba(0,255,128,0.1) 2px, transparent 3px),
        repeating-linear-gradient(45deg, 
          rgba(0,0,0,0.9) 0px, rgba(0,0,0,0.9) 2px,
          rgba(26,26,46,0.9) 2px, rgba(26,26,46,0.9) 4px);
      background-size: 32px 32px, 32px 32px, 8px 8px;
      display:none;
      flex-direction: column;
      align-items:center;
      justify-content: flex-start;
      z-index:50;
      overflow-y: auto;
      padding: 20px;
    }

    .characters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      max-width: 1200px;
      width: 100%;
      margin-top: 20px;
      padding: 0 20px;
    }

    .select-header {
      width: 100%;
      text-align: center;
      margin-bottom: 20px;
      position: relative;
    }

    .select-header h2 {
      color: #00ffff;
      font-size: 16px;
      text-shadow: 
        2px 2px 0px #000,
        4px 4px 0px rgba(0,255,255,0.5);
      margin: 0;
      padding: 15px;
      background: 
        repeating-linear-gradient(45deg,
          rgba(0,0,0,0.8) 0px, rgba(0,0,0,0.8) 4px,
          rgba(0,255,255,0.2) 4px, rgba(0,255,255,0.2) 8px);
      border: 3px solid #00ffff;
      box-shadow: 
        0 0 0 1px #000,
        0 0 10px rgba(0,255,255,0.5);
    }

    .scroll-design {
      height: 20px;
      background: 
        repeating-linear-gradient(90deg,
          #ff4500 0px, #ff4500 4px,
          #ffff00 4px, #ffff00 8px,
          #00ff80 8px, #00ff80 12px,
          #0080ff 12px, #0080ff 16px);
      opacity: 0.8;
      margin-top: 10px;
      image-rendering: pixelated;
    }

    .char-card {
      width: 100%;
      max-width: 280px;
      margin: 0;
      background: 
        radial-gradient(circle at 10% 10%, rgba(0,255,255,0.1) 2px, transparent 3px),
        repeating-linear-gradient(45deg,
          rgba(0,0,51,0.95) 0px, rgba(0,0,51,0.95) 3px,
          rgba(255,69,0,0.1) 3px, rgba(255,69,0,0.1) 6px);
      background-size: 16px 16px, 12px 12px;
      border: 3px solid #ff4500;
      border-radius: 0px;
      padding: 20px;
      text-align: center;
      color: #fff;
      cursor: pointer;
      transition: all 0.1s steps(2);
      box-shadow: 
        0 0 0 1px #000,
        3px 3px 0px #000,
        0 0 15px rgba(255,69,0,0.3);
      position: relative;
      overflow: hidden;
      image-rendering: pixelated;
      justify-self: center;
    }

    .char-card:hover {
      transform: scale(1.05) translate(-1px, -1px);
      border-color: #ffff00;
      box-shadow: 
        0 0 0 1px #000,
        4px 4px 0px #000,
        0 0 20px rgba(255,255,0,0.5);
      background: 
        radial-gradient(circle at 10% 10%, rgba(255,255,0,0.2) 2px, transparent 3px),
        repeating-linear-gradient(45deg,
          rgba(0,0,51,0.98) 0px, rgba(0,0,51,0.98) 3px,
          rgba(255,215,0,0.2) 3px, rgba(255,215,0,0.2) 6px);
    }

    .char-card h3 {
      color: #ff4500;
      font-size: 10px;
      margin-bottom: 10px;
      text-shadow: 
        1px 1px 0px #000,
        2px 2px 0px rgba(255,69,0,0.5);
    }

    .char-card p {
      color: #ffff00;
      font-size: 6px;
      line-height: 1.4;
      margin-top: 10px;
      text-shadow: 1px 1px 0px #000;
    }

    .char-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: 
        repeating-linear-gradient(45deg,
          transparent 0px, transparent 2px,
          rgba(74,144,226,0.1) 2px, rgba(74,144,226,0.1) 4px);
      animation: pixel-shine 3s steps(8) infinite;
      pointer-events: none;
    }

    @keyframes pixel-shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .char-img{
      width:100%;
      height:160px;
      background:#1a1a2e;
      margin:8px auto;
      background-size: contain !important;
      border: 2px solid #00ffff;
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 5px rgba(0,0,0,0.5);
      image-rendering: pixelated;
    }

    #joystick{
      position:absolute;bottom:15px;left:15px;width:100px;height:100px;
      touch-action:none;z-index:10;
      filter: drop-shadow(2px 2px 0px #000);
    }

    #joy-base,#joy-thumb{
      position:absolute;border-radius:0px;pointer-events:none;
      image-rendering: pixelated;
    }

    #joy-base{
      width:100%;height:100%;
      border:3px solid #00ffff;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,255,255,0.1) 0deg 45deg, 
          rgba(0,0,0,0.3) 45deg 90deg);
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 10px rgba(0,255,255,0.2);
    }

    #joy-thumb{
      width:40px;height:40px;top:30px;left:30px;
      background: 
        radial-gradient(circle, #00ffff 30%, #0080ff 70%);
      border:2px solid #fff;
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000,
        0 0 5px rgba(0,255,255,0.8);
    }

    #actions{
      position:absolute;bottom:15px;right:15px;
      display:flex;flex-direction:column;gap:8px;z-index:10;
      user-select:none;
    }

    .action-btn{
      width:50px;height:50px;
      border-radius:0px;
      text-align:center;
      line-height:50px;
      color:#00ffff;
      font-size: 8px;
      font-weight: normal;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,0,0,0.8) 0deg 90deg, 
          rgba(26,26,46,0.8) 90deg 180deg);
      border:2px solid #00ffff;
      touch-action:none;
      text-shadow: 1px 1px 0px #000;
      letter-spacing: 0.5px;
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000;
    }

    #jump{
      border-color:#00ff00;color:#00ff00;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,128,0,0.3) 0deg 90deg, 
          rgba(0,0,0,0.8) 90deg 180deg);
    }

    .health-back,.health-bar{
      position:absolute;width:40px;height:4px;
      transform:translate(-50%,-120%);pointer-events:none;
      image-rendering: pixelated;
    }

    .health-back{
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #333 2px, #333 4px);
      border: 1px solid #000;
    } 

    .health-bar{
      background: 
        repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 2px, #80ff00 2px, #80ff00 4px);
      border: 1px solid #000;
      box-shadow: 0 0 3px rgba(0,255,0,0.5);
    }

    #player-hud {
      position: absolute;
      top: 8px;
      left: 8px;
      color: white;
      font-family: 'Press Start 2P', cursive;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      background: 
        repeating-linear-gradient(45deg,
          rgba(26,26,46,0.9) 0px, rgba(26,26,46,0.9) 3px,
          rgba(0,0,0,0.8) 3px, rgba(0,0,0,0.8) 6px);
      padding: 6px 10px;
      border: 2px solid #00ffff;
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000,
        0 0 10px rgba(0,255,255,0.3);
      scale: 0.8;
      image-rendering: pixelated;
    }

    #health-container {
      background: 
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.7) 0px, rgba(0,0,0,0.7) 2px,
          rgba(26,26,46,0.7) 2px, rgba(26,26,46,0.7) 4px);
      padding: 6px 8px;
      border: 2px solid #00ffff;
      display: flex;
      gap: 4px;
      margin-bottom: 6px;
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 5px rgba(0,0,0,0.5);
    }

    .player-heart {
      width: 16px;
      height: 16px;
      background: 
        repeating-conic-gradient(from 0deg, 
          #ff3333 0deg 45deg, 
          #ff6666 45deg 90deg,
          #ff3333 90deg 135deg,
          #cc0000 135deg 180deg);
      clip-path: polygon(50% 20%, 80% 40%, 70% 80%, 50% 100%, 30% 80%, 20% 40%);
      animation: pixel-heart-pulse 1.5s steps(4) infinite;
      image-rendering: pixelated;
      box-shadow: 
        1px 1px 0px #000,
        0 0 3px rgba(255,51,51,0.7);
    }

    .heart-empty {
      background: 
        repeating-conic-gradient(from 0deg, 
          #333333 0deg 45deg, 
          #666666 45deg 90deg,
          #333333 90deg 135deg,
          #111111 135deg 180deg);
      box-shadow: 1px 1px 0px #000;
      animation: none;
    }

    @keyframes pixel-heart-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    #player-level {
      font-size: 8px;
      color: #ffff00;
      text-shadow: 
        1px 1px 0px #000,
        2px 2px 0px rgba(255,255,0,0.5);
      font-weight: normal;
      letter-spacing: 1px;
    }

    #loading-status {
      margin-top: 8px;
      font-size: 10px;
      color: #00ffff;
      text-shadow: 1px 1px 0px #000;
    }

    #loading-size {
      margin-top: 4px;
      font-size: 8px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
    }

    .enemy-hearts {
      position: absolute;
      display: flex;
      gap: 1px;
      filter: drop-shadow(1px 1px 0px #000);
    }

    .enemy-heart {
      width: 6px;
      height: 6px;
      background: 
        linear-gradient(45deg, #ff0000 50%, #cc0000 50%);
      clip-path: polygon(50% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%);
      image-rendering: pixelated;
    }

    .enemy-heart.heart-empty {
      background: 
        linear-gradient(45deg, #333 50%, #111 50%);
    }

    /* Efectos de part√≠culas pixeladas */
    @keyframes pixel-spark {
      0% { transform: scale(1) rotate(0deg); opacity: 1; }
      100% { transform: scale(0) rotate(180deg); opacity: 0; }
    }

    /* Scrollbar pixel style */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #333 2px, #333 4px);
    }

    ::-webkit-scrollbar-thumb {
      background: 
        repeating-linear-gradient(90deg, #00ffff 0px, #00ffff 2px, #0080ff 2px, #0080ff 4px);
      border: 1px solid #000;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: 
        repeating-linear-gradient(90deg, #ffff00 0px, #ffff00 2px, #ff8000 2px, #ff8000 4px);
    }
  </style>
</head>
<body>
  <!-- Pantalla de cr√©ditos Glam Works -->
  <div id="glam-credits">
    <div id="glam-logo">
      <h1>GLAM WORKS</h1>
      <div class="glam-subtitle">PRESENTA</div>
    </div>
    <div id="glam-skip">PRESIONA PARA SALTAR</div>
  </div>

  <!-- Pantalla de video personalizado -->
  <div id="video-intro" style="display:none;">
    <video id="intro-video" 
           style="width:100%;height:100%;object-fit:cover;background:#000;" 
           playsinline
           preload="auto">
      <source src="https://ik.imagekit.io/lcpvlmgbf/copy_DBDB6139-95C4-4DBB-A0DF-78E4B5FED009.mov/ik-video.mp4?updatedAt=1748452619471" type="video/mp4">
    </video>
    <div id="video-skip-button" style="display:none;">PRESIONA PARA SALTAR</div>
  </div>

  <!-- Pantalla de inicio con logo Naruto arreglado -->
  <div id="intro-screen" style="display:none;">
    <div id="naruto-logo-container">
      <img id="naruto-logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Logo_Naruto_Shipp%C5%ABden.svg/2560px-Logo_Naruto_Shipp%C5%ABden.svg.png" alt="Naruto Shippuden">
    </div>
  </div>
  <!-- Pantalla de carga -->
  <div id="loading">
    <h2>CARGANDO...</h2>
    <div id="loading-status">INICIANDO...</div>
    <div id="loading-size">0 MB / 100 MB</div>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
  </div>

  <!-- Selecci√≥n de personaje -->
  <div id="char-select">
    <div class="select-header">
      <h2>SELECCIONA TU PERSONAJE</h2>
      <div class="scroll-design"></div>
    </div>
    <audio id="hover-sound" src="https://www.soundjay.com/buttons/button-09a.mp3"></audio>
    <audio id="select-sound" src="https://www.soundjay.com/buttons/button-37a.mp3"></audio>
    
    <div class="characters-grid">
      <div class="char-card" onclick="selectCharacter('neji')" onmouseover="playHoverSound()">
        <h3>NEJI HYUGA</h3>
        <div class="char-img" style="background: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_JLthZ20l4C_V-G8cKVR_3hOqAyrTOVTLaw&s') center/contain no-repeat;"></div>
        <p>PODERES: BYAKUGAN, JUKEN, 64 PALMAS, 128 PALMAS, KAITEN</p>
      </div>
      <div class="char-card" onclick="selectCharacter('itachi')">
        <h3>ITACHI UCHIHA</h3>
        <div class="char-img" style="background: url('https://officialpsds.com/imageview/r0/68/r068ny_large.png?1521316545') center/contain no-repeat;"></div>
        <p>PODERES: SHARINGAN, AMATERASU, TSUKUYOMI, SUSANOO</p>
      </div>
      <div class="char-card" onclick="selectCharacter('ino')">
        <h3>INO YAMANAKA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/c/cc/Ino_Segunda_Guerra_Mundial_Shinobi_HD.png') center/contain no-repeat;"></div>
        <p>PODERES: TRANSFERENCIA DE MENTE, BOMBA DE CHAKRA, CONTROL MENTAL, CURACION</p>
      </div>
      <div class="char-card" onclick="selectCharacter('shikamaru')">
        <h3>SHIKAMARU NARA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/9a/Shikamaru_Nara.png') center/contain no-repeat;"></div>
        <p>PODERES: POSESION DE SOMBRA, ESTRANGULACION DE SOMBRA, COSTURA DE SOMBRA, IMITACION DE SOMBRA</p>
      </div>
      <div class="char-card" onclick="selectCharacter('tenten')">
        <h3>TENTEN</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/92/Tenten_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: INVOCACION DE ARMAS, LLUVIA DE KUNAIS, PERGAMINO GIGANTE, BARRERA DE ARMAS</p>
      </div>
      <div class="char-card" onclick="selectCharacter('hinata')">
        <h3>HINATA HYUGA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/97/Hinata.png') center/contain no-repeat;"></div>
        <p>PODERES: BYAKUGAN, PUNO SUAVE, LEON GEMELO, PROTECCION DE 8 TRIGRAMAS</p>
      </div>
      <div class="char-card" onclick="selectCharacter('temari')">
        <h3>TEMARI</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/7/7c/Temari_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: DANZA DEL ABANICO, TORBELLINO CORTANTE, GUADANA COMADREJA, INVOCACION</p>
      </div>
      <div class="char-card" onclick="selectCharacter('sasuke')">
        <h3>SASUKE UCHIHA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/2/21/Sasuke_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: CHIDORI, SHARINGAN, AMATERASU, KIRIN</p>
      </div>
      <div class="char-card" onclick="selectCharacter('hashirama')">
        <h3>HASHIRAMA SENJU</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/7/7e/Hashirama_Senju.png') center/contain no-repeat;"></div>
        <p>PODERES: MOKUTON, SENJUTSU, REGENERACION, GOJU MOKUTON</p>
      </div>
    </div>
  </div>

  <!-- Joystick -->
  <div id="joystick">
    <div id="joy-base"></div>
    <div id="joy-thumb"></div>
  </div>

  <!-- Botones (se actualizar√°n seg√∫n el personaje) -->
  <div id="actions"></div>

  <!-- Player HUD -->
  <div id="player-hud">
    <div id="health-container"></div>
    <div id="player-level">NIVEL 1</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
  // Secuencia completa: Glam Works ‚Üí Video ‚Üí Logo ‚Üí Personajes
  const glamCredits = document.getElementById('glam-credits');
  const glamSkip = document.getElementById('glam-skip');
  const videoIntro = document.getElementById('video-intro');
  const introVideo = document.getElementById('intro-video');
  const videoSkipButton = document.getElementById('video-skip-button');
  const introScreen = document.getElementById('intro-screen');

  let currentStep = 1; // 1=Glam, 2=Video, 3=Logo, 4=Game
  let canSkip = false;

  // PASO 1: Cr√©ditos Glam Works
  function showGlamCredits() {
    glamCredits.style.display = 'flex';
    canSkip = false;
    
    // Permitir skip despu√©s de 2 segundos
    setTimeout(() => {
      canSkip = true;
    }, 2000);
    
    // NO auto-avanzar - solo manual
  }

  // PASO 2: Video personalizado (SIN cr√©ditos encima)
  function showVideo() {
    glamCredits.style.display = 'none';
    videoIntro.style.display = 'flex';
    canSkip = false;
    
    // SILENCIAR COMPLETAMENTE YouTube durante el video del intro
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube silenciado para el video del intro');
    }
    
    // Quitar la superposici√≥n de cr√©ditos del video
    const videoCreditsOverlay = document.getElementById('video-credits-overlay');
    if(videoCreditsOverlay) {
      videoCreditsOverlay.style.display = 'none';
    }
    
    // Reproducir el video autom√°ticamente con audio
    const startVideo = () => {
      // Intentar reproducir con audio inmediatamente
      introVideo.muted = false;
      introVideo.play().then(() => {
        console.log('Video iniciado con audio');
      }).catch(e => {
        console.log('Autoplay bloqueado, requiere interacci√≥n:', e);
        // Si falla, mostrar mensaje para interactuar
        showPlayMessage();
      });
    };
    
    const showPlayMessage = () => {
      let playMessage = document.createElement('div');
      playMessage.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ffff;
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        text-align: center;
        background: rgba(0,0,0,0.8);
        padding: 20px;
        border: 2px solid #00ffff;
        z-index: 1001;
        animation: pixelBlink 1.5s steps(2) infinite;
        cursor: pointer;
      `;
      playMessage.innerHTML = 'TOCA PARA REPRODUCIR<br>EL VIDEO CON AUDIO';
      videoIntro.appendChild(playMessage);
      
      // Reproducir cuando se haga clic en el mensaje
      playMessage.addEventListener('click', () => {
        introVideo.muted = false;
        introVideo.play().then(() => {
          playMessage.remove();
        });
      });
      
      // Tambi√©n permitir clic en cualquier parte del video
      videoIntro.addEventListener('click', () => {
        introVideo.muted = false;
        introVideo.play().then(() => {
          playMessage.remove();
        });
      }, {once: true});
    };
    
    // Iniciar inmediatamente
    startVideo();
    
    // Mostrar bot√≥n de skip despu√©s de 10 segundos
    setTimeout(() => {
      canSkip = true;
      videoSkipButton.style.display = 'block';
    }, 10000);
    
    // Auto-avanzar SOLO cuando termine el video
    introVideo.addEventListener('ended', () => {
      if(currentStep === 2) {
        console.log('Video termin√≥, avanzando...');
        nextStep();
      }
    });
    
    // Detectar duraci√≥n del video y ajustar tiempo
    introVideo.addEventListener('loadedmetadata', () => {
      console.log('Duraci√≥n del video:', introVideo.duration, 'segundos');
    });
  }

  // PASO 3: Pantalla de inicializaci√≥n del juego
  function showGameInitialization() {
    videoIntro.style.display = 'none';
    
    // MANTENER YouTube silenciado durante la carga
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube mantiene silencio durante carga');
    }
    
    // Crear pantalla de inicializaci√≥n
    let initScreen = document.createElement('div');
    initScreen.id = 'game-init-screen';
    initScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, #ff0080 2px, transparent 3px),
        radial-gradient(circle at 80% 20%, #00ff80 2px, transparent 3px),
        radial-gradient(circle at 40% 40%, #0080ff 1px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a0a1a 50%);
      background-size: 32px 32px, 32px 32px, 16px 16px, 8px 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-family: 'Press Start 2P', cursive;
    `;
    
    initScreen.innerHTML = `
      <h1 style="
        color: #00ffff;
        font-size: 24px;
        text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
        margin-bottom: 30px;
        animation: pixel-blink 1s steps(2) infinite;
      ">INICIALIZANDO JUEGO...</h1>
      
      <div id="init-status" style="
        color: #ffff00;
        font-size: 12px;
        text-shadow: 1px 1px 0px #000;
        margin-bottom: 20px;
      ">CARGANDO SISTEMA...</div>
      
      <div style="
        width: 400px;
        height: 20px;
        border: 3px solid #00ffff;
        background: repeating-linear-gradient(90deg, #000 0px, #000 2px, #1a1a1a 2px, #1a1a1a 4px);
        box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0,255,255,0.5);
      ">
        <div id="init-progress" style="
          height: 100%;
          width: 0%;
          background: repeating-linear-gradient(90deg, 
            #00ffff 0px, #00ffff 4px, 
            #0080ff 4px, #0080ff 8px,
            #8000ff 8px, #8000ff 12px,
            #ff0080 12px, #ff0080 16px);
          transition: width 0.3s ease;
        "></div>
      </div>
    `;
    
    document.body.appendChild(initScreen);
    
    // Simular proceso de carga
    let progress = 0;
    let statusEl = document.getElementById('init-status');
    let progressEl = document.getElementById('init-progress');
    
    const loadingSteps = [
      "DESCARGANDO PAQUETES DE JUTSU...",
      "INSTALANDO EFECTOS DE CHAKRA...",
      "CARGANDO MODELOS 3D...",
      "CONFIGURANDO ARENA DE COMBATE...",
      "ACTIVANDO SISTEMA DE COMBATE...",
      "SINCRONIZANDO PODERES NINJA...",
      "PREPARANDO EXPERIENCIA COMPLETA..."
    ];
    
    let stepIndex = 0;
    let loadInterval = setInterval(() => {
      progress += Math.random() * 15 + 5;
      if(progress > 100) progress = 100;
      
      progressEl.style.width = progress + '%';
      
      if(stepIndex < loadingSteps.length && progress > (stepIndex + 1) * 14) {
        statusEl.textContent = loadingSteps[stepIndex];
        stepIndex++;
      }
      
      if(progress >= 100) {
        clearInterval(loadInterval);
        statusEl.textContent = "¬°SISTEMA LISTO!";
        
        setTimeout(() => {
          initScreen.remove();
          nextStep(); // Ir a la pantalla del t√≠tulo
        }, 1500);
      }
    }, 200);
    
    canSkip = false;
    setTimeout(() => canSkip = true, 3000);
  }

  // PASO 4: Pantalla de t√≠tulo "Naruto Final Time"
  function showTitleScreen() {
    // MANTENER YouTube silenciado durante la pantalla de t√≠tulo
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube silenciado en pantalla de t√≠tulo');
    }
    
    // Crear pantalla de t√≠tulo
    let titleScreen = document.createElement('div');
    titleScreen.id = 'title-screen';
    titleScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255,0,128,0.1) 2px, transparent 3px),
        radial-gradient(circle at 75% 75%, rgba(0,255,128,0.1) 2px, transparent 3px),
        repeating-linear-gradient(45deg, 
          rgba(0,0,0,0.95) 0px, rgba(0,0,0,0.95) 2px,
          rgba(26,26,46,0.95) 2px, rgba(26,26,46,0.95) 4px);
      background-size: 32px 32px, 32px 32px, 8px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-family: 'Press Start 2P', cursive;
    `;
    
    titleScreen.innerHTML = `
      <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        width: 80%;
        max-width: 800px;
        gap: 40px;
      ">
        <img src="https://i.ibb.co/Kjfn5VwH/naruto-image.png" 
             style="
               width: 200px;
               height: 200px;
               object-fit: contain;
               filter: drop-shadow(3px 3px 0px #000) drop-shadow(6px 6px 0px #ff4500);
               animation: pixel-float 3s steps(4) infinite;
               image-rendering: pixelated;
             " 
             onerror="this.style.display='none';"
             alt="Naruto" />
        
        <div style="text-align: center;">
          <h1 style="
            color: #ff4500;
            font-size: 32px;
            text-shadow: 
              3px 3px 0px #000,
              6px 6px 0px rgba(255,69,0,0.5),
              0 0 20px #ff4500;
            margin: 0 0 20px 0;
            letter-spacing: 4px;
            animation: pixelGlow 2s steps(4) infinite;
          ">NARUTO</h1>
          
          <h2 style="
            color: #00ffff;
            font-size: 24px;
            text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
            margin: 0 0 40px 0;
            letter-spacing: 3px;
          ">FINAL TIME</h2>
          
          <button id="play-game-btn" style="
            background: 
              repeating-conic-gradient(from 0deg, 
                rgba(255,69,0,0.8) 0deg 90deg, 
                rgba(255,140,0,0.8) 90deg 180deg);
            border: 3px solid #ff4500;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.2s steps(2);
            box-shadow: 
              0 0 0 1px #000,
              3px 3px 0px #000,
              0 0 15px rgba(255,69,0,0.5);
            text-shadow: 2px 2px 0px #000;
            animation: pixelBlink 2s steps(2) infinite;
          " 
          onmouseover="this.style.transform='scale(1.1)'; this.style.borderColor='#ffff00';"
          onmouseout="this.style.transform='scale(1)'; this.style.borderColor='#ff4500';">
            PLAY GAME
          </button>
        </div>
      </div>
    `;
    
    // A√±adir estilos de animaci√≥n
    const titleStyles = document.createElement('style');
    titleStyles.textContent = `
      @keyframes pixel-float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }
      
      @keyframes pixelGlow {
        0%, 100% { 
          text-shadow: 3px 3px 0px #000, 6px 6px 0px rgba(255,69,0,0.5);
        }
        50% { 
          text-shadow: 3px 3px 0px #000, 6px 6px 0px rgba(255,255,0,0.8), 0 0 15px #ff4500;
        }
      }
      
      @keyframes pixelBlink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(titleStyles);
    
    document.body.appendChild(titleScreen);
    
    // Event listener para el bot√≥n de jugar
    document.getElementById('play-game-btn').addEventListener('click', () => {
      titleScreen.remove();
      titleStyles.remove();
      console.log('üéÆ Play button clicked - iniciando m√∫sica de batalla');
      nextStep(); // Ir a selecci√≥n de personajes
    });
    
    canSkip = false;
    setTimeout(() => canSkip = true, 2000);
  }

  // PASO 5: Selecci√≥n de personajes  
  function showCharacterSelect() {
    // VERIFICAR SI YA EXISTE Y LIMPIAR M√öSICA ANTERIOR
    const existingBattleMusic = document.getElementById('battle-music-video');
    if(existingBattleMusic) {
      existingBattleMusic.remove();
      console.log('üéµ M√∫sica anterior removida');
    }

    // MOSTRAR PANTALLA DE SELECCI√ìN INMEDIATAMENTE
    document.getElementById('loading').style.display = 'none';
    document.getElementById('char-select').style.display = 'flex';
    console.log('üéÆ Pantalla de selecci√≥n mostrada');

    // CREAR Y ACTIVAR M√öSICA DE BATALLA CON M√öLTIPLES INTENTOS
    function createAndPlayBattleMusic() {
      let battleMusicVideo = document.createElement('video');
      battleMusicVideo.id = 'battle-music-video';
      battleMusicVideo.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
      battleMusicVideo.src = 'https://ik.imagekit.io/lcpvlmgbf/copy_3D85FC1D-0C2F-4869-8324-615CD5FE94A5.mov/ik-video.mp4?updatedAt=1748458403027';
      battleMusicVideo.autoplay = true;
      battleMusicVideo.loop = true;
      battleMusicVideo.muted = false;
      battleMusicVideo.volume = 0.7;
      battleMusicVideo.preload = 'auto';
      
      document.body.appendChild(battleMusicVideo);
      
      // INTENTAR REPRODUCIR CON M√öLTIPLES M√âTODOS
      const playAttempts = [
        // Intento 1: Reproducci√≥n directa
        () => {
          return battleMusicVideo.play().then(() => {
            console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n directa exitosa');
            return true;
          });
        },
        
        // Intento 2: Con mute temporal
        () => {
          battleMusicVideo.muted = true;
          return battleMusicVideo.play().then(() => {
            setTimeout(() => {
              battleMusicVideo.muted = false;
              console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n con unmute exitosa');
            }, 200);
            return true;
          });
        },
        
        // Intento 3: Reiniciar y reproducir
        () => {
          battleMusicVideo.currentTime = 0;
          battleMusicVideo.muted = false;
          return battleMusicVideo.play().then(() => {
            console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n con reinicio exitosa');
            return true;
          });
        }
      ];

      // Ejecutar intentos secuencialmente
      function tryPlayback(attemptIndex = 0) {
        if(attemptIndex >= playAttempts.length) {
          console.log('‚ùå Todos los intentos de reproducci√≥n fallaron');
          // Crear mensaje visual para activar m√∫sica manualmente
          createManualMusicActivator();
          return;
        }

        playAttempts[attemptIndex]().catch(error => {
          console.log(`‚ö†Ô∏è Intento ${attemptIndex + 1} fall√≥:`, error);
          setTimeout(() => tryPlayback(attemptIndex + 1), 300);
        });
      }

      // Iniciar intentos de reproducci√≥n
      setTimeout(() => {
        console.log('üéµ Iniciando reproducci√≥n de m√∫sica de batalla...');
        tryPlayback();
      }, 100);

      // Verificar si la m√∫sica est√° sonando cada segundo
      let musicCheckInterval = setInterval(() => {
        if(!battleMusicVideo.paused && !battleMusicVideo.muted && battleMusicVideo.currentTime > 0) {
          console.log('üéµ M√∫sica de batalla confirmada activa');
          clearInterval(musicCheckInterval);
        }
      }, 1000);

      // Limpiar verificaci√≥n despu√©s de 10 segundos
      setTimeout(() => clearInterval(musicCheckInterval), 10000);
    }

    // Crear activador manual en caso de fallos
    function createManualMusicActivator() {
      if(document.getElementById('manual-music-activator')) return;
      
      let activator = document.createElement('div');
      activator.id = 'manual-music-activator';
      activator.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255,69,0,0.9);
        color: white;
        padding: 10px 15px;
        border: 2px solid #ffff00;
        font-family: 'Press Start 2P', cursive;
        font-size: 8px;
        cursor: pointer;
        z-index: 1000;
        animation: pixelBlink 1s steps(2) infinite;
      `;
      activator.textContent = 'ACTIVAR M√öSICA';
      
      activator.addEventListener('click', () => {
        const music = document.getElementById('battle-music-video');
        if(music) {
          music.muted = false;
          music.currentTime = 0;
          music.play().then(() => {
            console.log('üéµ M√∫sica activada manualmente');
            activator.remove();
          });
        }
      });
      
      document.body.appendChild(activator);
      
      // Auto-remover despu√©s de 15 segundos
      setTimeout(() => {
        if(activator.parentNode) activator.remove();
      }, 15000);
    }

    // Activar m√∫sica inmediatamente
    createAndPlayBattleMusic();
  }

  // Funci√≥n para avanzar al siguiente paso
  function nextStep() {
    if(!canSkip && currentStep < 5) return; // No permitir skip si no est√° habilitado
    
    // DETENER Y SILENCIAR VIDEO SI EST√Å REPRODUCI√âNDOSE
    if(introVideo && !introVideo.paused) {
      introVideo.pause();
      introVideo.currentTime = 0;
      introVideo.muted = true;
      console.log('Video del intro detenido por skip');
    }
    
    currentStep++;
    switch(currentStep) {
      case 2:
        showVideo();
        break;
      case 3:
        showGameInitialization();
        break;
      case 4:
        showTitleScreen();
        break;
      case 5:
        console.log('üéµ Iniciando selecci√≥n de personajes con m√∫sica de batalla');
        showCharacterSelect();
        break;
    }
  }

  // Event listeners para saltar - SOLO cuando canSkip es true
  glamSkip.addEventListener('click', () => {
    if(canSkip) nextStep();
  });
  
  videoSkipButton.addEventListener('click', () => {
    if(canSkip) {
      // Detener video inmediatamente cuando se presiona skip
      if(introVideo && !introVideo.paused) {
        introVideo.pause();
        introVideo.currentTime = 0;
        introVideo.muted = true;
      }
      nextStep();
    }
  });
  
  // Clicks en las pantallas - SOLO cuando canSkip es true
  glamCredits.addEventListener('click', () => {
    if(canSkip) nextStep();
  });
  
  videoIntro.addEventListener('click', () => {
    if(canSkip) {
      // Detener video inmediatamente cuando se hace clic para skip
      if(introVideo && !introVideo.paused) {
        introVideo.pause();
        introVideo.currentTime = 0;
        introVideo.muted = true;
      }
      nextStep();
    }
  });
  
  // Agregar click handlers para las nuevas pantallas
  document.addEventListener('click', (e) => {
    if(canSkip) {
      if(e.target.closest('#game-init-screen')) {
        nextStep();
      } else if(e.target.closest('#title-screen') && !e.target.closest('#play-game-btn')) {
        nextStep();
      }
    }
  });

  // Iniciar secuencia
  showGlamCredits();

  // Reproducir m√∫sica de intro con YouTube (opcional)
  let youtubePlayer;

  // Crear el iframe de YouTube
  let ytContainer = document.createElement('div');
  ytContainer.style.cssText = 'display:none;';
  ytContainer.innerHTML = `
    <iframe id="youtube-player" 
            width="560" height="315" 
            src="https://www.youtube.com/embed/6YsxjUhZw1A?enablejsapi=1" 
            allow="autoplay">
    </iframe>`;
  document.body.appendChild(ytContainer);

  // Cargar API de YouTube
  let tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  document.body.appendChild(tag);

  // Funci√≥n que se llama cuando la API est√° lista
  window.onYouTubeIframeAPIReady = function() {
    youtubePlayer = new YT.Player('youtube-player', {
      events: {
        'onReady': onPlayerReady
      }
    });
  };

  function onPlayerReady(event) {
    // Pausar inmediatamente el video de YouTube y mantenerlo silenciado
    youtubePlayer.pauseVideo();
    youtubePlayer.mute();
    console.log('YouTube inicializado y silenciado - esperando selecci√≥n de personaje');
  };

  // Variables globales
  let scene, camera, renderer, player, floor;
  let enemies = [], powers = [], moveDir={x:0,z:0}, velY=0, onGround=true;
  const GRAV=-0.02, enemyHUD={};
  let playerHealth = 5; // 5 vidas
  let playerLevel = 1;
  let currentStage = 1;
  
  // Variables para c√°mara libre 360¬∞
  let cameraAngleX = 0; // Rotaci√≥n horizontal (izquierda/derecha)
  let cameraAngleY = 0; // Rotaci√≥n vertical (arriba/abajo)
  let cameraDistance = 10; // Distancia de la c√°mara al jugador
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  const MAX_HEALTH = 5;
  const STAGES = {
    1: {name: 'Bosque de Konoha', enemies: 3, enemyHealth: 5, enemyDamage: 10},
    2: {name: 'Aldea de la Lluvia', enemies: 4, enemyHealth: 6, enemyDamage: 12},
    3: {name: 'Valle del Fin', enemies: 5, enemyHealth: 7, enemyDamage: 15},
    4: {name: 'Cueva Akatsuki', enemies: 6, enemyHealth: 8, enemyDamage: 20},
    5: {name: 'Templo del Fuego', enemies: 10, enemyHealth: 10, enemyDamage: 25},
    6: {name: 'Monta√±a Cementerio', enemies: 15, enemyHealth: 12, enemyDamage: 30},
    7: {name: 'Pa√≠s del Hierro', enemies: 25, enemyHealth: 15, enemyDamage: 35},
    8: {name: 'Puente del Cielo y la Tierra', enemies: 50, enemyHealth: 18, enemyDamage: 40},
    9: {name: 'Base de Orochimaru', enemies: 100, enemyHealth: 20, enemyDamage: 45},
    10: {name: 'Guerra Ninja', enemies: 500, enemyHealth: 25, enemyDamage: 50, hasAlly: true},
    11: {name: 'Batalla Final vs Pain', enemies: 1, enemyHealth: 1000, enemyDamage: 100, isBossFight: true}
  };

  // Variables globales para el aliado y el jefe
  let ally = null;
  let pain = null;
  let painPaths = [];

  function updatePlayerHUD() {
    const container = document.getElementById('health-container');
    container.innerHTML = '';
    for(let i = 0; i < MAX_HEALTH; i++) {
      const heart = document.createElement('div');
      heart.className = `player-heart ${i >= playerHealth ? 'heart-empty' : ''}`;
      container.appendChild(heart);
    }
    document.getElementById('player-level').textContent = 'NIVEL ' + playerLevel;
  }
  let currentCharacter = '';
let playerSpeed = 0.15; // Velocidad base
let characterNames = {
  'neji': 'NEJI HYUGA',
  'itachi': 'ITACHI UCHIHA',
  'ino': 'INO YAMANAKA',
  'shikamaru': 'SHIKAMARU NARA',
  'tenten': 'TENTEN',
  'hinata': 'HINATA HYUGA',
  'temari': 'TEMARI',
  'sasuke': 'SASUKE UCHIHA'
};

// Mostrar nombre del personaje
function showCharacterName() {
  let nameDiv = document.createElement('div');
  nameDiv.style.cssText = `
    position: fixed;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    color: #00ffff;
    font-size: 16px;
    font-family: 'Press Start 2P', cursive;
    font-weight: normal;
    text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 12px;
    border: 2px solid #00ffff;
    box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0,255,255,0.5);
  `;
  nameDiv.textContent = characterNames[currentCharacter];
  document.body.appendChild(nameDiv);
}

  // Sistema de carga con almacenamiento local
  window.onload = () => {
    // Verificar si ya se carg√≥ anteriormente
    if(localStorage.getItem('narutoGameLoaded')) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('char-select').style.display = 'flex';
      return;
    }

    let progress = 0;
    const loadingBar = document.getElementById('loading-progress');
    const loadingStatus = document.getElementById('loading-status');
    const loadingSize = document.getElementById('loading-size');
    const totalSize = 250; // Aumentamos el tama√±o total
    const loadingSteps = [
      {progress: 10, message: "DESCARGANDO MODELOS 3D BASE...", size: 25},
      {progress: 20, message: "CARGANDO TEXTURAS DE PERSONAJES...", size: 50},
      {progress: 30, message: "INSTALANDO EFECTOS DE JUTSU...", size: 75},
      {progress: 40, message: "CARGANDO ANIMACIONES...", size: 100},
      {progress: 50, message: "INSTALANDO EFECTOS DE PARTICULAS...", size: 125},
      {progress: 60, message: "CARGANDO SONIDOS Y MUSICA...", size: 150},
      {progress: 70, message: "CONFIGURANDO FISICA DEL JUEGO...", size: 175},
      {progress: 80, message: "OPTIMIZANDO RENDIMIENTO...", size: 200},
      {progress: 90, message: "FINALIZANDO INSTALACION...", size: 225},
      {progress: 100, message: "INSTALACION COMPLETADA!", size: 250}
    ];

      let currentStep = 0;
      const interval = setInterval(() => {
        if(currentStep < loadingSteps.length) {
          let step = loadingSteps[currentStep];
          if(progress < step.progress) {
            progress += 1;
            loadingBar.style.width = progress + '%';
            loadingSize.textContent = `${Math.floor(progress * totalSize / 100)} MB / ${totalSize} MB`;
          } else {
            loadingStatus.textContent = step.message;
            currentStep++;
          }
        }
        if(progress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            // Guardar en localStorage que ya se carg√≥ el juego
            localStorage.setItem('narutoGameLoaded', 'true');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('char-select').style.display = 'flex';
          }, 1000);
        }
      }, 100); // Aumentamos el intervalo para simular una carga m√°s realista
    };

  function playHoverSound() {
    document.getElementById('hover-sound').play();
  }

  function selectCharacter(char) {
    document.getElementById('select-sound').play();
    currentCharacter = char;
    document.getElementById('char-select').style.display = 'none';
    updatePlayerHUD();
    showCharacterName();
    
    // DETENER COMPLETAMENTE la m√∫sica de batalla al entrar al campo de batalla
    const battleMusic = document.getElementById('battle-music-video');
    if(battleMusic) {
      battleMusic.pause();
      battleMusic.currentTime = 0;
      battleMusic.muted = true;
      battleMusic.remove();
      console.log('üîá M√∫sica de batalla detenida completamente - entrando al campo de batalla');
    }
    
    // Remover activador manual si existe
    const manualActivator = document.getElementById('manual-music-activator');
    if(manualActivator) {
      manualActivator.remove();
      console.log('üîá Activador manual removido');
    }

    // Configurar botones seg√∫n el personaje
    const actions = document.getElementById('actions');
    actions.innerHTML = '';

    const addButton = (id, text) => {
      const btn = document.createElement('div');
      btn.id = id;
      btn.className = 'action-btn';
      btn.textContent = text;
      actions.appendChild(btn);
      return btn;
    };

    addButton('jump', 'JUMP');

    if(char === 'neji') {
      addButton('btn-byak', 'BYAK').addEventListener('touchstart', activateByakugan);
      addButton('btn-juken', 'JUKEN').addEventListener('touchstart', activateJuken);
      addButton('btn-64', '64P').addEventListener('touchstart', activate64Palms);
      addButton('btn-128', '128P').addEventListener('touchstart', activate128Palms);
      addButton('btn-kaiten', 'KAIT').addEventListener('touchstart', activateKaiten);
      addButton('btn-kusho', 'KUSH').addEventListener('touchstart', activateKusho);
      addButton('btn-det', 'DET').addEventListener('touchstart', activateDetect);
    } else if(char === 'itachi') {
      addButton('btn-sharingan', 'SHAR').addEventListener('touchstart', activateSharingan);
      addButton('btn-amaterasu', 'AMAT').addEventListener('touchstart', activateAmaterasu);
      addButton('btn-tsukuyomi', 'TSUK').addEventListener('touchstart', activateTsukuyomi);
      addButton('btn-susanoo', 'SUSA').addEventListener('touchstart', activateSusanoo);
    } else if(char === 'ino') {
      addButton('btn-mind-transfer', 'MIND').addEventListener('touchstart', activateMindTransfer);
      addButton('btn-chakra-bomb', 'BOMB').addEventListener('touchstart', activateChakraBomb);
      addButton('btn-mind-control', 'CTRL').addEventListener('touchstart', activateMindControl);
      addButton('btn-healing', 'HEAL').addEventListener('touchstart', activateHealing);
    } else if(char === 'shikamaru') {
      addButton('btn-shadow-possession', 'POSS').addEventListener('touchstart', activateShadowPossession);
      addButton('btn-shadow-strangle', 'STRN').addEventListener('touchstart', activateShadowStrangle);
    } else if(char === 'tenten') {
      addButton('btn-weapon-summon', 'SUMM').addEventListener('touchstart', activateWeaponSummoning);
      addButton('btn-kunai-rain', 'RAIN').addEventListener('touchstart', activateKunaiRain);
    } else if(char === 'hinata') {
      addButton('btn-gentle-fist', 'GENT').addEventListener('touchstart', activateGentleFist);
      addButton('btn-twin-lions', 'LION').addEventListener('touchstart', activateTwinLionFists);
    } else if(char === 'temari') {
      addButton('btn-fan-dance', 'FAN').addEventListener('touchstart', activateFanDance);
      addButton('btn-whirlwind', 'WIND').addEventListener('touchstart', activateWhirlwind);
    } else if(char === 'sasuke') {
      addButton('btn-chidori', 'CHID').addEventListener('touchstart', activateChidori);
      addButton('btn-kirin', 'KIRI').addEventListener('touchstart', activateKirin);
      addButton('btn-sharingan', 'SHAR').addEventListener('touchstart', activateSharingan);
      addButton('btn-amaterasu', 'AMAT').addEventListener('touchstart', activateAmaterasu);
    } else if(char === 'hashirama') {
      addButton('btn-mokuton', 'MOKU').addEventListener('touchstart', activateMokuton);
      addButton('btn-senjutsu', 'SENJ').addEventListener('touchstart', activateSenjutsu);
      addButton('btn-regen', 'REGEN').addEventListener('touchstart', activateRegeneration);
      addButton('btn-goju', 'GOJU').addEventListener('touchstart', activateGojuMokuton);
    }

    // Habilidades de Hashirama
    function activateMokuton() {
      // Crear plataforma principal de madera
      let mainWood = new THREE.Group(); // Usar un grupo para mejor control
      
      let woodBase = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.3, 4),
        new THREE.MeshStandardMaterial({
          color: 0x8B4513,
          roughness: 0.8,
          metalness: 0.2
        })
      );
      mainWood.add(woodBase);
      
      // A√±adir barandillas para mejor estabilidad visual
      for(let x = -1; x <= 1; x += 2) {
        let rail = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 4),
          new THREE.MeshStandardMaterial({color: 0x8B4513})
        );
        rail.position.set(x * 0.9, 0.4, 0);
        mainWood.add(rail);
      }

      // A√±adir detalles decorativos
      for(let i = 0; i < 6; i++) {
        let detail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.05, 0.8),
          new THREE.MeshStandardMaterial({color: 0x8B4513})
        );
        detail.position.set(
          (i % 2 ? 0.9 : -0.9),
          0.3,
          (i/2 - 1) * 1.5
        );
        mainWood.add(detail);
      }

      // Posicionar la plataforma y el jugador
      mainWood.position.copy(player.position);
      mainWood.position.y = player.position.y - 0.5; // Ajustar altura inicial
      scene.add(mainWood);
      
      // Vincular el jugador a la plataforma
      let playerOffset = new THREE.Vector3(0, 1.75, 0);
      
      // Animaci√≥n de surfeo mejorada
      let time = 0;
      let woodPath = [];
      let pathInterval = setInterval(() => {
        time += 0.1;
        
        // Movimiento m√°s suave
        mainWood.position.y += Math.sin(time * 2) * 0.015; // Movimiento vertical m√°s sutil
        mainWood.position.z -= 0.4; // Velocidad reducida para mayor control
        mainWood.rotation.x = Math.sin(time) * 0.05; // Rotaci√≥n m√°s suave
        
        // Mantener al jugador firmemente sobre la plataforma
        player.position.copy(mainWood.position).add(playerOffset);
        player.rotation.x = mainWood.rotation.x; // Sincronizar rotaci√≥n
        
        // Crear rastro de madera
        let trail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.1, 2),
          new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            transparent: true,
            opacity: 0.7
          })
        );
        trail.position.copy(mainWood.position).add(new THREE.Vector3(0, -2, 2));
        trail.rotation.x = Math.PI/6;
        scene.add(trail);
        woodPath.push(trail);

        // Desvanecer rastro
        woodPath.forEach((w, i) => {
          w.material.opacity -= 0.05;
          if(w.material.opacity <= 0) {
            scene.remove(w);
            woodPath.splice(i, 1);
          }
        });

        // Efecto de da√±o a enemigos
        enemies.forEach(e => {
          if(e.position.distanceTo(mainWood.position) < 3) {
            e.userData.hp -= 5;
            let impact = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshBasicMaterial({
                color: 0x8B4513,
                transparent: true,
                opacity: 0.5
              })
            );
            impact.position.copy(e.position);
            scene.add(impact);
            setTimeout(() => scene.remove(impact), 300);
          }
        });

      }, 50);

      // Detener animaci√≥n despu√©s de 3 segundos
      setTimeout(() => {
        clearInterval(pathInterval);
        scene.remove(mainWood);
        woodPath.forEach(w => scene.remove(w));
        player.position.y = originalY;
      }, 3000);
    }

    function activateSenjutsu() {
      // Modo Sabio
      player.children.forEach(part => {
        part.material.color.setHex(0xFF4500);
      });
      playerSpeed *= 1.5;
      setTimeout(() => {
        player.children.forEach(part => {
          part.material.color.setHex(0xeeeeee);
        });
        playerSpeed /= 1.5;
      }, 10000);
    }

    function activateRegeneration() {
      // Regeneraci√≥n de vida
      let heal = setInterval(() => {
        if(playerHealth < MAX_HEALTH) {
          playerHealth++;
          updatePlayerHUD();
        }
      }, 500);
      setTimeout(() => clearInterval(heal), 5000);
    }

    function activateGojuMokuton() {
      // Golem de Madera gigante
      let golem = new THREE.Group();
      let body = new THREE.Mesh(
        new THREE.BoxGeometry(4, 6, 3),
        new THREE.MeshStandardMaterial({color: 0x8B4513})
      );
      golem.add(body);
      golem.position.copy(player.position);
      scene.add(golem);
      
      let cnt = 0;
      let iv = setInterval(() => {
        golem.position.z -= 0.5;
        enemies.forEach(e => {
          if(e.position.distanceTo(golem.position) < 4) {
            e.userData.hp -= 15;
            flash(e.position);
          }
        });
        if(++cnt > 40) {
          clearInterval(iv);
          scene.remove(golem);
        }
      }, 100);
    }

    init();
    animate();
  }

  function changeStage(level) {
    // Limpiar enemigos actuales y aliados
    enemies.forEach(e => {
      scene.remove(e);
      enemyHUD[e.userData.id].remove();
      delete enemyHUD[e.userData.id];
    });
    enemies = [];

    if(ally) {
      scene.remove(ally);
      ally = null;
    }

    if(pain) {
      scene.remove(pain);
      painPaths.forEach(p => scene.remove(p));
      pain = null;
      painPaths = [];
    }

    // Ajustar vida del jugador seg√∫n el nivel
    if(level === 11) {
      playerHealth = 18;
      createPainBoss();
    } else if(level === 10) {
      playerHealth = 15;
      createAlly();
      // Spawn en √°rea m√°s segura
      player.position.set(-90, 1.25, -90);
    }

    // Ajustar velocidad a partir del nivel 5
    playerSpeed = level >= 5 ? 0.3 : 0.15;

    // Cambiar escenario seg√∫n el nivel
    switch(level) {
      case 1: // Bosque
        scene.background = new THREE.Color(0x2E8B57);
        floor.material.color.setHex(0x228B22);
        break;
      case 2: // Lluvia
        scene.background = new THREE.Color(0x4A708B);
        floor.material.color.setHex(0x4F666A);
        // Efecto de lluvia
        addRainEffect();
        break;
      case 3: // Valle del Fin
        scene.background = new THREE.Color(0xCD853F);
        floor.material.color.setHex(0x8B4513);
        break;
      case 4: // Cueva
        scene.background = new THREE.Color(0x2F4F4F);
        floor.material.color.setHex(0x363636);
        break;
    }

    // A√±adir nuevos enemigos
    for(let i = 0; i < STAGES[level].enemies; i++) {
      addEnemy();
    }

    // Restaurar algo de vida al jugador
    playerHealth = Math.min(playerHealth + 30, 100);
    updatePlayerHUD();
  }

  function addRainEffect() {
    const rainCount = 1000;
    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = [];

    for(let i = 0; i < rainCount; i++) {
      rainPositions.push(
        Math.random() * 200 - 100,
        Math.random() * 50,
        Math.random() * 200 - 100
      );
    }

    rainGeometry.setAttribute('position', 
      new THREE.Float32BufferAttribute(rainPositions, 3)
    );

    const rainMaterial = new THREE.PointsMaterial({
      color: 0x99ccff,
      size: 0.1,
      transparent: true,
      opacity: 0.6
    });

    const rain = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rain);

    // Animaci√≥n de lluvia
    function animateRain() {
      const positions = rain.geometry.attributes.position.array;
      for(let i = 0; i < positions.length; i += 3) {
        positions[i + 1] -= 0.5;
        if(positions[i + 1] < 0) positions[i + 1] = 50;
      }
      rain.geometry.attributes.position.needsUpdate = true;
      requestAnimationFrame(animateRain);
    }
    animateRain();
  }

  function init(){
    scene=new THREE.Scene();
    scene.background = new THREE.Color(0x000033);
    scene.fog = new THREE.FogExp2(0x000033, 0.02);
    camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,500);

    // Crear textura para las paredes con patr√≥n pixelado
    const wallMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x1a1a2e,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9,
      emissive: 0x004400,
      emissiveIntensity: 0.2
    });

    // Crear paredes pixeladas
    const wallGeometry = new THREE.PlaneGeometry(200, 20);

    // Pared Norte
    const wallNorth = new THREE.Mesh(wallGeometry, wallMaterial);
    wallNorth.position.set(0, 10, -100);
    scene.add(wallNorth);

    // Pared Sur
    const wallSouth = new THREE.Mesh(wallGeometry, wallMaterial);
    wallSouth.position.set(0, 10, 100);
    wallSouth.rotation.y = Math.PI;
    scene.add(wallSouth);

    // Pared Este
    const wallEast = new THREE.Mesh(wallGeometry, wallMaterial);
    wallEast.position.set(100, 10, 0);
    wallEast.rotation.y = -Math.PI/2;
    scene.add(wallEast);

    // Pared Oeste
    const wallWest = new THREE.Mesh(wallGeometry, wallMaterial);
    wallWest.position.set(-100, 10, 0);
    wallWest.rotation.y = Math.PI/2;
    scene.add(wallWest);
    
    camera.position.set(0,5,10);
    renderer=new THREE.WebGLRenderer({antialias:false});
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);

    // luces
    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));
    let dl=new THREE.DirectionalLight(0xffffff,0.8);
    dl.position.set(5,10,7); scene.add(dl);

    // suelo pixelado
    floor=new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshStandardMaterial({color:0x228B22})
    ); floor.rotation.x=-Math.PI/2; scene.add(floor);
    
    // hierba pixelada
    for(let i=0;i<500;i++){
      let b=new THREE.Mesh(
        new THREE.BoxGeometry(0.04,0.6,0.04),
        new THREE.MeshStandardMaterial({color:0x00aa00})
      );
      b.position.set(Math.random()*180-90,0.3,Math.random()*180-90);
      b.rotation.z=(Math.random()-0.5)*0.5;
      scene.add(b);
    }

    // Crear modelo espec√≠fico seg√∫n el personaje seleccionado
    function createCharacterModel(characterType) {
      let characterGroup = new THREE.Group();
      
      if(characterType === 'neji') {
        // Cuerpo de Neji con ropa t√≠pica de Konoha
        let body = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.5, 0.8),
          new THREE.MeshStandardMaterial({
            color: 0xF5F5DC, // Beige claro para la ropa
            roughness: 0.8,
            metalness: 0.1
          })
        );
        
        // Chaleco verde de Konoha
        let vest = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 1.8, 0.85),
          new THREE.MeshStandardMaterial({
            color: 0x228B22, // Verde Konoha
            roughness: 0.9
          })
        );
        vest.position.y = 0.3;
        
        // Cabeza con tono de piel realista
        let head = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({
            color: 0xFFDBB3, // Tono de piel
            roughness: 0.6
          })
        );
        head.position.y = 1.8;
        
        // CABELLO LARGO DE NEJI - Mejorado para ser m√°s fiel al personaje
        // Cabello principal largo hasta los hombros
        let hairMain = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.2, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423, // Marr√≥n m√°s claro y realista
            roughness: 0.7
          })
        );
        hairMain.position.set(0, 2.1, 0);
        
        // Cabello trasero largo hasta la cintura - MECH√ìN PRINCIPAL
        let hairBack = new THREE.Mesh(
          new THREE.BoxGeometry(1.0, 3.5, 0.4),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423, // Mismo tono
            roughness: 0.7
          })
        );
        hairBack.position.set(0, 1.0, -0.6);
        
        // MECH√ìN TRASERO EXTRA LARGO caracter√≠stico de Neji
        let hairBackLong = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 4.2, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairBackLong.position.set(0, 0.5, -0.8); // M√°s atr√°s y m√°s largo
        
        // Mech√≥n trasero que llega hasta la espalda baja
        let hairTail = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 2.8, 0.2),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairTail.position.set(0, -0.8, -0.9); // Llega hasta la espalda baja
        
        // Mechones laterales largos caracter√≠sticos
        let hairLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 2.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairLeft.position.set(-0.65, 1.2, 0.2);
        
        let hairRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 2.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairRight.position.set(0.65, 1.2, 0.2);
        
        // Flequillo dividido caracter√≠stico de Neji
        let hairFrontLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairFrontLeft.position.set(-0.3, 2.3, 0.5);
        
        let hairFrontRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairFrontRight.position.set(0.3, 2.3, 0.5);
        
        // Brazos con guantes ninja
        let leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xF5F5DC})
        );
        let rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xF5F5DC})
        );
        leftArm.position.set(-0.8, 0.5, 0);
        rightArm.position.set(0.8, 0.5, 0);
        
        // Guantes ninja pixelados
        let leftGlove = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.6, 0.45),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        let rightGlove = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.6, 0.45),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        leftGlove.position.set(-0.8, -0.2, 0);
        rightGlove.position.set(0.8, -0.2, 0);
        
        // Piernas con pantalones ninja
        let leftLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F}) // Verde oscuro
        );
        let rightLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        leftLeg.position.set(-0.4, -0.8, 0);
        rightLeg.position.set(0.4, -0.8, 0);
        
        // Sandalias ninja pixeladas
        let leftSandal = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.3, 0.8),
          new THREE.MeshStandardMaterial({color: 0x000080}) // Azul oscuro
        );
        let rightSandal = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.3, 0.8),
          new THREE.MeshStandardMaterial({color: 0x000080})
        );
        leftSandal.position.set(-0.4, -1.9, 0.1);
        rightSandal.position.set(0.4, -1.9, 0.1);
        
        // Banda ninja en la frente
        let headband = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.3, 0.2),
          new THREE.MeshStandardMaterial({
            color: 0x000080, // Azul Konoha
            metalness: 0.6,
            roughness: 0.3
          })
        );
        headband.position.set(0, 2.3, 0.4);
        
        // S√≠mbolo de Konoha en la banda
        let konohaSymbol = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.2, 0.05),
          new THREE.MeshStandardMaterial({
            color: 0xFFD700, // Dorado
            metalness: 0.8,
            roughness: 0.2
          })
        );
        konohaSymbol.position.set(0, 2.3, 0.5);
        
        // Efectos especiales para Byakugan
        let byakuganAura = new THREE.Mesh(
          new THREE.SphereGeometry(2.5, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.1,
            side: THREE.DoubleSide
          })
        );
        byakuganAura.visible = false; // Solo visible cuando se activa Byakugan
        
        characterGroup.add(
          body, vest, head, hairMain, hairBack, hairBackLong, hairTail, hairLeft, hairRight, 
          hairFrontLeft, hairFrontRight,
          leftArm, rightArm, leftGlove, rightGlove,
          leftLeg, rightLeg, leftSandal, rightSandal,
          headband, konohaSymbol, byakuganAura
        );
        
        // Guardar referencias para animaciones
        characterGroup.userData.byakuganAura = byakuganAura;
        characterGroup.userData.body = body;
        characterGroup.userData.head = head;
        characterGroup.userData.leftArm = leftArm;
        characterGroup.userData.rightArm = rightArm;
        characterGroup.userData.leftLeg = leftLeg;
        characterGroup.userData.rightLeg = rightLeg;
        
      } else {
        // Modelo gen√©rico para otros personajes
        let body = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.5, 0.8),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let head = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({color: 0xdddddd})
        );
        head.position.y = 1.8;
        
        let leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        leftArm.position.set(-0.8, 0.5, 0);
        rightArm.position.set(0.8, 0.5, 0);
        
        let leftLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let rightLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        leftLeg.position.set(-0.4, -0.8, 0);
        rightLeg.position.set(0.4, -0.8, 0);
        
        characterGroup.add(body, head, leftArm, rightArm, leftLeg, rightLeg);
      }
      
      return characterGroup;
    }

    // Crear el modelo del personaje seg√∫n el tipo seleccionado
    player = createCharacterModel(currentCharacter);
    player.position.set(0,1.25,0); scene.add(player);

    // enemigos
    for(let i=0;i<5;i++) addEnemy();

    // joystick
    const joy=document.getElementById('joystick'),
          thumb=document.getElementById('joy-thumb');
    let origin={x:0,y:0}, tracking=false;
    joy.addEventListener('touchstart',e=>{
      let t=e.touches[0];
      const rect=joy.getBoundingClientRect();
      origin={x:rect.left+rect.width/2,y:rect.top+rect.height/2};
      tracking=true;
    });
    joy.addEventListener('touchmove',e=>{
      if(!tracking) return;
      let t=e.touches[0],
          dx=t.clientX-origin.x,
          dy=t.clientY-origin.y,
          dist=Math.hypot(dx,dy),
          max=50;
      if(dist>max){ dx*=max/dist; dy*=max/dist; }
      thumb.style.transform=`translate(${dx}px,${dy}px)`;
      moveDir.x=dx/max*0.15; moveDir.z=dy/max*0.15;
    });
    joy.addEventListener('touchend',()=>{
      tracking=false;
      thumb.style.transform='translate(0,0)';
      moveDir={x:0,z:0};
    });

    // botones
    document.getElementById('jump')
      .addEventListener('touchstart',_=>{ if(onGround){velY=0.5;onGround=false;}});

    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  }

  function addEnemy(){
    // Limitar enemigos visibles en nivel 10
    if(currentStage === 10 && enemies.length > 50) {
      return;
    }
    let g=new THREE.Group();
    // Cuerpo pixelado
    let b=new THREE.Mesh(
      new THREE.BoxGeometry(1,1.5,1),
      new THREE.MeshStandardMaterial({
        color:0xAA0000,
        roughness: 0.8,
        metalness: 0.5
      })
    );

    g.userData = {
      hp: STAGES[currentStage].enemyHealth,
      id: THREE.MathUtils.generateUUID()
    };
    // Cabeza pixelada
    let h=new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({
        color:0xFF4444,
        emissive: 0xFF0000,
        emissiveIntensity: 0.5
      })
    );
    h.position.y=1.25;

    // Garras pixeladas
    let clawGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.1);
    for(let i = 0; i < 3; i++) {
      let claw = new THREE.Mesh(clawGeometry, new THREE.MeshStandardMaterial({color: 0x660000}));
      claw.position.set(0.3 * (i-1), 0, 0.6);
      b.add(claw);
    }
    g.add(b,h);

    // Efecto de distorsi√≥n en Tsukuyomi
    g.userData.originalScale = g.scale.clone();
    g.userData.tsukuyomiActive = false;
    g.position.set(Math.random()*40-20,0.75,Math.random()*40-20);
    g.userData={hp:200,id:THREE.MathUtils.generateUUID()};
    scene.add(g); enemies.push(g);
    // HUD
    let container=document.createElement('div');
    document.body.appendChild(container);
    enemyHUD[g.userData.id]=container;
  }

  function createAlly() {
    // Crear dos aliados: Ino y Hinata
    allies = [];
    const allyData = [
      {name: 'Ino', color: 0x800080, x: 3},
      {name: 'Hinata', color: 0x4B0082, x: -3}
    ];

    allyData.forEach(data => {
      let allyChar = new THREE.Group();
      let body = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 2.5, 0.8),
        new THREE.MeshStandardMaterial({color: data.color})
      );
      let head = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshStandardMaterial({color: 0xFFE4B5})
      );
      head.position.y = 1.8;
      allyChar.add(body, head);
      allyChar.position.set(player.position.x + data.x, 1.25, player.position.z);
      allyChar.userData = {name: data.name};
      scene.add(allyChar);
      allies.push(allyChar);
    });
    // IA del aliado
    setInterval(() => {
      allies.forEach(allyChar => {
        if(enemies.length > 0) {
          // Encontrar enemigo m√°s cercano
          let closest = enemies.reduce((prev, curr) => 
            prev.position.distanceTo(allyChar.position) < curr.position.distanceTo(allyChar.position) ? prev : curr
          );

          // Moverse hacia el enemigo
          let dir = closest.position.clone().sub(allyChar.position).normalize().multiplyScalar(0.1);
          allyChar.position.add(dir);

          // Usar poderes aleatorios
          if(Math.random() < 0.1) {
            if(allyChar.userData.name === 'Ino') {
              let power = Math.floor(Math.random() * 4);
              switch(power) {
                case 0: activateMindTransfer(); break;
                case 1: activateChakraBomb(); break;
                case 2: activateMindControl(); break;
                case 3: activateHealing(); break;
              }
            } else if(allyChar.userData.name === 'Hinata') {
              let power = Math.floor(Math.random() * 2);
              switch(power) {
                case 0: activateGentleFist(); break;
                case 1: activateTwinLionFists(); break;
              }
            }
          }
        }
      });
    }, 100);
  }

function createPainBoss() {
  pain = new THREE.Group();

  // Crear modelo de Pain pixelado
  let body = new THREE.Mesh(
    new THREE.BoxGeometry(1.6, 3, 1.2),
    new THREE.MeshStandardMaterial({color: 0x000000})
  );
  let head = new THREE.Mesh(
    new THREE.BoxGeometry(1.4, 1.4, 1.4),
    new THREE.MeshStandardMaterial({color: 0xFF4500})
  );
  head.position.y = 2;

  // A√±adir piercings caracter√≠sticos pixelados
  for(let i = 0; i < 6; i++) {
    let piercing = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.2, 0.2),
      new THREE.MeshStandardMaterial({color: 0x808080})
    );
    piercing.position.set(
      Math.cos(i * Math.PI/3) * 0.4,
      2,
      Math.sin(i * Math.PI/3) * 0.4
    );
    pain.add(piercing);
  }

  pain.add(body, head);
  pain.position.set(0, 1.5, -20);
  pain.userData = {hp: 1000, id: 'pain'};
  scene.add(pain);
  enemies.push(pain);

  // IA de Pain
  setInterval(() => {
    if(pain.userData.hp > 0) {
      // Movimiento estrat√©gico
      let dir = player.position.clone().sub(pain.position);
      if(dir.length() > 10) {
        dir.normalize().multiplyScalar(0.2);
        pain.position.add(dir);
      }

      // Ataques de Pain
      if(Math.random() < 0.1) {
        let attack = Math.floor(Math.random() * 5);
        switch(attack) {
          case 0: // Shinra Tensei
            let blast = new THREE.Mesh(
              new THREE.BoxGeometry(20, 20, 20),
              new THREE.MeshBasicMaterial({color: 0x4B0082, transparent: true, opacity: 0.3})
            );
            blast.position.copy(pain.position);
            scene.add(blast);
            setTimeout(() => scene.remove(blast), 1000);
            if(player.position.distanceTo(pain.position) < 15) {
              playerHealth -= 2;
            }
            break;

          case 1: // Bansho Tenin
            let pull = player.position.clone().sub(pain.position).normalize().multiplyScalar(-0.5);
            player.position.add(pull);
            break;

          case 2: // Chibaku Tensei
            let sphere = new THREE.Mesh(
              new THREE.BoxGeometry(4, 4, 4),
              new THREE.MeshBasicMaterial({color: 0x000000})
            );
            sphere.position.copy(player.position).add(new THREE.Vector3(0, 10, 0));
            scene.add(sphere);
            setTimeout(() => scene.remove(sphere), 3000);
            player.position.y += 0.3;
            break;
        }
      }
    }
  }, 100);
}

function animate(){
    requestAnimationFrame(animate);
    // Animaci√≥n de brazos y piernas al moverse - MEJORADA
    if(moveDir.x !== 0 || moveDir.z !== 0) {
      let time = Date.now() * 0.002; // Velocidad m√°s lenta para animaci√≥n m√°s natural
      
      // Usar referencias espec√≠ficas para animaciones m√°s precisas
      if(player.userData.leftArm) {
        player.userData.leftArm.rotation.x = Math.sin(time * 4) * 0.3; // Movimiento m√°s sutil
      }
      if(player.userData.rightArm) {
        player.userData.rightArm.rotation.x = Math.sin(time * 4 + Math.PI) * 0.3;
      }
      if(player.userData.leftLeg) {
        player.userData.leftLeg.rotation.x = Math.sin(time * 4 + Math.PI) * 0.4;
      }
      if(player.userData.rightLeg) {
        player.userData.rightLeg.rotation.x = Math.sin(time * 4) * 0.4;
      }
      
      // Balanceo sutil del cuerpo
      if(player.userData.body) {
        player.userData.body.rotation.z = Math.sin(time * 2) * 0.05;
      }
    } else {
      // Resetear posiciones cuando no se mueve
      if(player.userData.leftArm) player.userData.leftArm.rotation.x = 0;
      if(player.userData.rightArm) player.userData.rightArm.rotation.x = 0;
      if(player.userData.leftLeg) player.userData.leftLeg.rotation.x = 0;
      if(player.userData.rightLeg) player.userData.rightLeg.rotation.x = 0;
      if(player.userData.body) player.userData.body.rotation.z = 0;
    }
    // movimiento + salto + colisiones con paredes (ahora relativo a la c√°mara)
    updateMovementDirection();

    velY+=GRAV; player.position.y+=velY;
    if(player.position.y<=1.25){player.position.y=1.25;velY=0;onGround=true;}
    // C√°mara libre 360¬∞ tipo Roblox
    updateFreeCamera();
    // poderes y colisiones (como antes)...
    powers.forEach((p,i)=>{
      p.mesh.position.add(p.vel);
      p.life--;
      enemies.forEach(e=>{
        if(p.life>0 && p.mesh.position.distanceTo(e.position)<1.2){
          e.userData.hp-=p.damage; p.life=0; flash(e.position);
          // Reproducir sonido de impacto cuando el poder golpea al enemigo
          playImpactSound();
        }
      });
      if(p.life<=0){ scene.remove(p.mesh); powers.splice(i,1); }
    });
    // IA enemigos + HUD + muerte + da√±o al jugador
    enemies.forEach((e,i)=>{
      let dir=player.position.clone().sub(e.position).setY(0).normalize().multiplyScalar(0.005);
      e.position.add(dir);

      // Actualizar barra de vida del enemigo
      let container = enemyHUD[e.userData.id],
          vp=e.position.clone().project(camera),
          x=(vp.x*0.5+0.5)*innerWidth,
          y=(-vp.y*0.5+0.5)*innerHeight - 50;
      container.innerHTML = '';
      container.className = 'enemy-hearts';
      container.style.transform = `translate(${x}px,${y}px)`;
      for(let i = 0; i < STAGES[currentStage].enemyHealth; i++) {
        const heart = document.createElement('div');
        heart.className = `enemy-heart ${i >= e.userData.hp ? 'heart-empty' : ''}`;
        container.appendChild(heart);
      }

      // Da√±o al jugador cuando est√° cerca
      if(e.position.distanceTo(player.position) < 2) {
        playerHealth -= 1; // Quitar 1 vida por golpe
        // Reproducir sonido de impacto cuando el enemigo golpea al jugador
        playImpactSound();
        
        // Efecto visual de da√±o
        let dmgFlash = document.createElement('div');
        dmgFlash.style.cssText = `
          position:fixed;top:0;left:0;width:100%;height:100%;
          background:rgba(255,0,0,0.3);pointer-events:none;
          animation:flash 0.5s forwards;
        `;
        document.body.appendChild(dmgFlash);
        setTimeout(() => dmgFlash.remove(), 500);

        updatePlayerHUD();
        if(playerHealth <= 0) {
          alert('¬°GAME OVER! - NIVEL ' + currentStage);
          location.reload();
        }
      }

      if(e.userData.hp<=0){
        scene.remove(e); container.remove();
        enemies.splice(i,1); delete enemyHUD[e.userData.id];

        // Verificar si pasamos de nivel
        if(enemies.length === 0) {
          currentStage++;
          if(currentStage in STAGES) {
            alert('¬°NIVEL ' + currentStage + ' - ' + STAGES[currentStage].name + '!');
            changeStage(currentStage);
          } else {
            alert('¬°FELICIDADES! ¬°HAS COMPLETADO TODOS LOS NIVELES!');
            location.reload();
          }
        }
      }
    });
    renderer.render(scene,camera);
  }

  function flash(pos){
    let m=new THREE.Mesh(
      new THREE.BoxGeometry(1,1,1),
      new THREE.MeshBasicMaterial({color:0xffff00})
    );
    m.position.copy(pos); scene.add(m);
    setTimeout(()=>scene.remove(m),200);
  }

  // Funci√≥n para reproducir sonido de poder a distancia
  function playProjectileSound() {
    let projectileSound = document.createElement('video');
    projectileSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    projectileSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-975843560396402730.mp4?updatedAt=1748455137385';
    projectileSound.autoplay = true;
    projectileSound.muted = false;
    projectileSound.volume = 0.7;
    projectileSound.preload = 'auto';
    
    document.body.appendChild(projectileSound);
    
    projectileSound.play().catch(e => {
      console.log('Projectile sound autoplay error:', e);
      projectileSound.muted = true;
      projectileSound.play().then(() => {
        projectileSound.muted = false;
      });
    });

    // Remover despu√©s de 2 segundos
    setTimeout(() => {
      projectileSound.remove();
    }, 2000);
  }

  // Funci√≥n para reproducir sonido de impacto/golpe
  function playImpactSound() {
    let impactSound = document.createElement('video');
    impactSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    impactSound.src = 'https://ik.imagekit.io/lcpvlmgbf/copy_21E0A2DA-745D-4447-B493-140B9050A5A2.mov/ik-video.mp4?updatedAt=1748454860763';
    impactSound.autoplay = true;
    impactSound.muted = false;
    impactSound.volume = 0.8;
    impactSound.preload = 'auto';
    
    document.body.appendChild(impactSound);
    
    impactSound.play().catch(e => {
      console.log('Impact sound autoplay error:', e);
      impactSound.muted = true;
      impactSound.play().then(() => {
        impactSound.muted = false;
      });
    });

    // Remover despu√©s de 1.5 segundos
    setTimeout(() => {
      impactSound.remove();
    }, 1500);
  }

  // ‚îÄ‚îÄ‚îÄ T√âCNICAS ‚îÄ‚îÄ‚îÄ

  function activateByakugan(){
    // Pausar YouTube mientras suena el Byakugan
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Byakugan mejorado con video HTML5
    let byakuganSound = document.createElement('video');
    byakuganSound.id = 'byakugan-sound';
    byakuganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    byakuganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-4196672225765940788.mp4?updatedAt=1748454278148';
    byakuganSound.autoplay = true;
    byakuganSound.muted = false;
    byakuganSound.volume = 1.0;
    byakuganSound.preload = 'auto';
    
    // Forzar reproducci√≥n inmediata
    document.body.appendChild(byakuganSound);
    
    byakuganSound.play().then(() => {
      console.log('Byakugan sound playing!');
    }).catch(e => {
      console.log('Byakugan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      byakuganSound.muted = true;
      byakuganSound.play().then(() => {
        byakuganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      byakuganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Byakugan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 3000);

    // Activar aura de Byakugan en Neji
    if(player.userData.byakuganAura) {
      player.userData.byakuganAura.visible = true;
      let pulseTime = 0;
      let pulseInterval = setInterval(() => {
        pulseTime += 0.1;
        player.userData.byakuganAura.material.opacity = 0.1 + Math.sin(pulseTime * 4) * 0.15;
        player.userData.byakuganAura.scale.setScalar(1 + Math.sin(pulseTime * 2) * 0.1);
      }, 50);
      
      setTimeout(() => {
        clearInterval(pulseInterval);
        player.userData.byakuganAura.visible = false;
      }, 5000);
    }

    // pupilas blancas + venas (overlay CSS) mejorado
    let ov=document.createElement('div');
    ov.style.cssText=`
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,0.4) 20%, transparent 70%),
        repeating-linear-gradient(45deg,
          rgba(255,255,255,0.3) 0px, rgba(255,255,255,0.3) 4px,
          transparent 4px, transparent 8px),
        repeating-linear-gradient(-45deg,
          rgba(200,200,255,0.2) 0px, rgba(200,200,255,0.2) 2px,
          transparent 2px, transparent 4px);
      pointer-events:none;
      animation: pixel-scan 1.2s steps(4) forwards;
      box-shadow: inset 0 0 100px rgba(255,255,255,0.3);
    `;
    document.body.appendChild(ov);
    setTimeout(()=>ov.remove(),1200);
    
    // auras en enemigos mejoradas con efecto de rayos X
    enemies.forEach(e=>{
      let aura=new THREE.Mesh(
        new THREE.BoxGeometry(3,0.1,3),
        new THREE.MeshBasicMaterial({color:0x00ffff,side:THREE.DoubleSide,transparent:true,opacity:0.3})
      );
      aura.rotation.x=-Math.PI/2;
      aura.position.copy(e.position).add(new THREE.Vector3(0,1,0));
      scene.add(aura);
      
      // Efecto de chakra visible
      let chakraPoints = [];
      for(let i = 0; i < 8; i++) {
        let chakraPoint = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.2),
          new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8
          })
        );
        chakraPoint.position.copy(e.position).add(new THREE.Vector3(
          Math.cos(i * Math.PI / 4) * 1.5,
          Math.random() * 2,
          Math.sin(i * Math.PI / 4) * 1.5
        ));
        scene.add(chakraPoint);
        chakraPoints.push(chakraPoint);
      }
      
      setTimeout(()=>{
        scene.remove(aura);
        chakraPoints.forEach(point => scene.remove(point));
      }, 1200);
    });
  }

  function activateJuken(){
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    // golpe suave: pulso pixelado
    let p=new THREE.Mesh(
      new THREE.BoxGeometry(1,1,1),
      new THREE.MeshBasicMaterial({color:0xffa500,transparent:true,opacity:0.8})
    );
    // Posici√≥n de la mano derecha
    p.position.copy(player.position).add(new THREE.Vector3(0.8, 1.5, 0));
    scene.add(p);
    powers.push({mesh:p,vel:new THREE.Vector3(0,0,-1),life:40,damage:50});
  }

  function activate64Palms(){
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    for(let i=0;i<64;i++){
      let a=(i/64)*Math.PI*2;
      let orb=new THREE.Mesh(
        new THREE.BoxGeometry(0.3,0.3,0.3),
        new THREE.MeshBasicMaterial({color:0x66ccff})
      );
      orb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
      scene.add(orb);
      powers.push({
        mesh:orb,
        vel:new THREE.Vector3(Math.cos(a)*0.7,0,Math.sin(a)*0.7),
        life:50,damage:10
      });
    }
  }

  function activate128Palms(){
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    for(let i=0;i<128;i++){      let a=(i/128)*Math.PI*2;
      let orb=new THREE.Mesh(
        new THREE.BoxGeometry(0.24,0.24,0.24),
        new THREE.MeshBasicMaterial({color:0x00ffff})
      );
      orb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
      scene.add(orb);
      powers.push({
        mesh:orb,
        vel:new THREE.Vector3(Math.cos(a)*0.9,0,Math.sin(a)*0.9),
        life:40,damage:8
      });
    }
  }

  function activateKaiten(){
    let t=new THREE.Mesh(
      new THREE.BoxGeometry(6,0.8,6),
      new THREE.MeshBasicMaterial({color:0x99ccff,transparent:true,opacity:0.4})
    );
    t.rotation.x=Math.PI/2; player.add(t);
    let cnt=0, iv=setInterval(()=>{
      t.rotation.z+=0.6;
      enemies.forEach(e=>{
        if(t.getWorldPosition(new THREE.Vector3()).distanceTo(e.position)<3)
          e.userData.hp-=3;
      });
      if(++cnt>30){ clearInterval(iv); player.remove(t); }
    },40);
  }

  function activateKusho(){
    // onda de vac√≠o pixelada
    let ring=new THREE.Mesh(
      new THREE.BoxGeometry(1.4,0.2,1.4),
      new THREE.MeshBasicMaterial({color:0xff00ff,side:THREE.DoubleSide,transparent:true,opacity:0.6})
    );
    ring.rotation.x=-Math.PI/2;
    ring.position.copy(player.position);
    scene.add(ring);
    let scale=1, iv=setInterval(()=>{
      scale+=0.5;
      ring.scale.set(scale,scale,scale);
      ring.material.opacity-=0.05;
      enemies.forEach(e=>{
        if(e.position.distanceTo(player.position)<scale*1.2)
          e.userData.hp-=4;
      });
      if(scale>6){ clearInterval(iv); scene.remove(ring); }
    },50);
  }

  function activateDetect(){
    // identifica clones/ilusiones: parpadea a los enemigos ocultos
    enemies.forEach(e=>{
      let highlight=new THREE.Mesh(
        new THREE.BoxGeometry(3.6,3.6,3.6),
        new THREE.MeshBasicMaterial({color:0xffff00,wireframe:true,transparent:true,opacity:0.5})
      );
      highlight.position.copy(e.position);
      scene.add(highlight);
      setTimeout(()=>scene.remove(highlight),1500);
    });
  }

  // Nuevos poderes de Itachi
  function activateSharingan() {
    // Pausar YouTube mientras suena el Sharingan
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Sharingan con video HTML5
    let sharinganSound = document.createElement('video');
    sharinganSound.id = 'sharingan-sound';
    sharinganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    sharinganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/4094554501659701029.mp4?updatedAt=1748454278815';
    sharinganSound.autoplay = true;
    sharinganSound.muted = false;
    sharinganSound.volume = 1.0;
    sharinganSound.preload = 'auto';
    
    // Forzar reproducci√≥n inmediata
    document.body.appendChild(sharinganSound);
    
    sharinganSound.play().then(() => {
      console.log('Sharingan sound playing!');
    }).catch(e => {
      console.log('Sharingan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      sharinganSound.muted = true;
      sharinganSound.play().then(() => {
        sharinganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      sharinganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Sharingan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 2500);

    // Efecto visual mejorado del Sharingan pixelado
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:
        repeating-conic-gradient(from 0deg,
          rgba(255,0,0,0.2) 0deg 45deg,
          rgba(0,0,0,0.4) 45deg 90deg);
      background-size: 32px 32px;
      pointer-events:none;
      animation: pixel-sharingan 2s steps(4) infinite;
    `;
    
    // A√±adir tomoes giratorios pixelados
    let tomoe = document.createElement('div');
    tomoe.style.cssText = `
      position:fixed;top:50%;left:50%;
      width:200px;height:200px;
      transform:translate(-50%,-50%);
      background:
        repeating-conic-gradient(from 0deg,
          #ff0000 0deg 30deg,
          #000000 30deg 60deg);
      background-size: 32px 32px;
      animation: pixel-spin 4s steps(8) infinite;
      pointer-events:none;
      z-index:1000;
      image-rendering: pixelated;
    `;
    
    document.body.appendChild(overlay);
    document.body.appendChild(tomoe);
    
    // Aumentar velocidad y precisi√≥n temporalmente
    let originalSpeed = playerSpeed;
    playerSpeed *= 1.5;
    
    // Marcar enemigos con auras m√°s visibles
    enemies.forEach(e => {
      let aura = new THREE.Mesh(
        new THREE.BoxGeometry(5,0.2,5),
        new THREE.MeshBasicMaterial({
          color:0xff0000,
          side:THREE.DoubleSide,
          transparent:true,
          opacity:0.5
        })
      );
      
      // A√±adir marcadores pixelados alrededor del enemigo
      for(let i = 0; i < 3; i++) {
        let marker = new THREE.Mesh(
          new THREE.BoxGeometry(0.4,0.4,0.4),
          new THREE.MeshBasicMaterial({color:0xff0000})
        );
        marker.position.copy(e.position).add(new THREE.Vector3(
          Math.cos(i * Math.PI * 2/3) * 2,
          1,
          Math.sin(i * Math.PI * 2/3) * 2
        ));
        scene.add(marker);
        setTimeout(() => scene.remove(marker), 5000);
      }
      
      aura.rotation.x = -Math.PI/2;
      aura.position.copy(e.position).add(new THREE.Vector3(0,1,0));
      scene.add(aura);
      
      // Animar aura
      let pulseInterval = setInterval(() => {
        aura.scale.x = 1 + Math.sin(Date.now() * 0.005) * 0.2;
        aura.scale.y = aura.scale.x;
      }, 50);
      
      setTimeout(() => {
        clearInterval(pulseInterval);
        scene.remove(aura);
      }, 5000);
      
      // Marcar enemigo como visible a trav√©s de paredes
      e.material.transparent = true;
      e.material.opacity = 0.7;
      setTimeout(() => {
        e.material.transparent = false;
        e.material.opacity = 1;
      }, 5000);
    });

    // Restaurar velocidad normal despu√©s de 5 segundos
    setTimeout(() => {
      playerSpeed = originalSpeed;
      overlay.remove();
      tomoe.remove();
    }, 5000);
  }

  function activateAmaterasu() {
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    let flame = new THREE.Mesh(
      new THREE.BoxGeometry(1,1,1),
      new THREE.MeshBasicMaterial({color:0x000000})
    );
    flame.position.copy(player.position).add(new THREE.Vector3(0,1,0));
    scene.add(flame);
    powers.push({
      mesh: flame,
      vel: new THREE.Vector3(0,0,-1),
      life: 60,
      damage: 100
    });
  }

  function activateTsukuyomi() {
    // Efecto visual mejorado de Tsukuyomi pixelado
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background: 
        repeating-linear-gradient(45deg,
          rgba(0,0,0,0.95) 0px, rgba(0,0,0,0.95) 8px,
          rgba(128,0,0,0.95) 8px, rgba(128,0,0,0.95) 16px);
      background-size: 16px 16px;
      opacity:0;pointer-events:none;
      transition:all 0.5s;
      animation: pixel-tsukuyomi-world 8s steps(8) forwards;
      image-rendering: pixelated;
    `;

    const style = document.createElement('style');
    style.textContent = `
      @keyframes pixel-tsukuyomi-world {
        0% { filter: hue-rotate(0deg) contrast(100%); transform: scale(1); }
        20% { filter: hue-rotate(180deg) contrast(200%); transform: scale(1.2); }
        100% { filter: hue-rotate(360deg) contrast(150%); transform: scale(1.1); }
      }
      
      @keyframes pixel-blood-rain {
        from { transform: translateY(-100%); }
        to { transform: translateY(100%); }
      }
      
      @keyframes pixel-sharingan {
        0% { background-position: 0 0; }
        100% { background-position: 32px 32px; }
      }
      
      @keyframes pixel-spin {
        from { transform: translate(-50%, -50%) rotate(0deg); }
        to { transform: translate(-50%, -50%) rotate(360deg); }
      }
      
      @keyframes pixel-scan {
        0% { background-position: 0 0; }
        100% { background-position: 32px 32px; }
      }
    `;
    document.head.appendChild(style);

    // A√±adir Sharingan giratorio pixelado
    let sharingan = document.createElement('div');
    sharingan.style.cssText = `
      position:fixed;
      top:50%;left:50%;
      width:200px;height:200px;
      background: 
        repeating-conic-gradient(from 0deg,
          #ff0000 0deg 30deg,
          #000000 30deg 60deg);
      background-size: 32px 32px;
      animation: pixel-spin 2s steps(8) infinite;
      z-index:1000;
      pointer-events:none;
      image-rendering: pixelated;
    `;

    document.body.appendChild(overlay);
    document.body.appendChild(sharingan);

    setTimeout(() => {
      overlay.style.opacity = '0.95';
      scene.fog = new THREE.FogExp2(0xff0000, 0.1);
      
      enemies.forEach(enemy => {
        if(enemy.position.distanceTo(player.position) < 10) {
          // Crear cruz pixelada que emerge del suelo
          const cross = document.createElement('div');
          cross.style.cssText = `
            position: fixed;
            width: 200px;
            height: 300px;
            background: 
              repeating-linear-gradient(90deg,
                #8B0000 0px, #8B0000 8px,
                #4B0000 8px, #4B0000 16px);
            top: 50%;
            left: 50%;
            transform: translate(-50%, 100%);
            box-shadow: 0 0 20px #FF0000;
            animation: crossRise 2s steps(4) forwards, crossFloat 2s steps(2) infinite;
            image-rendering: pixelated;
          `;

          // Brazos de la cruz pixelados
          const crossArm = document.createElement('div');
          crossArm.style.cssText = `
            position: absolute;
            width: 150px;
            height: 40px;
            background: 
              repeating-linear-gradient(90deg,
                #8B0000 0px, #8B0000 8px,
                #4B0000 8px, #4B0000 16px);
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 20px #FF0000;
            image-rendering: pixelated;
          `;
          
          cross.appendChild(crossArm);
          document.body.appendChild(cross);
          
          // Enemigo flotando con animaci√≥n pixelada
          let floatHeight = 0;
          const floatInterval = setInterval(() => {
            floatHeight += 0.2;
            if(floatHeight <= 5) {
              enemy.position.y += 0.2;
            }
            enemy.rotation.y += 0.1; // Gira mientras flota
          }, 50);
          enemy.userData.inTsukuyomi = true;
          enemy.userData.floatInterval = floatInterval;
          
          // Lluvia de sangre pixelada
          for(let i = 0; i < 50; i++) {
            const drop = document.createElement('div');
            drop.style.cssText = `
              position: fixed;
              width: 4px;
              height: 20px;
              background: 
                repeating-linear-gradient(180deg,
                  #FF0000 0px, #FF0000 4px,
                  #CC0000 4px, #CC0000 8px);
              left: ${Math.random() * 100}%;
              top: -20px;
              animation: pixel-blood-rain 2s steps(4) infinite;
              animation-delay: ${Math.random() * 2}s;
              image-rendering: pixelated;
            `;
            document.body.appendChild(drop);
            
            setTimeout(() => drop.remove(), 8000);
          }
          
          // Da√±o continuo
          const damageInterval = setInterval(() => {
            enemy.userData.hp -= 10;
            flash(enemy.position);
          }, 500);
          
          setTimeout(() => {
            clearInterval(damageInterval);
            clearInterval(enemy.userData.floatInterval);
            enemy.position.y = 0.75; // Volver a la posici√≥n original
            enemy.userData.inTsukuyomi = false;
            cross.remove();
          }, 7500);
        }
      });
      
    }, 100);

    setTimeout(() => {
      overlay.style.opacity = '0';
      sharingan.remove();
      scene.fog = null;
      setTimeout(() => {
        overlay.remove();
        style.remove();
      }, 500);
    }, 8000);

    // Da√±o mejorado a enemigos
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < 5) {
        e.userData.hp -= 150;
        // Efecto visual de da√±o
        let flash = new THREE.Mesh(
          new THREE.BoxGeometry(4,4,4),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
          })
        );
        flash.position.copy(e.position);
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 500);
      }
    });
  }

  function activateSusanoo() {
    let susanoo = new THREE.Group();
    // Crear forma b√°sica del Susanoo pixelado
    let body = new THREE.Mesh(
      new THREE.BoxGeometry(4,8,4),
      new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.3})
    );
    susanoo.add(body);
    player.add(susanoo);

    let cnt = 0, iv = setInterval(() => {
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < 4) {
          e.userData.hp -= 5;
        }
      });
      if(++cnt > 50) {
        clearInterval(iv);
        player.remove(susanoo);
      }
    }, 100);
  }

  // Habilidades de Ino
  function activateMindTransfer() {
    let beam = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.2, 20),
      new THREE.MeshBasicMaterial({color: 0x9932CC, transparent: true, opacity: 0.6})
    );
    beam.rotation.x = Math.PI/2;
    beam.position.copy(player.position);
    scene.add(beam);

    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < 10) {
        e.userData.hp -= 80;
        e.material = new THREE.MeshBasicMaterial({color: 0x9932CC});
        setTimeout(() => {
          e.material = new THREE.MeshStandardMaterial({color: 0xAA0000});
        }, 2000);
      }
    });

    setTimeout(() => scene.remove(beam), 1000);
  }

  function activateChakraBomb() {
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    let bomb = new THREE.Mesh(
      new THREE.BoxGeometry(0.6,0.6,0.6),
      new THREE.MeshBasicMaterial({color: 0x00FF7F})
    );
    bomb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
    scene.add(bomb);
    powers.push({
      mesh: bomb,
      vel: new THREE.Vector3(0,0,-1),
      life: 30,
      damage: 60
    });
  }

  function activateMindControl() {
    let circle = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.2, 8),
      new THREE.MeshBasicMaterial({color: 0x9400D3, side: THREE.DoubleSide, transparent: true, opacity: 0.4})
    );
    circle.rotation.x = -Math.PI/2;
    circle.position.copy(player.position);
    scene.add(circle);

    let scale = 1;
    let iv = setInterval(() => {
      scale += 0.2;
      circle.scale.set(scale, scale, scale);
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < scale * 2) {
          e.userData.hp -= 3;
          e.rotation.y += 0.2;
        }
      });
      if(scale > 3) {
        clearInterval(iv);
        scene.remove(circle);
      }
    }, 100);
  }

  function activateHealing() {
    let healingField = new THREE.Mesh(
      new THREE.BoxGeometry(6, 0.2, 6),
      new THREE.MeshBasicMaterial({color: 0x98FB98, transparent: true, opacity: 0.3, side: THREE.DoubleSide})
    );
    healingField.rotation.x = -Math.PI/2;
    healingField.position.copy(player.position);
    scene.add(healingField);

    let particles = [];
    for(let i = 0; i < 20; i++) {
      let particle = new THREE.Mesh(
        new THREE.BoxGeometry(0.2,0.2,0.2),
        new THREE.MeshBasicMaterial({color: 0x00FF7F})
      );
      particle.position.copy(player.position);
      scene.add(particle);
      particles.push(particle);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      particles.forEach(p => {
        p.position.y += 0.1;
        p.material.opacity -= 0.05;
      });
      if(++cnt > 20) {
        clearInterval(iv);
        scene.remove(healingField);
        particles.forEach(p => scene.remove(p));
      }
    }, 100);
  }

  // Habilidades de Shikamaru
  function activateShadowPossession() {
    // Animaci√≥n de sombra emergiendo y extendi√©ndose pixelada
    let shadowLength = 0;
    let shadowSegments = [];
    const SEGMENTS = 20;
    const MAX_DISTANCE = 15;

    function createShadowSegment() {
      let segment = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 0.2, 1),
        new THREE.MeshBasicMaterial({
          color: 0x000000, 
          transparent: true, 
          opacity: 0
        })
      );
      segment.position.copy(player.position);
      segment.position.y = 0.01; // Ligeramente sobre el suelo
      scene.add(segment);
      return segment;
    }

    // Crear segmentos iniciales
    for(let i = 0; i < SEGMENTS; i++) {
      shadowSegments.push(createShadowSegment());
    }

    let targetEnemy = null;
    let minDist = Infinity;

    // Encontrar el enemigo m√°s cercano en la direcci√≥n frontal
    enemies.forEach(e => {
      let dirToEnemy = e.position.clone().sub(player.position);
      let angle = dirToEnemy.angleTo(new THREE.Vector3(0, 0, -1));
      if(angle < Math.PI/4 && dirToEnemy.length() < minDist) {
        minDist = dirToEnemy.length();
        targetEnemy = e;
      }
    });

    if(!targetEnemy) {
      shadowSegments.forEach(s => scene.remove(s));
      return;
    }

    let growInterval = setInterval(() => {
      shadowLength += 1;
      let progress = shadowLength / SEGMENTS;

      // Actualizar cada segmento
      shadowSegments.forEach((segment, i) => {
        if(i <= shadowLength) {
          let t = i / SEGMENTS;
          let pos = new THREE.Vector3().lerpVectors(
            player.position,
            targetEnemy.position,
            t
          );
          segment.position.copy(pos);
          segment.lookAt(targetEnemy.position);
          segment.material.opacity = Math.min(0.7, (1 - t) * 0.7);

          // Efecto de emergencia pixelado
          segment.position.y = Math.sin(t * Math.PI) * 0.5;
          segment.scale.y = 1 + Math.sin(t * Math.PI) * 0.5;
        }
      });

      // Cuando la sombra alcanza al enemigo
      if(shadowLength >= SEGMENTS) {
        clearInterval(growInterval);
        targetEnemy.userData.frozen = true;
        targetEnemy.userData.controlled = true;
        targetEnemy.userData.originalPosition = targetEnemy.position.clone();
        targetEnemy.material.color.set(0x000000);

        // Limpiar despu√©s de 5 segundos
        setTimeout(() => {
          shadowSegments.forEach(s => scene.remove(s));
          targetEnemy.userData.frozen = false;
          targetEnemy.userData.controlled = false;
          targetEnemy.material.color.set(0xAA0000);
        }, 5000);
      }
    }, 50);

    // Mantener enemigos paralizados
    let controlInterval = setInterval(() => {
      enemies.forEach(e => {
        if(e.userData.controlled) {
          e.position.copy(e.userData.originalPosition);
          // Efecto visual de par√°lisis pixelado
          let sparkle = new THREE.Mesh(
            new THREE.BoxGeometry(0.2,0.2,0.2),
            new THREE.MeshBasicMaterial({color: 0x000000})
          );
          sparkle.position.copy(e.position).add(new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() * 2,
            Math.random() - 0.5
          ));
          scene.add(sparkle);
          setTimeout(() => scene.remove(sparkle), 500);
        }
      });
    }, 100);

    setTimeout(() => {
      clearInterval(controlInterval);
      enemies.forEach(e => {
        e.userData.frozen = false;
        e.userData.controlled = false;
        e.material.color.set(0xAA0000);
      });
    }, 5000);
  }

  function activateShadowStrangle() {
    let range = 8;
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < range) {
        e.userData.hp -= 70;
        let shadow = new THREE.Mesh(
          new THREE.BoxGeometry(1, 0.2, 1),
          new THREE.MeshBasicMaterial({color: 0x000000})
        );
        shadow.position.copy(e.position).add(new THREE.Vector3(0, 1, 0));
        scene.add(shadow);
        setTimeout(() => scene.remove(shadow), 1000);
      }
    });
  }

  // Habilidades de Tenten
  function activateWeaponSummoning() {
    // Pergamino giratorio pixelado
    let scroll = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.2, 4),
      new THREE.MeshBasicMaterial({color: 0xF5DEB3})
    );
    scroll.position.copy(player.position).add(new THREE.Vector3(0, 2, 0));
    scroll.rotation.x = Math.PI/2;
    scene.add(scroll);

    // Diferentes tipos de armas pixeladas
    const weaponTypes = [
      {geo: new THREE.BoxGeometry(0.2, 1.2, 0.2), color: 0x808080, name: 'kunai'}, // Kunai
      {geo: new THREE.BoxGeometry(0.2, 1.4, 0.2), color: 0x4A4A4A, name: 'sword'}, // Espada
      {geo: new THREE.BoxGeometry(0.3, 0.3, 0.3), color: 0x696969, name: 'shuriken'} // Shuriken
    ];

    let cnt = 0;
    let weaponInterval = setInterval(() => {
      if(cnt > 15) {
        clearInterval(weaponInterval);
        scene.remove(scroll);
        return;
      }

      let weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
      let weapon = new THREE.Mesh(
        weaponType.geo,
        new THREE.MeshBasicMaterial({color: weaponType.color})
      );

      // Aparecer desde el pergamino
      weapon.position.copy(scroll.position);
      weapon.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      scene.add(weapon);
      powers.push({
        mesh: weapon,
        vel: new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 0.5,
          -1
        ).normalize().multiplyScalar(0.3),
        life: 40,
        damage: weaponType.name === 'sword' ? 40 : 25,
        spin: new THREE.Vector3(
          Math.random() * 0.2,
          Math.random() * 0.2,
          Math.random() * 0.2
        )
      });

      cnt++;
    }, 100);

    // Actualizar la funci√≥n animate para hacer girar las armas
    let originalAnimate = animate;
    animate = function() {
      originalAnimate();
      powers.forEach(p => {
        if(p.spin) {
          p.mesh.rotation.x += p.spin.x;
          p.mesh.rotation.y += p.spin.y;
          p.mesh.rotation.z += p.spin.z;
        }
      });
    };
  }

  function activateKunaiRain() {
    for(let i = 0; i < 30; i++) {
      setTimeout(() => {
        let kunai = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.8, 0.2),
          new THREE.MeshBasicMaterial({color: 0x606060})
        );
        kunai.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 10 - 5,
          5,
          Math.random() * 10 - 5
        ));
        scene.add(kunai);
        powers.push({
          mesh: kunai,
          vel: new THREE.Vector3(0, -0.3, 0),
          life: 20,
          damage: 15
        });
      }, i * 100);
    }
  }

  // Habilidades de Hinata
  function activateGentleFist() {
    // Pausar YouTube mientras suena el Byakugan de Hinata
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Byakugan mejorado para Hinata con video HTML5
    let byakuganSound = document.createElement('video');
    byakuganSound.id = 'hinata-byakugan-sound';
    byakuganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    byakuganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-4196672225765940788.mp4?updatedAt=1748454278148';
    byakuganSound.autoplay = true;
    byakuganSound.muted = false;
    byakuganSound.volume = 1.0;
    byakuganSound.preload = 'auto';
    
    // Forzar reproducci√≥n inmediata
    document.body.appendChild(byakuganSound);
    
    byakuganSound.play().then(() => {
      console.log('Hinata Byakugan sound playing!');
    }).catch(e => {
      console.log('Hinata Byakugan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      byakuganSound.muted = true;
      byakuganSound.play().then(() => {
        byakuganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      byakuganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Byakugan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 3000);

    // Animaci√≥n de Byakugan activ√°ndose pixelado
    let byakuganRing = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.2, 2),
      new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.5})
    );
    byakuganRing.rotation.x = -Math.PI/2;
    byakuganRing.position.copy(player.position);
    scene.add(byakuganRing);

    // Reproducir sonido de poder a distancia para los proyectiles
    playProjectileSound();
    
    // M√∫ltiples golpes de Pu√±o Suave pixelados
    for(let i = 0; i < 5; i++) {
      setTimeout(() => {
        let chakra = new THREE.Mesh(
          new THREE.BoxGeometry(0.6,0.6,0.6),
          new THREE.MeshBasicMaterial({color: 0x4169E1, transparent: true, opacity: 0.8})
        );
        chakra.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 2 - 1,
          1,
          Math.random() * 2 - 1
        ));
        scene.add(chakra);
        powers.push({
          mesh: chakra,
          vel: new THREE.Vector3(Math.random() - 0.5, 0, -1).normalize(),
          life: 25,
          damage: 35
        });
      }, i * 200);
    }

    setTimeout(() => scene.remove(byakuganRing), 1000);
  }

  // Temari's Powers
  function activateFanDance() {
    let fan = new THREE.Mesh(
      new THREE.BoxGeometry(6, 3, 0.2),
      new THREE.MeshBasicMaterial({color: 0xF5F5F5})
    );
    fan.position.copy(player.position).add(new THREE.Vector3(0, 1, 1));
    scene.add(fan);

    let angle = 0;
    let iv = setInterval(() => {
      angle += 0.3;
      fan.rotation.y = Math.sin(angle) * 2;
      
      // M√∫ltiples ondas de viento pixeladas
      if(angle > Math.PI) {
        for(let i = 0; i < 3; i++) {
          let wind = new THREE.Mesh(
            new THREE.BoxGeometry(1, 6, 20),
            new THREE.MeshBasicMaterial({color: 0xADD8E6, transparent: true, opacity: 0.4})
          );
          wind.position.copy(player.position).add(new THREE.Vector3(i*2-2, 1, -4));
          wind.rotation.x = Math.PI/2;
          scene.add(wind);
          powers.push({
            mesh: wind,
            vel: new THREE.Vector3(0, 0, -1.5),
            life: 40,
            damage: 120
          });
        }
        clearInterval(iv);
        scene.remove(fan);
      }
    }, 50);
  }

  function activateWhirlwind() {
    let tornado = new THREE.Group();
    for(let i = 0; i < 5; i++) {
      let ring = new THREE.Mesh(
        new THREE.BoxGeometry(2 + i*0.6, 0.4, 2 + i*0.6),
        new THREE.MeshBasicMaterial({color: 0x87CEEB, transparent: true, opacity: 0.4})
      );
      ring.position.y = i;
      tornado.add(ring);
    }
    tornado.position.copy(player.position);
    scene.add(tornado);

    let cnt = 0;
    let iv = setInterval(() => {
      tornado.rotation.y += 0.2;
      tornado.position.z -= 0.3;
      tornado.children.forEach(ring => {
        ring.scale.x = 1 + Math.sin(cnt * 0.2) * 0.2;
      });
      
      enemies.forEach(e => {
        if(e.position.distanceTo(tornado.position) < 3) {
          e.userData.hp -= 5;
          e.position.add(new THREE.Vector3(Math.random()-0.5, 0.2, Math.random()-0.5));
        }
      });

      if(++cnt > 50) {
        clearInterval(iv);
        scene.remove(tornado);
      }
    }, 50);
  }

  // Sasuke's Powers
  function activateChidori() {
    // Reproducir sonido de poder a distancia
    playProjectileSound();
    
    let lightning = new THREE.Group();
    for(let i = 0; i < 20; i++) {
      let bolt = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 1),
        new THREE.MeshBasicMaterial({color: 0x00FFFF})
      );
      bolt.position.set(
        Math.random() * 2 - 1,
        Math.random() * 2,
        Math.random() * 2 - 1
      );
      lightning.add(bolt);
    }
    
    lightning.position.copy(player.position).add(new THREE.Vector3(0, 1, 0));
    scene.add(lightning);

    let vel = new THREE.Vector3(0, 0, -1);
    powers.push({
      mesh: lightning,
      vel: vel,
      life: 30,
      damage: 150
    });
  }

  function activateKirin() {
    // Efecto de rayo en el cielo pixelado
    let skyLightning = new THREE.Mesh(
      new THREE.BoxGeometry(200, 0.4, 200),
      new THREE.MeshBasicMaterial({color: 0x4169E1, transparent: true, opacity: 0.3})
    );
    skyLightning.position.y = 50;
    skyLightning.rotation.x = -Math.PI/2;
    scene.add(skyLightning);

    setTimeout(() => {
      let dragon = new THREE.Group();
      // Crear forma de drag√≥n el√©ctrico pixelado
      for(let i = 0; i < 30; i++) {
        let segment = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 2),
          new THREE.MeshBasicMaterial({color: 0x00FFFF})
        );
        segment.position.z = -i * 2;
        dragon.add(segment);
      }
      dragon.position.set(0, 40, 0);
      scene.add(dragon);

      let cnt = 0;
      let iv = setInterval(() => {
        dragon.position.y -= 2;
        dragon.children.forEach((segment, i) => {
          segment.rotation.z = Math.sin(cnt * 0.3 + i * 0.2) * 0.3;
        });

        if(dragon.position.y < 0) {
          clearInterval(iv);
          scene.remove(dragon);
          scene.remove(skyLightning);

          // Explosi√≥n
          enemies.forEach(e => {
            if(e.position.distanceTo(player.position) < 10) {
              e.userData.hp -= 200;
              flash(e.position);
            }
          });
        }
        cnt++;
      }, 50);
    }, 1000);
  }

  function activateTwinLionFists() {
    let lions = [];
    // Leones pixelados m√°s grandes y m√°s detallados
    for(let i = 0; i < 2; i++) {
      let lionGroup = new THREE.Group();

      // Cuerpo del le√≥n pixelado
      let body = new THREE.Mesh(
        new THREE.BoxGeometry(1.4,1.4,1.4),
        new THREE.MeshBasicMaterial({color: 0x4B0082})
      );

      // Melena pixelada
      for(let j = 0; j < 8; j++) {
        let hair = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.4),
          new THREE.MeshBasicMaterial({color: 0x6A5ACD})
        );
        hair.position.set(
          Math.cos(j * Math.PI/4) * 0.4,
          Math.sin(j * Math.PI/4) * 0.4,
          0
        );
        hair.lookAt(new THREE.Vector3(0, 0, 1));
        lionGroup.add(hair);
      }

      lionGroup.add(body);
      lionGroup.position.copy(player.position).add(new THREE.Vector3(i ? 1.5 : -1.5, 1, 0));
      scene.add(lionGroup);
      lions.push(lionGroup);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      lions.forEach((lion, i) => {
        // Movimiento m√°s fluido
        let angle = cnt * 0.2 + i * Math.PI;
        let target = new THREE.Vector3(
          Math.cos(angle) * 2,
          Math.sin(angle * 0.5) * 0.5,
          -1
        );
        lion.position.add(target.multiplyScalar(0.15));
        lion.rotation.z = Math.sin(cnt * 0.1) * 0.2;

        // Efecto de chakra pixelado
        if(cnt % 3 === 0) {
          let chakraSpark = new THREE.Mesh(
            new THREE.BoxGeometry(0.2,0.2,0.2),
            new THREE.MeshBasicMaterial({color: 0x4B0082, transparent: true, opacity: 0.6})
          );
          chakraSpark.position.copy(lion.position);
          scene.add(chakraSpark);
          setTimeout(() => scene.remove(chakraSpark), 300);
        }
      });

      enemies.forEach(e => {
        lions.forEach(lion => {
          if(lion.position.distanceTo(e.position) < 1.5) {
            e.userData.hp -= 8;
            // Efecto de impacto pixelado
            let impact = new THREE.Mesh(
              new THREE.BoxGeometry(0.8, 0.8, 0.8),
              new THREE.MeshBasicMaterial({color: 0x4B0082, side: THREE.DoubleSide})
            );
            impact.position.copy(e.position);
            impact.lookAt(camera.position);
            scene.add(impact);
            setTimeout(() => scene.remove(impact), 200);
          }
        });
      });

      if(++cnt > 40) {
        clearInterval(iv);
        lions.forEach(lion => scene.remove(lion));
      }
    }, 50);
  }

  // Funci√≥n para actualizar la c√°mara libre 360¬∞
  function updateFreeCamera() {
    // Calcular posici√≥n de la c√°mara basada en los √°ngulos
    let cameraX = player.position.x + Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
    let cameraY = player.position.y + Math.sin(cameraAngleY) * cameraDistance + 4;
    let cameraZ = player.position.z + Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
    
    camera.position.set(cameraX, cameraY, cameraZ);
    camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
  }

  // Controles de mouse para PC
  document.addEventListener('mousedown', (event) => {
    if(event.button === 0) { // Solo bot√≥n izquierdo
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }
  });

  document.addEventListener('mouseup', (event) => {
    if(event.button === 0) {
      isDragging = false;
    }
  });

  document.addEventListener('mousemove', (event) => {
    if(isDragging) {
      let deltaX = event.clientX - lastMouseX;
      let deltaY = event.clientY - lastMouseY;
      
      // Actualizar √°ngulos de c√°mara
      cameraAngleX += deltaX * 0.01; // Sensibilidad horizontal
      cameraAngleY -= deltaY * 0.01; // Sensibilidad vertical
      
      // Limitar rotaci√≥n vertical para evitar que se voltee completamente
      cameraAngleY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleY));
      
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }
  });

  // Controles t√°ctiles para m√≥viles
  document.addEventListener('touchstart', (event) => {
    if(event.touches.length === 1) {
      isDragging = true;
      lastMouseX = event.touches[0].clientX;
      lastMouseY = event.touches[0].clientY;
    }
  });

  document.addEventListener('touchend', () => {
    isDragging = false;
  });

  document.addEventListener('touchmove', (event) => {
    if(isDragging && event.touches.length === 1) {
      let deltaX = event.touches[0].clientX - lastMouseX;
      let deltaY = event.touches[0].clientY - lastMouseY;
      
      // Actualizar √°ngulos de c√°mara
      cameraAngleX += deltaX * 0.01;
      cameraAngleY -= deltaY * 0.01;
      
      // Limitar rotaci√≥n vertical
      cameraAngleY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleY));
      
      lastMouseX = event.touches[0].clientX;
      lastMouseY = event.touches[0].clientY;
    }
  });

  // Control de zoom con rueda del mouse
  document.addEventListener('wheel', (event) => {
    cameraDistance += event.deltaY * 0.01;
    cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Limitar zoom
    event.preventDefault();
  });

  // Movimiento relativo a la c√°mara
  function updateMovementDirection() {
    if(moveDir.x !== 0 || moveDir.z !== 0) {
      // Calcular direcci√≥n basada en la orientaci√≥n de la c√°mara
      let forward = new THREE.Vector3(
        Math.sin(cameraAngleX),
        0,
        Math.cos(cameraAngleX)
      ).normalize();
      
      let right = new THREE.Vector3(
        Math.cos(cameraAngleX),
        0,
        -Math.sin(cameraAngleX)
      ).normalize();
      
      // Aplicar movimiento relativo a la c√°mara
      let moveVector = new THREE.Vector3();
      moveVector.add(forward.clone().multiplyScalar(-moveDir.z * playerSpeed));
      moveVector.add(right.clone().multiplyScalar(moveDir.x * playerSpeed));
      
      // Verificar l√≠mites de las paredes
      const WALL_LIMIT = 95;
      let nextX = player.position.x + moveVector.x;
      let nextZ = player.position.z + moveVector.z;
      
      if(Math.abs(nextX) < WALL_LIMIT) player.position.x = nextX;
      if(Math.abs(nextZ) < WALL_LIMIT) player.position.z = nextZ;
      
      // Rotar el jugador hacia la direcci√≥n de movimiento
      if(moveVector.length() > 0) {
        player.lookAt(player.position.x + moveVector.x, player.position.y, player.position.z + moveVector.z);
      }
    }
  }

  // Add Speed Button

  let speedButton = document.createElement('div');
  speedButton.id = 'speed-button';
  speedButton.className = 'action-btn';
  speedButton.textContent = 'SPEED';
  speedButton.addEventListener('touchstart', function() {
    playerSpeed = 0.5;
    setTimeout(function() {
      playerSpeed = 0.15;
    }, 5000);
  });

  document.getElementById('actions').appendChild(speedButton);

  </script>
</body>
</html>
