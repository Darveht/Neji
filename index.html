<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Naruto Characters 3D</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body,html{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#000;}
    canvas{display:block;}
    @keyframes ninja-scroll {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    @keyframes chakra-pulse {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 0.4; }
      100% { transform: scale(1); opacity: 0.8; }
    }
    #loading{
      position:fixed;width:100%;height:100%;
      background:#000 url('https://i.imgur.com/XqwUZ0r.jpg') center/cover;
      color:#ff4500;
      display:flex;flex-direction:column;
      align-items:center;justify-content:center;
      z-index:100;
      font-family: 'ninja', Arial, sans-serif;
      text-shadow: 0 0 10px #ff4500;
    }
    #loading-bar{
      width:200px;height:20px;
      border:2px solid #ff4500;
      margin-top:20px;
      position: relative;
      overflow: hidden;
      background: rgba(0,0,0,0.5);
    }
    #loading-progress{
      width:0%;height:100%;
      background: linear-gradient(90deg, #ff4500, #ffa500);
      transition:width 0.3s;
      position: relative;
    }
    #loading-progress::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: ninja-scroll 1s infinite;
    }
    #char-select{
      position:fixed;width:100%;height:100%;
      background:rgba(0,0,0,0.9);
      display:none;
      align-items:center;justify-content:center;
      z-index:50;
    }
    .char-card{
      width:280px;
      margin:10px;
      background:rgba(255,255,255,0.1);
      border:2px solid #fff;
      padding:15px;
      text-align:center;
      color:#fff;
      cursor:pointer;
      transition:transform 0.2s;
      flex-shrink: 0;
    }
    .char-card:hover{
      transform:scale(1.05);
    }
    .char-img{
      width:100%;
      height:200px;
      background:#333;
      margin:10px auto;
      background-size: contain !important;
    }
    #char-select {
      overflow-y: auto;
      flex-wrap: wrap;
      justify-content: center;
      padding: 20px 10px;
    }
    @media (max-width: 600px) {
      .char-card {
        width: 90%;
        margin: 10px auto;
      }
      .char-img {
        height: 180px;
      }
      h3 {
        font-size: 1.2em;
      }
      p {
        font-size: 0.9em;
      }
    }
    #joystick{position:absolute;bottom:20px;left:20px;width:120px;height:120px;touch-action:none;z-index:10;}
    #joy-base,#joy-thumb{position:absolute;border-radius:50%;pointer-events:none;}
    #joy-base{width:100%;height:100%;border:2px solid rgba(255,255,255,0.5);background:rgba(255,255,255,0.1);}
    #joy-thumb{width:50px;height:50px;top:35px;left:35px;background:rgba(255,255,255,0.6);border:2px solid #fff;}
    #actions{position:absolute;bottom:20px;right:20px;display:flex;flex-direction:column;gap:10px;z-index:10;user-select:none;}
    .action-btn{width:60px;height:60px;border-radius:50%;text-align:center;line-height:60px;color:#fff;font-size:12px;
               background:rgba(0,0,0,0.4);border:2px solid #fff;touch-action:none;}
    #jump{border-color:#0f0;color:#0f0;}
    .health-back,.health-bar{position:absolute;width:50px;height:6px;transform:translate(-50%,-120%);pointer-events:none;}
    .health-back{background:rgba(0,0,0,0.5);} .health-bar{background:lime;}
  </style>
</head>
<body>
  <!-- Pantalla de carga -->
  <div id="loading">
    <h2>Cargando...</h2>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
  </div>

  <!-- Selección de personaje -->
  <div id="char-select">
    <div class="char-card" onclick="selectCharacter('neji')">
      <h3>Neji Hyūga</h3>
      <div class="char-img" style="background: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_JLthZ20l4C_V-G8cKVR_3hOqAyrTOVTLaw&s') center/contain no-repeat;"></div>
      <p>Poderes: Byakugan, Jūken, 64 Palmas, 128 Palmas, Kaiten</p>
    </div>
    <div class="char-card" onclick="selectCharacter('itachi')">
      <h3>Itachi Uchiha</h3>
      <div class="char-img" style="background: url('https://officialpsds.com/imageview/r0/68/r068ny_large.png?1521316545') center/contain no-repeat;"></div>
      <p>Poderes: Sharingan, Amaterasu, Tsukuyomi, Susanoo</p>
    </div>
    <div class="char-card" onclick="selectCharacter('ino')">
      <h3>Ino Yamanaka</h3>
      <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/c/cc/Ino_Segunda_Guerra_Mundial_Shinobi_HD.png') center/contain no-repeat;"></div>
      <p>Poderes: Transferencia de Mente, Bomba de Chakra, Control Mental, Curación</p>
    </div>
    <div class="char-card" onclick="selectCharacter('shikamaru')">
      <h3>Shikamaru Nara</h3>
      <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/9a/Shikamaru_Nara.png') center/contain no-repeat;"></div>
      <p>Poderes: Posesión de Sombra, Estrangulación de Sombra, Costura de Sombra, Imitación de Sombra</p>
    </div>
    <div class="char-card" onclick="selectCharacter('tenten')">
      <h3>Tenten</h3>
      <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/92/Tenten_Part_2.png') center/contain no-repeat;"></div>
      <p>Poderes: Invocación de Armas, Lluvia de Kunais, Pergamino Gigante, Barrera de Armas</p>
    </div>
    <div class="char-card" onclick="selectCharacter('hinata')">
      <h3>Hinata Hyūga</h3>
      <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/97/Hinata.png') center/contain no-repeat;"></div>
      <p>Poderes: Byakugan, Puño Suave, León Gemelo, Protección de 8 Trigramas</p>
    </div>
  </div>

  <!-- Joystick -->
  <div id="joystick">
    <div id="joy-base"></div>
    <div id="joy-thumb"></div>
  </div>

  <!-- Botones (se actualizarán según el personaje) -->
  <div id="actions"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
  // Variables globales
  let scene, camera, renderer, player, floor;
  let enemies = [], powers = [], moveDir={x:0,z:0}, velY=0, onGround=true;
  const GRAV=-0.02, enemyHUD={};
  let currentCharacter = '';

  // Simular carga
  window.onload = () => {
    let progress = 0;
    const loadingBar = document.getElementById('loading-progress');
    const interval = setInterval(() => {
      progress += 5;
      loadingBar.style.width = progress + '%';
      if(progress >= 100) {
        clearInterval(interval);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('char-select').style.display = 'flex';
      }
    }, 100);
  };

  function selectCharacter(char) {
    currentCharacter = char;
    document.getElementById('char-select').style.display = 'none';

    // Configurar botones según el personaje
    const actions = document.getElementById('actions');
    actions.innerHTML = '';

    const addButton = (id, text) => {
      const btn = document.createElement('div');
      btn.id = id;
      btn.className = 'action-btn';
      btn.textContent = text;
      actions.appendChild(btn);
      return btn;
    };

    addButton('jump', 'Jump');

    if(char === 'neji') {
      addButton('btn-byak', 'Byakugan').addEventListener('touchstart', activateByakugan);
      addButton('btn-juken', 'Jūken').addEventListener('touchstart', activateJuken);
      addButton('btn-64', '64P').addEventListener('touchstart', activate64Palms);
      addButton('btn-128', '128P').addEventListener('touchstart', activate128Palms);
      addButton('btn-kaiten', 'Kaiten').addEventListener('touchstart', activateKaiten);
      addButton('btn-kusho', 'Kūshō').addEventListener('touchstart', activateKusho);
      addButton('btn-det', 'Detect').addEventListener('touchstart', activateDetect);
    } else if(char === 'itachi') {
      addButton('btn-sharingan', 'Sharingan').addEventListener('touchstart', activateSharingan);
      addButton('btn-amaterasu', 'Amaterasu').addEventListener('touchstart', activateAmaterasu);
      addButton('btn-tsukuyomi', 'Tsukuyomi').addEventListener('touchstart', activateTsukuyomi);
      addButton('btn-susanoo', 'Susanoo').addEventListener('touchstart', activateSusanoo);
    } else if(char === 'ino') {
      addButton('btn-mind-transfer', 'Transferencia').addEventListener('touchstart', activateMindTransfer);
      addButton('btn-chakra-bomb', 'Bomba').addEventListener('touchstart', activateChakraBomb);
      addButton('btn-mind-control', 'Control').addEventListener('touchstart', activateMindControl);
      addButton('btn-healing', 'Curación').addEventListener('touchstart', activateHealing);
    } else if(char === 'shikamaru') {
      addButton('btn-shadow-possession', 'Posesión').addEventListener('touchstart', activateShadowPossession);
      addButton('btn-shadow-strangle', 'Estrangular').addEventListener('touchstart', activateShadowStrangle);
    } else if(char === 'tenten') {
      addButton('btn-weapon-summon', 'Invocar').addEventListener('touchstart', activateWeaponSummoning);
      addButton('btn-kunai-rain', 'Lluvia').addEventListener('touchstart', activateKunaiRain);
    } else if(char === 'hinata') {
      addButton('btn-gentle-fist', 'Puño Suave').addEventListener('touchstart', activateGentleFist);
      addButton('btn-twin-lions', 'Leones').addEventListener('touchstart', activateTwinLionFists);
    }

    init();
    animate();
  }

  function init(){
    scene=new THREE.Scene(); 
    scene.background = new THREE.Color(0x87CEEB);
    camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,500);

    // Crear textura para las paredes
    const textureLoader = new THREE.TextureLoader();
    const wallTexture = textureLoader.load('https://wallpapers.com/images/hd/hidden-leaf-village-96kizz8o1c5ev6sf.jpg');
    
    // Crear paredes
    const wallGeometry = new THREE.PlaneGeometry(200, 20);
    const wallMaterial = new THREE.MeshStandardMaterial({ 
      map: wallTexture,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9,
      emissive: 0x444444,
      emissiveIntensity: 0.2
    });

    // Pared Norte
    const wallNorth = new THREE.Mesh(wallGeometry, wallMaterial);
    wallNorth.position.set(0, 10, -100);
    scene.add(wallNorth);

    // Pared Sur
    const wallSouth = new THREE.Mesh(wallGeometry, wallMaterial);
    wallSouth.position.set(0, 10, 100);
    wallSouth.rotation.y = Math.PI;
    scene.add(wallSouth);

    // Pared Este
    const wallEast = new THREE.Mesh(wallGeometry, wallMaterial);
    wallEast.position.set(100, 10, 0);
    wallEast.rotation.y = -Math.PI/2;
    scene.add(wallEast);

    // Pared Oeste
    const wallWest = new THREE.Mesh(wallGeometry, wallMaterial);
    wallWest.position.set(-100, 10, 0);
    wallWest.rotation.y = Math.PI/2;
    scene.add(wallWest);
    camera.position.set(0,5,10);
    renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);

    // luces
    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));
    let dl=new THREE.DirectionalLight(0xffffff,0.8);
    dl.position.set(5,10,7); scene.add(dl);

    // suelo + hierba (idéntico)
    floor=new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshStandardMaterial({color:0x228B22})
    ); floor.rotation.x=-Math.PI/2; scene.add(floor);
    for(let i=0;i<500;i++){
      let b=new THREE.Mesh(
        new THREE.CylinderGeometry(0.02,0.02,0.6),
        new THREE.MeshStandardMaterial({color:0x00aa00})
      );
      b.position.set(Math.random()*180-90,0.3,Math.random()*180-90);
      b.rotation.z=(Math.random()-0.5)*0.5;
      scene.add(b);
    }

    // personaje con brazos y piernas animadas
    let body=new THREE.Mesh(
      new THREE.CylinderGeometry(0.6,0.6,2.5),
      new THREE.MeshStandardMaterial({color:0xeeeeee})
    );
    let head=new THREE.Mesh(
      new THREE.SphereGeometry(0.6),
      new THREE.MeshStandardMaterial({color:0xdddddd})
    );
    head.position.y=1.8;
    
    // Brazos
    let armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5);
    let leftArm = new THREE.Mesh(armGeometry, new THREE.MeshStandardMaterial({color: 0xeeeeee}));
    let rightArm = new THREE.Mesh(armGeometry, new THREE.MeshStandardMaterial({color: 0xeeeeee}));
    leftArm.position.set(-0.8, 0.5, 0);
    rightArm.position.set(0.8, 0.5, 0);
    
    // Piernas más visibles
    let legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 2);
    let leftLeg = new THREE.Mesh(legGeometry, new THREE.MeshStandardMaterial({color: 0xeeeeee}));
    let rightLeg = new THREE.Mesh(legGeometry, new THREE.MeshStandardMaterial({color: 0xeeeeee}));
    leftLeg.position.set(-0.4, -0.8, 0);
    rightLeg.position.set(0.4, -0.8, 0);
    
    player=new THREE.Group(); 
    player.add(body, head, leftArm, rightArm, leftLeg, rightLeg);
    player.position.set(0,1.25,0); scene.add(player);

    // enemigos
    for(let i=0;i<5;i++) addEnemy();

    // joystick
    const joy=document.getElementById('joystick'),
          thumb=document.getElementById('joy-thumb');
    let origin={x:0,y:0}, tracking=false;
    joy.addEventListener('touchstart',e=>{
      let t=e.touches[0];
      const rect=joy.getBoundingClientRect();
      origin={x:rect.left+rect.width/2,y:rect.top+rect.height/2};
      tracking=true;
    });
    joy.addEventListener('touchmove',e=>{
      if(!tracking) return;
      let t=e.touches[0],
          dx=t.clientX-origin.x,
          dy=t.clientY-origin.y,
          dist=Math.hypot(dx,dy),
          max=50;
      if(dist>max){ dx*=max/dist; dy*=max/dist; }
      thumb.style.transform=`translate(${dx}px,${dy}px)`;
      moveDir.x=dx/max*0.15; moveDir.z=dy/max*0.15;
    });
    joy.addEventListener('touchend',()=>{
      tracking=false;
      thumb.style.transform='translate(0,0)';
      moveDir={x:0,z:0};
    });

    // botones
    document.getElementById('jump')
      .addEventListener('touchstart',_=>{ if(onGround){velY=0.5;onGround=false;}});

    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  }

  function addEnemy(){
    let g=new THREE.Group();
    let b=new THREE.Mesh(
      new THREE.BoxGeometry(1,1.5,1),
      new THREE.MeshStandardMaterial({
        color:0xAA0000,
        roughness: 0.8,
        metalness: 0.5
      })
    );
    let h=new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 32, 32),
      new THREE.MeshStandardMaterial({
        color:0xFF4444,
        emissive: 0xFF0000,
        emissiveIntensity: 0.5
      })
    );
    h.position.y=1.25;
    
    // Garras y detalles monstruosos
    let clawGeometry = new THREE.ConeGeometry(0.1, 0.3, 4);
    for(let i = 0; i < 3; i++) {
      let claw = new THREE.Mesh(clawGeometry, new THREE.MeshStandardMaterial({color: 0x660000}));
      claw.position.set(0.3 * (i-1), 0, 0.6);
      b.add(claw);
    }
    g.add(b,h);
    
    // Efecto de distorsión en Tsukuyomi
    g.userData.originalScale = g.scale.clone();
    g.userData.tsukuyomiActive = false;
    g.position.set(Math.random()*40-20,0.75,Math.random()*40-20);
    g.userData={hp:200,id:THREE.MathUtils.generateUUID()};
    scene.add(g); enemies.push(g);
    // HUD
    let back=document.createElement('div'),
        bar=document.createElement('div');
    back.className='health-back'; bar.className='health-bar';
    document.body.appendChild(back); document.body.appendChild(bar);
    enemyHUD[g.userData.id]={back,bar};
  }

  function animate(){
    requestAnimationFrame(animate);
    // Animación de brazos y piernas al moverse
    if(moveDir.x !== 0 || moveDir.z !== 0) {
      let time = Date.now() * 0.003;
      player.children[2].rotation.x = Math.sin(time * 5) * 0.5; // brazo izquierdo
      player.children[3].rotation.x = Math.sin(time * 5 + Math.PI) * 0.5; // brazo derecho
      player.children[4].rotation.x = Math.sin(time * 5 + Math.PI) * 0.5; // pierna izquierda
      player.children[5].rotation.x = Math.sin(time * 5) * 0.5; // pierna derecha
    }
    // movimiento + salto + colisiones con paredes
    let nextX = player.position.x + moveDir.x;
    let nextZ = player.position.z + moveDir.z;
    
    // Límites de las paredes
    const WALL_LIMIT = 95;
    if(Math.abs(nextX) < WALL_LIMIT) player.position.x = nextX;
    if(Math.abs(nextZ) < WALL_LIMIT) player.position.z = nextZ;
    
    velY+=GRAV; player.position.y+=velY;
    if(player.position.y<=1.25){player.position.y=1.25;velY=0;onGround=true;}
    // cámara
    camera.position.set(player.position.x+6,player.position.y+4,player.position.z+8);
    camera.lookAt(player.position);
    // poderes y colisiones (como antes)...
    powers.forEach((p,i)=>{
      p.mesh.position.add(p.vel);
      p.life--;
      enemies.forEach(e=>{
        if(p.life>0 && p.mesh.position.distanceTo(e.position)<1.2){
          e.userData.hp-=p.damage; p.life=0; flash(e.position);
        }
      });
      if(p.life<=0){ scene.remove(p.mesh); powers.splice(i,1); }
    });
    // IA enemigos + HUD + muerte
    enemies.forEach((e,i)=>{
      let dir=player.position.clone().sub(e.position).setY(0).normalize().multiplyScalar(0.005);
      e.position.add(dir);
      let {back,bar}=enemyHUD[e.userData.id],
          vp=e.position.clone().project(camera),
          x=(vp.x*0.5+0.5)*innerWidth,
          y=(-vp.y*0.5+0.5)*innerHeight;
      back.style.transform=`translate(${x}px,${y}px)`;
      bar.style.transform=`translate(${x}px,${y}px) scaleX(${e.userData.hp/200})`;
      if(e.userData.hp<=0){
        scene.remove(e); back.remove(); bar.remove();
        enemies.splice(i,1); delete enemyHUD[e.userData.id];
      }
    });
    renderer.render(scene,camera);
  }

  function flash(pos){
    let m=new THREE.Mesh(
      new THREE.SphereGeometry(0.5,8,8),
      new THREE.MeshBasicMaterial({color:0xffff00})
    );
    m.position.copy(pos); scene.add(m);
    setTimeout(()=>scene.remove(m),200);
  }

  // ─── TÉCNICAS ───

  function activateByakugan(){
    // pupilas blancas + venas (overlay CSS)
    let ov=document.createElement('div');
    ov.style.cssText=`
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:rgba(255,255,255,0.2);
      pointer-events:none;mix-blend-mode:overlay;
      mask: radial-gradient(circle at 50% 40%, transparent 20%, black 30%);
    `;
    document.body.appendChild(ov);
    setTimeout(()=>ov.remove(),1200);
    // auras en enemigos
    enemies.forEach(e=>{
      let aura=new THREE.Mesh(
        new THREE.RingGeometry(1.5,2.5,32),
        new THREE.MeshBasicMaterial({color:0x00ffff,side:THREE.DoubleSide,transparent:true,opacity:0.3})
      );
      aura.rotation.x=-Math.PI/2;
      aura.position.copy(e.position).add(new THREE.Vector3(0,1,0));
      scene.add(aura);
      setTimeout(()=>scene.remove(aura),1200);
    });
  }

  function activateJuken(){
    // golpe suave: pulso puntual
    let p=new THREE.Mesh(
      new THREE.SphereGeometry(0.5,16,16),
      new THREE.MeshBasicMaterial({color:0xffa500,transparent:true,opacity:0.8})
    );
    // Posición de la mano derecha
    p.position.copy(player.position).add(new THREE.Vector3(0.8, 1.5, 0));
    scene.add(p);
    powers.push({mesh:p,vel:new THREE.Vector3(0,0,-1),life:40,damage:50});
  }

  function activate64Palms(){
    for(let i=0;i<64;i++){
      let a=(i/64)*Math.PI*2;
      let orb=new THREE.Mesh(
        new THREE.SphereGeometry(0.15,8,8),
        new THREE.MeshBasicMaterial({color:0x66ccff})
      );
      orb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
      scene.add(orb);
      powers.push({
        mesh:orb,
        vel:new THREE.Vector3(Math.cos(a)*0.7,0,Math.sin(a)*0.7),
        life:50,damage:10
      });
    }
  }

  function activate128Palms(){
    for(let i=0;i<128;i++){
      let a=(i/128)*Math.PI*2;
      let orb=new THREE.Mesh(
        new THREE.SphereGeometry(0.12,8,8),
        new THREE.MeshBasicMaterial({color:0x00ffff})
      );
      orb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
      scene.add(orb);
      powers.push({
        mesh:orb,
        vel:new THREE.Vector3(Math.cos(a)*0.9,0,Math.sin(a)*0.9),
        life:40,damage:8
      });
    }
  }

  function activateKaiten(){
    let t=new THREE.Mesh(
      new THREE.TorusGeometry(3,0.4,16,100),
      new THREE.MeshBasicMaterial({color:0x99ccff,transparent:true,opacity:0.4})
    );
    t.rotation.x=Math.PI/2; player.add(t);
    let cnt=0, iv=setInterval(()=>{
      t.rotation.z+=0.6;
      enemies.forEach(e=>{
        if(t.getWorldPosition(new THREE.Vector3()).distanceTo(e.position)<3)
          e.userData.hp-=3;
      });
      if(++cnt>30){ clearInterval(iv); player.remove(t); }
    },40);
  }

  function activateKusho(){
    // onda de vacío
    let ring=new THREE.Mesh(
      new THREE.RingGeometry(0.5,0.7,32),
      new THREE.MeshBasicMaterial({color:0xff00ff,side:THREE.DoubleSide,transparent:true,opacity:0.6})
    );
    ring.rotation.x=-Math.PI/2;
    ring.position.copy(player.position);
    scene.add(ring);
    let scale=1, iv=setInterval(()=>{
      scale+=0.5;
      ring.scale.set(scale,scale,scale);
      ring.material.opacity-=0.05;
      enemies.forEach(e=>{
        if(e.position.distanceTo(player.position)<scale*1.2)
          e.userData.hp-=4;
      });
      if(scale>6){ clearInterval(iv); scene.remove(ring); }
    },50);
  }

  function activateDetect(){
    // identifica clones/ilusiones: parpadea a los enemigos ocultos
    enemies.forEach(e=>{
      let highlight=new THREE.Mesh(
        new THREE.SphereGeometry(1.8,16,16),
        new THREE.MeshBasicMaterial({color:0xffff00,wireframe:true,transparent:true,opacity:0.5})
      );
      highlight.position.copy(e.position);
      scene.add(highlight);
      setTimeout(()=>scene.remove(highlight),1500);
    });
  }

  // Nuevos poderes de Itachi
  function activateSharingan() {
    // Efecto visual de ojos rojos
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:rgba(255,0,0,0.1);
      pointer-events:none;mix-blend-mode:overlay;
      mask: radial-gradient(circle at 50% 40%, transparent 20%, black 30%);
    `;
    document.body.appendChild(overlay);
    setTimeout(() => overlay.remove(), 1200);

    // Marcar enemigos
    enemies.forEach(e => {
      let aura = new THREE.Mesh(
        new THREE.RingGeometry(1.5,2.5,32),
        new THREE.MeshBasicMaterial({color:0xff0000,side:THREE.DoubleSide,transparent:true,opacity:0.3})
      );
      aura.rotation.x = -Math.PI/2;
      aura.position.copy(e.position).add(new THREE.Vector3(0,1,0));
      scene.add(aura);
      setTimeout(() => scene.remove(aura), 1200);
    });
  }

  function activateAmaterasu() {
    let flame = new THREE.Mesh(
      new THREE.SphereGeometry(0.5),
      new THREE.MeshBasicMaterial({color:0x000000})
    );
    flame.position.copy(player.position).add(new THREE.Vector3(0,1,0));
    scene.add(flame);
    powers.push({
      mesh: flame,
      vel: new THREE.Vector3(0,0,-1),
      life: 60,
      damage: 100
    });
  }

  function activateTsukuyomi() {
    // Efecto visual mejorado de Tsukuyomi con rotación 3D
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background: url('https://i.imgur.com/XqwUZ0r.jpg') center/cover;
      opacity:0;pointer-events:none;
      transition:all 0.5s;
      animation: tsukuyomi-world 4s forwards;
      filter: contrast(150%) saturate(150%);
      transform-style: preserve-3d;
      perspective: 1000px;
    `;
    
    const style = document.createElement('style');
    style.textContent = `
      @keyframes tsukuyomi-world {
        0% { filter: hue-rotate(0deg) invert(0); transform: scale(1) rotateY(0deg); }
        50% { filter: hue-rotate(180deg) invert(1); transform: scale(1.1) rotateY(180deg); }
        100% { filter: hue-rotate(360deg) invert(0); transform: scale(1) rotateY(360deg); }
      }
      @keyframes sharingan-spin {
        from { transform: translate(-50%, -50%) rotate(0deg); }
        to { transform: translate(-50%, -50%) rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
    
    // Añadir Sharingan giratorio
    let sharingan = document.createElement('div');
    sharingan.style.cssText = `
      position:fixed;
      top:50%;left:50%;
      width:200px;height:200px;
      background: url('https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Sharingan_triple.svg/1024px-Sharingan_triple.svg.png') center/cover;
      animation: sharingan-spin 2s linear infinite;
      z-index:1000;
      pointer-events:none;
    `;
    
    document.body.appendChild(overlay);
    document.body.appendChild(sharingan);
    
    // Efecto de sonido
    let tsukuyomiSound = new Audio('https://example.com/tsukuyomi.mp3');
    tsukuyomiSound.play();
    
    setTimeout(() => {
      overlay.style.opacity = '0.9';
      // Efecto de distorsión de tiempo
      scene.fog = new THREE.FogExp2(0xff0000, 0.1);
    }, 100);
    
    setTimeout(() => {
      overlay.style.opacity = '0';
      sharingan.remove();
      scene.fog = null;
      setTimeout(() => {
        overlay.remove();
        style.remove();
      }, 500);
    }, 2000);

    // Daño mejorado a enemigos
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < 5) {
        e.userData.hp -= 150;
        // Efecto visual de daño
        let flash = new THREE.Mesh(
          new THREE.SphereGeometry(2),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
          })
        );
        flash.position.copy(e.position);
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 500);
      }
    });
  }

  function activateSusanoo() {
    let susanoo = new THREE.Group();
    // Crear forma básica del Susanoo
    let body = new THREE.Mesh(
      new THREE.CylinderGeometry(2,2,4),
      new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.3})
    );
    susanoo.add(body);
    player.add(susanoo);

    let cnt = 0, iv = setInterval(() => {
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < 4) {
          e.userData.hp -= 5;
        }
      });
      if(++cnt > 50) {
        clearInterval(iv);
        player.remove(susanoo);
      }
    }, 100);
  }

  // Habilidades de Ino
  function activateMindTransfer() {
    let beam = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 10),
      new THREE.MeshBasicMaterial({color: 0x9932CC, transparent: true, opacity: 0.6})
    );
    beam.rotation.x = Math.PI/2;
    beam.position.copy(player.position);
    scene.add(beam);

    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < 10) {
        e.userData.hp -= 80;
        e.material = new THREE.MeshBasicMaterial({color: 0x9932CC});
        setTimeout(() => {
          e.material = new THREE.MeshStandardMaterial({color: 0xAA0000});
        }, 2000);
      }
    });

    setTimeout(() => scene.remove(beam), 1000);
  }

  function activateChakraBomb() {
    let bomb = new THREE.Mesh(
      new THREE.SphereGeometry(0.3),
      new THREE.MeshBasicMaterial({color: 0x00FF7F})
    );
    bomb.position.copy(player.position).add(new THREE.Vector3(0,1,0));
    scene.add(bomb);
    powers.push({
      mesh: bomb,
      vel: new THREE.Vector3(0,0,-1),
      life: 30,
      damage: 60
    });
  }

  function activateMindControl() {
    let circle = new THREE.Mesh(
      new THREE.RingGeometry(0.5, 4, 32),
      new THREE.MeshBasicMaterial({color: 0x9400D3, side: THREE.DoubleSide, transparent: true, opacity: 0.4})
    );
    circle.rotation.x = -Math.PI/2;
    circle.position.copy(player.position);
    scene.add(circle);

    let scale = 1;
    let iv = setInterval(() => {
      scale += 0.2;
      circle.scale.set(scale, scale, scale);
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < scale * 2) {
          e.userData.hp -= 3;
          e.rotation.y += 0.2;
        }
      });
      if(scale > 3) {
        clearInterval(iv);
        scene.remove(circle);
      }
    }, 100);
  }

  function activateHealing() {
    let healingField = new THREE.Mesh(
      new THREE.CircleGeometry(3, 32),
      new THREE.MeshBasicMaterial({color: 0x98FB98, transparent: true, opacity: 0.3, side: THREE.DoubleSide})
    );
    healingField.rotation.x = -Math.PI/2;
    healingField.position.copy(player.position);
    scene.add(healingField);
    
    let particles = [];
    for(let i = 0; i < 20; i++) {
      let particle = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({color: 0x00FF7F})
      );
      particle.position.copy(player.position);
      scene.add(particle);
      particles.push(particle);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      particles.forEach(p => {
        p.position.y += 0.1;
        p.material.opacity -= 0.05;
      });
      if(++cnt > 20) {
        clearInterval(iv);
        scene.remove(healingField);
        particles.forEach(p => scene.remove(p));
      }
    }, 100);
  }

  // Habilidades de Shikamaru
  function activateShadowPossession() {
    // Animación de sombra emergiendo y extendiéndose
    let shadowLength = 0;
    let shadowSegments = [];
    const SEGMENTS = 20;
    const MAX_DISTANCE = 15;
    
    function createShadowSegment() {
      let segment = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.1, 0.5),
        new THREE.MeshBasicMaterial({
          color: 0x000000, 
          transparent: true, 
          opacity: 0
        })
      );
      segment.position.copy(player.position);
      segment.position.y = 0.01; // Ligeramente sobre el suelo
      scene.add(segment);
      return segment;
    }

    // Crear segmentos iniciales
    for(let i = 0; i < SEGMENTS; i++) {
      shadowSegments.push(createShadowSegment());
    }

    let targetEnemy = null;
    let minDist = Infinity;
    
    // Encontrar el enemigo más cercano en la dirección frontal
    enemies.forEach(e => {
      let dirToEnemy = e.position.clone().sub(player.position);
      let angle = dirToEnemy.angleTo(new THREE.Vector3(0, 0, -1));
      if(angle < Math.PI/4 && dirToEnemy.length() < minDist) {
        minDist = dirToEnemy.length();
        targetEnemy = e;
      }
    });

    if(!targetEnemy) {
      shadowSegments.forEach(s => scene.remove(s));
      return;
    }

    let growInterval = setInterval(() => {
      shadowLength += 1;
      let progress = shadowLength / SEGMENTS;
      
      // Actualizar cada segmento
      shadowSegments.forEach((segment, i) => {
        if(i <= shadowLength) {
          let t = i / SEGMENTS;
          let pos = new THREE.Vector3().lerpVectors(
            player.position,
            targetEnemy.position,
            t
          );
          segment.position.copy(pos);
          segment.lookAt(targetEnemy.position);
          segment.material.opacity = Math.min(0.7, (1 - t) * 0.7);
          
          // Efecto de emergencia
          segment.position.y = Math.sin(t * Math.PI) * 0.5;
          segment.scale.y = 1 + Math.sin(t * Math.PI) * 0.5;
        }
      });

      // Cuando la sombra alcanza al enemigo
      if(shadowLength >= SEGMENTS) {
        clearInterval(growInterval);
        targetEnemy.userData.frozen = true;
        targetEnemy.userData.controlled = true;
        targetEnemy.userData.originalPosition = targetEnemy.position.clone();
        targetEnemy.material.color.set(0x000000);
        
        // Limpiar después de 5 segundos
        setTimeout(() => {
          shadowSegments.forEach(s => scene.remove(s));
          targetEnemy.userData.frozen = false;
          targetEnemy.userData.controlled = false;
          targetEnemy.material.color.set(0xAA0000);
        }, 5000);
      }
    }, 50);

    // Mantener enemigos paralizados
    let controlInterval = setInterval(() => {
      enemies.forEach(e => {
        if(e.userData.controlled) {
          e.position.copy(e.userData.originalPosition);
          // Efecto visual de parálisis
          let sparkle = new THREE.Mesh(
            new THREE.SphereGeometry(0.1),
            new THREE.MeshBasicMaterial({color: 0x000000})
          );
          sparkle.position.copy(e.position).add(new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() * 2,
            Math.random() - 0.5
          ));
          scene.add(sparkle);
          setTimeout(() => scene.remove(sparkle), 500);
        }
      });
    }, 100);

    setTimeout(() => {
      clearInterval(controlInterval);
      scene.remove(shadow);
      enemies.forEach(e => {
        e.userData.frozen = false;
        e.userData.controlled = false;
        e.material.color.set(0xAA0000);
      });
    }, 5000);
  }

  function activateShadowStrangle() {
    let range = 8;
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < range) {
        e.userData.hp -= 70;
        let shadow = new THREE.Mesh(
          new THREE.TorusGeometry(0.5, 0.1, 8, 24),
          new THREE.MeshBasicMaterial({color: 0x000000})
        );
        shadow.position.copy(e.position).add(new THREE.Vector3(0, 1, 0));
        scene.add(shadow);
        setTimeout(() => scene.remove(shadow), 1000);
      }
    });
  }

  // Habilidades de Tenten
  function activateWeaponSummoning() {
    // Pergamino giratorio
    let scroll = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2),
      new THREE.MeshBasicMaterial({color: 0xF5DEB3})
    );
    scroll.position.copy(player.position).add(new THREE.Vector3(0, 2, 0));
    scroll.rotation.x = Math.PI/2;
    scene.add(scroll);

    // Diferentes tipos de armas
    const weaponTypes = [
      {geo: new THREE.ConeGeometry(0.1, 0.6), color: 0x808080, name: 'kunai'}, // Kunai
      {geo: new THREE.BoxGeometry(0.1, 0.7, 0.1), color: 0x4A4A4A, name: 'sword'}, // Espada
      {geo: new THREE.SphereGeometry(0.15), color: 0x696969, name: 'shuriken'} // Shuriken
    ];

    let cnt = 0;
    let weaponInterval = setInterval(() => {
      if(cnt > 15) {
        clearInterval(weaponInterval);
        scene.remove(scroll);
        return;
      }

      let weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
      let weapon = new THREE.Mesh(
        weaponType.geo,
        new THREE.MeshBasicMaterial({color: weaponType.color})
      );

      // Aparecer desde el pergamino
      weapon.position.copy(scroll.position);
      weapon.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      scene.add(weapon);
      powers.push({
        mesh: weapon,
        vel: new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 0.5,
          -1
        ).normalize().multiplyScalar(0.3),
        life: 40,
        damage: weaponType.name === 'sword' ? 40 : 25,
        spin: new THREE.Vector3(
          Math.random() * 0.2,
          Math.random() * 0.2,
          Math.random() * 0.2
        )
      });

      cnt++;
    }, 100);

    // Actualizar la función animate para hacer girar las armas
    let originalAnimate = animate;
    animate = function() {
      originalAnimate();
      powers.forEach(p => {
        if(p.spin) {
          p.mesh.rotation.x += p.spin.x;
          p.mesh.rotation.y += p.spin.y;
          p.mesh.rotation.z += p.spin.z;
        }
      });
    };
  }

  function activateKunaiRain() {
    for(let i = 0; i < 30; i++) {
      setTimeout(() => {
        let kunai = new THREE.Mesh(
          new THREE.ConeGeometry(0.1, 0.4),
          new THREE.MeshBasicMaterial({color: 0x606060})
        );
        kunai.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 10 - 5,
          5,
          Math.random() * 10 - 5
        ));
        scene.add(kunai);
        powers.push({
          mesh: kunai,
          vel: new THREE.Vector3(0, -0.3, 0),
          life: 20,
          damage: 15
        });
      }, i * 100);
    }
  }

  // Habilidades de Hinata
  function activateGentleFist() {
    // Animación de Byakugan activándose
    let byakuganRing = new THREE.Mesh(
      new THREE.RingGeometry(0.5, 1, 32),
      new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.5})
    );
    byakuganRing.rotation.x = -Math.PI/2;
    byakuganRing.position.copy(player.position);
    scene.add(byakuganRing);

    // Múltiples golpes de Puño Suave
    for(let i = 0; i < 5; i++) {
      setTimeout(() => {
        let chakra = new THREE.Mesh(
          new THREE.SphereGeometry(0.3),
          new THREE.MeshBasicMaterial({color: 0x4169E1, transparent: true, opacity: 0.8})
        );
        chakra.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 2 - 1,
          1,
          Math.random() * 2 - 1
        ));
        scene.add(chakra);
        powers.push({
          mesh: chakra,
          vel: new THREE.Vector3(Math.random() - 0.5, 0, -1).normalize(),
          life: 25,
          damage: 35
        });
      }, i * 200);
    }

    setTimeout(() => scene.remove(byakuganRing), 1000);
  }

  function activateTwinLionFists() {
    let lions = [];
    // Leones más grandes y más detallados
    for(let i = 0; i < 2; i++) {
      let lionGroup = new THREE.Group();
      
      // Cuerpo del león
      let body = new THREE.Mesh(
        new THREE.SphereGeometry(0.7),
        new THREE.MeshBasicMaterial({color: 0x4B0082})
      );
      
      // Melena
      for(let j = 0; j < 8; j++) {
        let hair = new THREE.Mesh(
          new THREE.ConeGeometry(0.2, 0.4),
          new THREE.MeshBasicMaterial({color: 0x6A5ACD})
        );
        hair.position.set(
          Math.cos(j * Math.PI/4) * 0.4,
          Math.sin(j * Math.PI/4) * 0.4,
          0
        );
        hair.lookAt(new THREE.Vector3(0, 0, 1));
        lionGroup.add(hair);
      }
      
      lionGroup.add(body);
      lionGroup.position.copy(player.position).add(new THREE.Vector3(i ? 1.5 : -1.5, 1, 0));
      scene.add(lionGroup);
      lions.push(lionGroup);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      lions.forEach((lion, i) => {
        // Movimiento más fluido
        let angle = cnt * 0.2 + i * Math.PI;
        let target = new THREE.Vector3(
          Math.cos(angle) * 2,
          Math.sin(angle * 0.5) * 0.5,
          -1
        );
        lion.position.add(target.multiplyScalar(0.15));
        lion.rotation.z = Math.sin(cnt * 0.1) * 0.2;
        
        // Efecto de chakra
        if(cnt % 3 === 0) {
          let chakraSpark = new THREE.Mesh(
            new THREE.SphereGeometry(0.1),
            new THREE.MeshBasicMaterial({color: 0x4B0082, transparent: true, opacity: 0.6})
          );
          chakraSpark.position.copy(lion.position);
          scene.add(chakraSpark);
          setTimeout(() => scene.remove(chakraSpark), 300);
        }
      });
      
      enemies.forEach(e => {
        lions.forEach(lion => {
          if(lion.position.distanceTo(e.position) < 1.5) {
            e.userData.hp -= 8;
            // Efecto de impacto
            let impact = new THREE.Mesh(
              new THREE.RingGeometry(0.2, 0.4, 16),
              new THREE.MeshBasicMaterial({color: 0x4B0082, side: THREE.DoubleSide})
            );
            impact.position.copy(e.position);
            impact.lookAt(camera.position);
            scene.add(impact);
            setTimeout(() => scene.remove(impact), 200);
          }
        });
      });

      if(++cnt > 40) {
        clearInterval(iv);
        lions.forEach(lion => scene.remove(lion));
      }
    }, 50);
  }
  </script>
</body>
</html>
