<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Naruto Characters 3D - Pixel Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body,html{
      margin:0;padding:0;width:100%;height:100%;
      overflow:hidden;
      background: 
        radial-gradient(circle at 20% 80%, #FF4500 2px, transparent 3px),
        radial-gradient(circle at 80% 20%, #FFD700 2px, transparent 3px),
        linear-gradient(135deg, #000033 25%, #1a0a1a 50%, #000000 75%);
      background-size: 32px 32px, 32px 32px, 100% 100%;
      font-family: 'Press Start 2P', cursive;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    h2, h3 {
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 
        2px 2px 0px #000, 
        4px 4px 0px #FF4500,
        6px 6px 0px rgba(255,69,0,0.5),
        0 0 15px #FF4500;
      color: #FFD700;
      background: 
        repeating-linear-gradient(45deg,
          rgba(255,69,0,0.2) 0px, rgba(255,69,0,0.2) 4px,
          rgba(0,0,0,0.8) 4px, rgba(0,0,0,0.8) 8px);
      padding: 8px 12px;
      border: 2px solid #FF4500;
      animation: narutoGlow 2s steps(4) infinite;
    }

    @keyframes narutoGlow {
      0%, 100% { 
        box-shadow: 0 0 10px #FF4500, inset 0 0 10px rgba(255,69,0,0.2);
      }
      50% { 
        box-shadow: 0 0 20px #FFD700, inset 0 0 15px rgba(255,215,0,0.3);
      }
    }

    p {
      font-size: 8px;
      line-height: 1.6;
      color: #FFD700;
      text-shadow: 
        1px 1px 0px #000,
        2px 2px 0px #FF4500;
      background: rgba(0,0,0,0.7);
      padding: 4px 6px;
      border-left: 3px solid #FF4500;
    }

    @media (max-width: 600px) {
      h2 { font-size: 12px; }
      h3 { font-size: 10px; }
      p { font-size: 6px; }

      .characters-grid {
        grid-template-columns: 1fr;
        gap: 15px;
        padding: 0 10px;
      }

      .char-card {
        max-width: 100%;
        padding: 15px;
      }

      .char-img {
        height: 120px;
      }
    }

    @media (max-width: 900px) and (min-width: 601px) {
      .characters-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Estilo aut√©ntico de pergaminos ninja de Konoha */
    .char-card {
      background: 
        repeating-linear-gradient(45deg,
          #F5DEB3 0px, #F5DEB3 8px,
          #DEB887 8px, #DEB887 16px),
        repeating-linear-gradient(-45deg,
          rgba(139,69,19,0.1) 0px, rgba(139,69,19,0.1) 4px,
          transparent 4px, transparent 8px);
      background-size: 16px 16px, 8px 8px;
      border: 4px solid #8B4513;
      border-radius: 0px;
      box-shadow: 
        0 0 0 2px #000,
        4px 4px 0px #654321,
        0 0 15px rgba(255,69,0,0.4),
        inset 0 0 10px rgba(245,222,179,0.3);
      transition: all 0.2s steps(4);
      position: relative;
    }

    .char-card::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 4px;
      background: 
        repeating-linear-gradient(90deg,
          #FF4500 0px, #FF4500 2px,
          #8B4513 2px, #8B4513 4px);
      box-shadow: 0 2px 0px #000;
    }

    .char-card::after {
      content: 'üçÉ';
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 16px;
      filter: sepia(1) hue-rotate(90deg);
    }

    .char-card:hover {
      transform: scale(1.05) rotateZ(1deg);
      border-color: #FF4500;
      box-shadow: 
        0 0 0 2px #000,
        4px 4px 0px #8B0000,
        0 0 25px #FF4500,
        inset 0 0 15px rgba(255,215,0,0.4);
      background: 
        repeating-linear-gradient(45deg,
          #FFE4B5 0px, #FFE4B5 8px,
          #F5DEB3 8px, #F5DEB3 16px),
        repeating-linear-gradient(-45deg,
          rgba(255,69,0,0.2) 0px, rgba(255,69,0,0.2) 4px,
          transparent 4px, transparent 8px);
    }

    .action-btn {
      background: 
        repeating-linear-gradient(45deg,
          #8B4513 0px, #8B4513 4px,
          #A0522D 4px, #A0522D 8px),
        linear-gradient(135deg, #D2691E 0%, #8B4513 100%);
      border: 3px solid #FF4500;
      color: #FFD700;
      font-family: 'Press Start 2P', cursive;
      font-size: 8px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 
        1px 1px 0px #000, 
        2px 2px 0px #8B0000,
        0 0 8px #FF4500;
      transition: all 0.15s steps(3);
      box-shadow: 
        0 0 0 1px #000,
        3px 3px 0px #654321,
        0 0 12px rgba(255,69,0,0.6),
        inset 0 0 8px rgba(255,215,0,0.2);
      position: relative;
    }

    .action-btn::before {
      content: 'Âøç';
      position: absolute;
      top: -8px;
      right: -8px;
      width: 16px;
      height: 16px;
      background: #FF4500;
      color: #FFD700;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #000;
      box-shadow: 2px 2px 0px #8B0000;
    }

    .action-btn:active {
      background: 
        repeating-linear-gradient(45deg,
          #FF4500 0px, #FF4500 4px,
          #FFD700 4px, #FFD700 8px);
      color: #000;
      transform: translate(2px, 2px);
      box-shadow: 
        0 0 0 1px #000,
        1px 1px 0px #654321,
        0 0 15px #FFD700;
    }

    #loading {
      background: 
        radial-gradient(circle at 25% 25%, #ff0080 2px, transparent 2px),
        radial-gradient(circle at 75% 75%, #00ff80 2px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a1a1a 50%);
      background-size: 16px 16px, 16px 16px, 8px 8px;
      font-family: 'Press Start 2P', cursive;
    }

    #loading h2 {
      color: #00ffff;
      font-size: 16px;
      animation: pixel-blink 1s steps(2) infinite;
    }

    @keyframes pixel-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    #loading-bar {
      border: 3px solid #00ffff;
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #1a1a1a 2px, #1a1a1a 4px);
      box-shadow: 
        0 0 0 1px #000,
        0 0 10px rgba(0,255,255,0.5),
        inset 0 0 5px rgba(0,0,0,0.5);
    }

    #loading-progress {
      background: 
        repeating-linear-gradient(90deg, 
          #00ffff 0px, #00ffff 4px, 
          #0080ff 4px, #0080ff 8px,
          #8000ff 8px, #8000ff 12px,
          #ff0080 12px, #ff0080 16px);
      box-shadow: 0 0 5px rgba(0,255,255,0.8);
      image-rendering: pixelated;
    }

    .player-heart {
      width: 12px;
      height: 12px;
      background: 
        conic-gradient(from 45deg, #ff0040 0deg 90deg, #ff4080 90deg 180deg, #ff0040 180deg 270deg, #800020 270deg 360deg);
      clip-path: polygon(50% 10%, 80% 30%, 100% 60%, 50% 100%, 0% 60%, 20% 30%);
      image-rendering: pixelated;
      box-shadow: 
        1px 1px 0px #000,
        0 0 3px rgba(255,0,64,0.8);
    }

    .player-heart.heart-empty {
      background: 
        conic-gradient(from 45deg, #404040 0deg 90deg, #606060 90deg 180deg, #404040 180deg 270deg, #202020 270deg 360deg);
      box-shadow: 1px 1px 0px #000;
    }

    #player-level {
      font-size: 8px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000, 2px 2px 0px rgba(255,255,0,0.5);
      margin-top: 8px;
    }

    #video-intro {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #credits-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      padding: 20px;
      animation: fadeInCredits 2s ease-in-out;
    }

    #credits-overlay h1 {
      font-size: 24px;
      color: #ff4500;
      text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5);
      margin-bottom: 10px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    #credits-overlay h2 {
      font-size: 16px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-bottom: 30px;
    }

    #credits-overlay p {
      font-size: 10px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
      margin: 8px 0;
      line-height: 1.4;
    }

    #skip-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,69,0,0.8);
      color: #fff;
      padding: 10px 15px;
      border: 2px solid #fff;
      font-size: 8px;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #skip-button:hover {
      background: rgba(255,255,0,0.8);
      color: #000;
      transform: scale(1.1);
    }

    @keyframes fadeInCredits {
      0% { opacity: 0; transform: translateY(50px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes pixelGlow {
      0%, 100% { text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5); }
      50% { text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,255,0,0.8), 0 0 10px #ff4500; }
    }

    /* Pantalla de cr√©ditos Glam Works */
    #glam-credits {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(45deg, #000000 25%, #1a1a1a 25%),
        linear-gradient(-45deg, #000000 25%, #1a1a1a 25%),
        linear-gradient(45deg, #1a1a1a 75%, #000000 75%),
        linear-gradient(-45deg, #1a1a1a 75%, #000000 75%);
      background-size: 16px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    #glam-logo {
      text-align: center;
      animation: glamAppear 3s ease-in-out;
    }

    #glam-logo h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 32px;
      color: #FFD700;
      text-shadow: 
        3px 3px 0px #000,
        6px 6px 0px rgba(255,215,0,0.5),
        0 0 20px #FFD700;
      margin: 0;
      letter-spacing: 4px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    .glam-subtitle {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-top: 20px;
      letter-spacing: 2px;
    }

    #glam-skip {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,215,0,0.8);
      color: #000;
      padding: 10px 15px;
      border: 2px solid #FFD700;
      font-size: 8px;
      font-family: 'Press Start 2P', cursive;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #glam-skip:hover {
      background: rgba(0,255,255,0.8);
      border-color: #00ffff;
      transform: scale(1.1);
    }

    @keyframes glamAppear {
      0% { opacity: 0; transform: scale(0.5) rotate(-10deg); }
      50% { opacity: 1; transform: scale(1.1) rotate(2deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }

    /* Estilos para video personalizado */
    #video-credits-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
      padding: 20px;
      animation: fadeInCredits 2s ease-in-out;
    }

    #video-credits-overlay h1 {
      font-size: 24px;
      color: #ff4500;
      text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(255,69,0,0.5);
      margin-bottom: 10px;
      animation: pixelGlow 2s steps(4) infinite;
    }

    #video-credits-overlay h2 {
      font-size: 16px;
      color: #00ffff;
      text-shadow: 2px 2px 0px #000;
      margin-bottom: 30px;
    }

    #video-credits-overlay p {
      font-size: 10px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
      margin: 8px 0;
      line-height: 1.4;
    }

    #video-skip-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background: rgba(255,69,0,0.8);
      color: #fff;
      padding: 10px 15px;
      border: 2px solid #fff;
      font-size: 8px;
      cursor: pointer;
      transition: all 0.3s;
      animation: pixelBlink 1.5s steps(2) infinite;
    }

    #video-skip-button:hover {
      background: rgba(255,255,0,0.8);
      color: #000;
      transform: scale(1.1);
    }

    #intro-screen {
      background: 
        radial-gradient(circle at 20% 80%, #ff0080 2px, transparent 3px),
        radial-gradient(circle at 80% 20%, #00ff80 2px, transparent 3px),
        radial-gradient(circle at 40% 40%, #0080ff 1px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a0a1a 50%);
      background-size: 32px 32px, 32px 32px, 16px 16px, 8px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #naruto-logo-container {
      max-width: 80%;
      max-height: 80%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #naruto-logo {
      max-width: 100%;
      max-height: 400px;
      width: auto;
      height: auto;
      filter: 
        drop-shadow(2px 2px 0px #000)
        drop-shadow(4px 4px 0px #ff4500)
        drop-shadow(0 0 10px #ff4500);
      animation: pixel-pulse 2s steps(4) infinite;
      image-rendering: pixelated;
    }

    @keyframes pixel-pulse {
      0% { transform: scale(1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff4500); }
      25% { transform: scale(1.05); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ffff00); }
      50% { transform: scale(1.1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #00ffff); }
      75% { transform: scale(1.05); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff0080); }
      100% { transform: scale(1); filter: drop-shadow(2px 2px 0px #000) drop-shadow(4px 4px 0px #ff4500); }
    }

    @keyframes pixel-rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes fadeInSubtitle {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0px); }
    }

    canvas{
      display:block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    #char-select{
      position:fixed;width:100%;height:100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255,69,0,0.3) 3px, transparent 4px),
        radial-gradient(circle at 75% 75%, rgba(255,215,0,0.3) 3px, transparent 4px),
        repeating-linear-gradient(45deg, 
          rgba(139,69,19,0.9) 0px, rgba(139,69,19,0.9) 4px,
          rgba(160,82,45,0.9) 4px, rgba(160,82,45,0.9) 8px),
        linear-gradient(135deg, rgba(245,222,179,0.1) 0%, rgba(0,0,0,0.8) 100%);
      background-size: 48px 48px, 48px 48px, 16px 16px, 100% 100%;
      display:none;
      flex-direction: column;
      align-items:center;
      justify-content: flex-start;
      z-index:50;
      overflow-y: auto;
      padding: 20px;
      position: relative;
    }

    #char-select::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        repeating-linear-gradient(0deg,
          transparent 0px, transparent 8px,
          rgba(255,69,0,0.1) 8px, rgba(255,69,0,0.1) 10px),
        repeating-linear-gradient(90deg,
          transparent 0px, transparent 8px,
          rgba(255,215,0,0.1) 8px, rgba(255,215,0,0.1) 10px);
      pointer-events: none;
      animation: scroll-pattern 4s linear infinite;
    }

    @keyframes scroll-pattern {
      from { background-position: 0 0, 0 0; }
      to { background-position: 0 16px, 16px 0; }
    }

    .characters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      max-width: 1200px;
      width: 100%;
      margin-top: 20px;
      padding: 0 20px;
    }

    .select-header {
      width: 100%;
      text-align: center;
      margin-bottom: 20px;
      position: relative;
    }

    .select-header h2 {
      color: #FFD700;
      font-size: 18px;
      text-shadow: 
        2px 2px 0px #000,
        4px 4px 0px #8B0000,
        6px 6px 0px rgba(255,69,0,0.6),
        0 0 20px #FF4500;
      margin: 0;
      padding: 18px 24px;
      background: 
        repeating-linear-gradient(45deg,
          rgba(139,69,19,0.9) 0px, rgba(139,69,19,0.9) 6px,
          rgba(255,69,0,0.3) 6px, rgba(255,69,0,0.3) 12px),
        radial-gradient(circle, rgba(245,222,179,0.2) 30%, transparent 70%);
      border: 4px solid #FF4500;
      border-radius: 0px;
      box-shadow: 
        0 0 0 2px #000,
        6px 6px 0px #654321,
        0 0 20px rgba(255,69,0,0.6),
        inset 0 0 15px rgba(255,215,0,0.2);
      position: relative;
    }

    .select-header h2::before {
      content: 'üçÉ Êú®„ÉéËëâÈö†„Çå„ÅÆÈáå üçÉ';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      background: #FF4500;
      color: #FFD700;
      padding: 4px 8px;
      border: 2px solid #000;
      box-shadow: 2px 2px 0px #8B0000;
    }

    .scroll-design {
      height: 20px;
      background: 
        repeating-linear-gradient(90deg,
          #ff4500 0px, #ff4500 4px,
          #ffff00 4px, #ffff00 8px,
          #00ff80 8px, #00ff80 12px,
          #0080ff 12px, #0080ff 16px);
      opacity: 0.8;
      margin-top: 10px;
      image-rendering: pixelated;
    }

    .char-card {
      width: 100%;
      max-width: 280px;
      margin: 0;
      background: 
        radial-gradient(circle at 10% 10%, rgba(0,255,255,0.1) 2px, transparent 3px),
        repeating-linear-gradient(45deg,
          rgba(0,0,51,0.95) 0px, rgba(0,0,51,0.95) 3px,
          rgba(255,69,0,0.1) 3px, rgba(255,69,0,0.1) 6px);
      background-size: 16px 16px, 12px 12px;
      border: 3px solid #ff4500;
      border-radius: 0px;
      padding: 20px;
      text-align: center;
      color: #fff;
      cursor: pointer;
      transition: all 0.1s steps(2);
      box-shadow: 
        0 0 0 1px #000,
        3px 3px 0px #000,
        0 0 15px rgba(255,69,0,0.3);
      position: relative;
      overflow: hidden;
      image-rendering: pixelated;
      justify-self: center;
    }

    .char-card:hover {
      transform: scale(1.05) translate(-1px, -1px);
      border-color: #ffff00;
      box-shadow: 
        0 0 0 1px #000,
        4px 4px 0px #000,
        0 0 20px rgba(255,255,0,0.5);
      background: 
        radial-gradient(circle at 10% 10%, rgba(255,255,0,0.2) 2px, transparent 3px),
        repeating-linear-gradient(45deg,
          rgba(0,0,51,0.98) 0px, rgba(0,0,51,0.98) 3px,
          rgba(255,215,0,0.2) 3px, rgba(255,215,0,0.2) 6px);
    }

    .char-card h3 {
      color: #ff4500;
      font-size: 10px;
      margin-bottom: 10px;
      text-shadow: 
        1px 1px 0px #000,
        2px 2px 0px rgba(255,69,0,0.5);
    }

    .char-card p {
      color: #ffff00;
      font-size: 6px;
      line-height: 1.4;
      margin-top: 10px;
      text-shadow: 1px 1px 0px #000;
    }

    .char-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: 
        repeating-linear-gradient(45deg,
          transparent 0px, transparent 2px,
          rgba(74,144,226,0.1) 2px, rgba(74,144,226,0.1) 4px);
      animation: pixel-shine 3s steps(8) infinite;
      pointer-events: none;
    }

    @keyframes pixel-shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .char-img{
      width:100%;
      height:160px;
      background:#1a1a2e;
      margin:8px auto;
      background-size: contain !important;
      border: 2px solid #00ffff;
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 5px rgba(0,0,0,0.5);
      image-rendering: pixelated;
    }

    #joystick{
      position:absolute;bottom:15px;left:15px;width:100px;height:100px;
      touch-action:none;z-index:10;
      filter: drop-shadow(2px 2px 0px #000);
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    #joy-base,#joy-thumb{
      position:absolute;border-radius:0px;pointer-events:none;
      image-rendering: pixelated;
    }

    #joy-base{
      width:100%;height:100%;
      border:3px solid #00ffff;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,255,255,0.1) 0deg 45deg, 
          rgba(0,0,0,0.3) 45deg 90deg);
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 10px rgba(0,255,255,0.2);
    }

    #joy-thumb{
      width:40px;height:40px;top:30px;left:30px;
      background: 
        radial-gradient(circle, #00ffff 30%, #0080ff 70%);
      border:2px solid #fff;
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000,
        0 0 5px rgba(0,255,255,0.8);
    }

    #actions{
      position:absolute;bottom:15px;right:15px;
      display:flex;flex-direction:column;gap:8px;z-index:10;
      user-select:none;
    }

    .action-btn{
      width:50px;height:50px;
      border-radius:0px;
      text-align:center;
      line-height:50px;
      color:#00ffff;
      font-size: 8px;
      font-weight: normal;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,0,0,0.8) 0deg 90deg, 
          rgba(26,26,46,0.8) 90deg 180deg);
      border:2px solid #00ffff;
      touch-action:none;
      text-shadow: 1px 1px 0px #000;
      letter-spacing: 0.5px;
      box-shadow: 
        0 0 0 1px #000,
        2px 2px 0px #000;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      cursor: pointer;
    }
    
    .action-btn:active {
      transform: scale(0.95);
      box-shadow: 
        0 0 0 1px #000,
        1px 1px 0px #000;
    }

    #jump{
      border-color:#00ff00;color:#00ff00;
      background: 
        repeating-conic-gradient(from 0deg, 
          rgba(0,128,0,0.3) 0deg 90deg, 
          rgba(0,0,0,0.8) 90deg 180deg);
    }

    .health-back,.health-bar{
      position:absolute;width:40px;height:4px;
      transform:translate(-50%,-120%);pointer-events:none;
      image-rendering: pixelated;
    }

    .health-back{
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #333 2px, #333 4px);
      border: 1px solid #000;
    } 

    .health-bar{
      background: 
        repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 2px, #80ff00 2px, #80ff00 4px);
      border: 1px solid #000;
      box-shadow: 0 0 3px rgba(0,255,0,0.5);
    }

    #player-hud {
      position: absolute;
      top: 8px;
      left: 8px;
      color: #FFD700;
      font-family: 'Press Start 2P', cursive;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      background: 
        repeating-linear-gradient(45deg,
          rgba(139,69,19,0.95) 0px, rgba(139,69,19,0.95) 4px,
          rgba(160,82,45,0.95) 4px, rgba(160,82,45,0.95) 8px),
        linear-gradient(135deg, rgba(245,222,179,0.1) 0%, rgba(139,69,19,0.1) 100%);
      padding: 8px 12px;
      border: 3px solid #FF4500;
      border-radius: 0px;
      box-shadow: 
        0 0 0 2px #000,
        4px 4px 0px #654321,
        0 0 15px rgba(255,69,0,0.5),
        inset 0 0 10px rgba(255,215,0,0.2);
      scale: 0.9;
      image-rendering: pixelated;
      position: relative;
    }

    #player-hud::before {
      content: 'üçÉ';
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 12px;
      background: #FF4500;
      border: 2px solid #000;
      padding: 2px;
      filter: sepia(1) hue-rotate(20deg);
    }

    #health-container {
      background: 
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.7) 0px, rgba(0,0,0,0.7) 2px,
          rgba(26,26,46,0.7) 2px, rgba(26,26,46,0.7) 4px);
      padding: 6px 8px;
      border: 2px solid #00ffff;
      display: flex;
      gap: 4px;
      margin-bottom: 6px;
      box-shadow: 
        0 0 0 1px #000,
        inset 0 0 5px rgba(0,0,0,0.5);
    }

    .player-heart {
      width: 18px;
      height: 18px;
      background: 
        repeating-conic-gradient(from 0deg, 
          #DC143C 0deg 45deg, 
          #FF6347 45deg 90deg,
          #DC143C 90deg 135deg,
          #8B0000 135deg 180deg);
      clip-path: polygon(50% 15%, 85% 35%, 85% 70%, 50% 100%, 15% 70%, 15% 35%);
      animation: ninja-heart-pulse 1.2s steps(4) infinite;
      image-rendering: pixelated;
      box-shadow: 
        2px 2px 0px #000,
        0 0 6px rgba(220,20,60,0.8),
        inset 0 0 4px rgba(255,215,0,0.3);
      position: relative;
    }

    .player-heart::before {
      content: '‚ô•';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 10px;
      text-shadow: 1px 1px 0px #000;
    }

    @keyframes ninja-heart-pulse {
      0%, 100% { 
        transform: scale(1);
        filter: hue-rotate(0deg);
      }
      50% { 
        transform: scale(1.3);
        filter: hue-rotate(15deg);
      }
    }

    .heart-empty {
      background: 
        repeating-conic-gradient(from 0deg, 
          #333333 0deg 45deg, 
          #666666 45deg 90deg,
          #333333 90deg 135deg,
          #111111 135deg 180deg);
      box-shadow: 1px 1px 0px #000;
      animation: none;
    }

    @keyframes pixel-heart-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    #player-level {
      font-size: 8px;
      color: #ffff00;
      text-shadow: 
        1px 1px 0px #000,
        2px 2px 0px rgba(255,255,0,0.5);
      font-weight: normal;
      letter-spacing: 1px;
    }

    #loading-status {
      margin-top: 8px;
      font-size: 10px;
      color: #00ffff;
      text-shadow: 1px 1px 0px #000;
    }

    #loading-size {
      margin-top: 4px;
      font-size: 8px;
      color: #ffff00;
      text-shadow: 1px 1px 0px #000;
    }

    .enemy-hearts {
      position: absolute;
      display: flex;
      gap: 1px;
      filter: drop-shadow(1px 1px 0px #000);
    }

    .enemy-heart {
      width: 6px;
      height: 6px;
      background: 
        linear-gradient(45deg, #ff0000 50%, #cc0000 50%);
      clip-path: polygon(50% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%);
      image-rendering: pixelated;
    }

    .enemy-heart.heart-empty {
      background: 
        linear-gradient(45deg, #333 50%, #111 50%);
    }

    /* Efectos de part√≠culas pixeladas */
    @keyframes pixel-spark {
      0% { transform: scale(1) rotate(0deg); opacity: 1; }
      100% { transform: scale(0) rotate(180deg); opacity: 0; }
    }

    /* Scrollbar pixel style */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: 
        repeating-linear-gradient(90deg, #000 0px, #000 2px, #333 2px, #333 4px);
    }

    ::-webkit-scrollbar-thumb {
      background: 
        repeating-linear-gradient(90deg, #00ffff 0px, #00ffff 2px, #0080ff 2px, #0080ff 4px);
      border: 1px solid #000;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: 
        repeating-linear-gradient(90deg, #ffff00 0px, #ffff00 2px, #ff8000 2px, #ff8000 4px);
    }
  </style>
</head>
<body>
  <!-- Pantalla de cr√©ditos Glam Works -->
  <div id="glam-credits">
    <div id="glam-logo">
      <h1>GLAM WORKS</h1>
      <div class="glam-subtitle">PRESENTA</div>
    </div>
    <div id="glam-skip">PRESIONA PARA SALTAR</div>
  </div>

  <!-- Pantalla de video personalizado -->
  <div id="video-intro" style="display:none;">
    <!-- Selector de idioma -->
    <div id="language-selector" style="
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1003;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border: 2px solid #FF4500;
      font-family: 'Press Start 2P', cursive;
      font-size: 8px;
    ">
      <div style="color: #FFD700; margin-bottom: 8px;">IDIOMA:</div>
      <button id="btn-japanese" style="
        background: #FF4500;
        color: #FFD700;
        border: 1px solid #FFD700;
        padding: 4px 8px;
        margin-right: 5px;
        font-family: 'Press Start 2P', cursive;
        font-size: 6px;
        cursor: pointer;
      ">Êó•Êú¨Ë™û</button>
      <button id="btn-spanish" style="
        background: #FF4500;
        color: #FFD700;
        border: 1px solid #FFD700;
        padding: 4px 8px;
        font-family: 'Press Start 2P', cursive;
        font-size: 6px;
        cursor: pointer;
      ">ESPA√ëOL</button>
    </div>

    <video id="intro-video" 
           style="width:100%;height:100%;object-fit:cover;background:#000;" 
           playsinline
           preload="auto">
      <source src="https://www.dropbox.com/scl/fi/f5qq6dgnlxidywwy1lpkt/copy_6D6E0B3D-1282-4F5B-A6D1-A0F5128B8C58.mov?rlkey=fsxtkk4gfpqjsntckvmc5xwdo&st=42rx8l0i&dl=1" type="video/mp4">
    </video>
    <div id="video-skip-button" style="display:none;">PRESIONA PARA SALTAR</div>
  </div>

  <!-- Pantalla de inicio con logo Naruto arreglado -->
  <div id="intro-screen" style="display:none;">
    <div id="naruto-logo-container">
      <img id="naruto-logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Logo_Naruto_Shipp%C5%ABden.svg/2560px-Logo_Naruto_Shipp%C5%ABden.svg.png" alt="Naruto Shippuden">
    </div>
  </div>
  <!-- Pantalla de carga -->
  <div id="loading">
    <h2>CARGANDO...</h2>
    <div id="loading-status">INICIANDO...</div>
    <div id="loading-size">0 MB / 100 MB</div>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
  </div>

  <!-- Selecci√≥n de personaje -->
  <div id="char-select">
    <div class="select-header">
      <h2>SELECCIONA TU PERSONAJE</h2>
      <div class="scroll-design"></div>
    </div>
    <audio id="hover-sound" src="https://www.soundjay.com/buttons/button-09a.mp3"></audio>
    <audio id="select-sound" src="https://www.soundjay.com/buttons/button-37a.mp3"></audio>

    <div class="characters-grid">
      <div class="char-card" onclick="selectCharacter('neji')" onmouseover="playHoverSound()">
        <h3>NEJI HYUGA</h3>
        <div class="char-img" style="background: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_JLthZ20l4C_V-G8cKVR_3hOqAyrTOVTLaw&s') center/contain no-repeat;"></div>
        <p>PODERES: BYAKUGAN, JUKEN, 64 PALMAS, 128 PALMAS, KAITEN</p>
      </div>
      <div class="char-card" onclick="selectCharacter('itachi')">
        <h3>ITACHI UCHIHA</h3>
        <div class="char-img" style="background: url('https://officialpsds.com/imageview/r0/68/r068ny_large.png?1521316545') center/contain no-repeat;"></div>
        <p>PODERES: SHARINGAN, AMATERASU, TSUKUYOMI, SUSANOO</p>
      </div>
      <div class="char-card" onclick="selectCharacter('ino')">
        <h3>INO YAMANAKA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/c/cc/Ino_Segunda_Guerra_Mundial_Shinobi_HD.png') center/contain no-repeat;"></div>
        <p>PODERES: TRANSFERENCIA DE MENTE, BOMBA DE CHAKRA, CONTROL MENTAL, CURACION</p>
      </div>
      <div class="char-card" onclick="selectCharacter('shikamaru')">
        <h3>SHIKAMARU NARA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/9a/Shikamaru_Nara.png') center/contain no-repeat;"></div>
        <p>PODERES: POSESION DE SOMBRA, ESTRANGULACION DE SOMBRA, COSTURA DE SOMBRA, IMITACION DE SOMBRA</p>
      </div>
      <div class="char-card" onclick="selectCharacter('tenten')">
        <h3>TENTEN</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/92/Tenten_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: INVOCACION DE ARMAS, LLUVIA DE KUNAIS, PERGAMINO GIGANTE, BARRERA DE ARMAS</p>
      </div>
      <div class="char-card" onclick="selectCharacter('hinata')">
        <h3>HINATA HYUGA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/9/97/Hinata.png') center/contain no-repeat;"></div>
        <p>PODERES: BYAKUGAN, PUNO SUAVE, LEON GEMELO, PROTECCION DE 8 TRIGRAMAS</p>
      </div>
      <div class="char-card" onclick="selectCharacter('temari')">
        <h3>TEMARI</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/7/7c/Temari_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: DANZA DEL ABANICO, TORBELLINO CORTANTE, GUADANA COMADREJA, INVOCACION</p>
      </div>
      <div class="char-card" onclick="selectCharacter('sasuke')">
        <h3>SASUKE UCHIHA</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/2/21/Sasuke_Part_2.png') center/contain no-repeat;"></div>
        <p>PODERES: CHIDORI, SHARINGAN, AMATERASU, KIRIN</p>
      </div>
      <div class="char-card" onclick="selectCharacter('hashirama')">
        <h3>HASHIRAMA SENJU</h3>
        <div class="char-img" style="background: url('https://static.wikia.nocookie.net/naruto/images/7/7e/Hashirama_Senju.png') center/contain no-repeat;"></div>
        <p>PODERES: MOKUTON, SENJUTSU, REGENERACION, GOJU MOKUTON</p>
      </div>
    </div>
  </div>

  <!-- Joystick -->
  <div id="joystick">
    <div id="joy-base"></div>
    <div id="joy-thumb"></div>
  </div>

  <!-- Botones (se actualizar√°n seg√∫n el personaje) -->
  <div id="actions"></div>

  <!-- Player HUD -->
  <div id="player-hud">
    <div id="health-container"></div>
    <div id="player-level">NIVEL 1</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
  // Variables globales para idioma
  let currentLanguage = 'japanese'; // Por defecto japon√©s

  // Traducciones para subt√≠tulos - SEPARADAS POR IDIOMA
  const subtitles = {
    japanese: [
      {time: 1, text: '„Éí„Éä„Çø„ÅÆÊÑõ„ÅÆÁâ©Ë™û<br>Hinata no Ai no Monogatari'},
      {time: 3, text: 'ÂΩºÂ•≥„ÅØÂ∏∏„Å´ÂΩº„ÇíË¶ã„Å§„ÇÅ„Å¶„ÅÑ„Åü<br>Kanojo wa tsuneni kare wo mitsumete ita'},
      {time: 6, text: '„Éä„É´„Éà„ÅÆÂãáÊ∞ó„Å´ÂøÉ„ÇíÂ•™„Çè„Çå„Åü<br>Naruto no yuuki ni kokoro wo ubawareta'},
      {time: 9, text: 'ÂΩº„ÅØÊ±∫„Åó„Å¶Ë´¶„ÇÅ„Å™„Åã„Å£„Åü<br>Kare wa kesshite akiramenakatta'},
      {time: 12, text: '„Åù„ÅÆÂº∑„Åï„Åå„Éí„Éä„Çø„ÇíÂ§â„Åà„Åü<br>Sono tsuyosa ga Hinata wo kaeta'},
      {time: 15, text: 'Áúü„ÅÆÊÑõ„ÅØÂãáÊ∞ó„Åã„ÇâÁîü„Åæ„Çå„Çã<br>Shin no ai wa yuuki kara umareru'},
      {time: 18, text: '„Éí„Éä„Çø‚ù§„Éä„É´„Éà<br>Hinata ‚ù§ Naruto'}
    ],
    spanish: [
      {time: 1, text: 'La Historia del Amor de Hinata'},
      {time: 3, text: 'Ella siempre lo miraba en silencio'},
      {time: 6, text: 'Su coraz√≥n fue conquistado por el valor de Naruto'},
      {time: 9, text: '√âl nunca se rindi√≥ ante nada'},
      {time: 12, text: 'Esa fuerza interior cambi√≥ a Hinata'},
      {time: 15, text: 'El amor verdadero nace del valor'},
      {time: 18, text: 'Hinata ‚ù§ Naruto - Para siempre juntos'}
    ]
  };

  // Secuencia completa: Glam Works ‚Üí Video ‚Üí Logo ‚Üí Personajes
  const glamCredits = document.getElementById('glam-credits');
  const glamSkip = document.getElementById('glam-skip');
  const videoIntro = document.getElementById('video-intro');
  const introVideo = document.getElementById('intro-video');
  const videoSkipButton = document.getElementById('video-skip-button');
  const introScreen = document.getElementById('intro-screen');

  let currentStep = 1; // 1=Glam, 2=Video, 3=Logo, 4=Game
  let canSkip = false;

  // PASO 1: Cr√©ditos Glam Works
  function showGlamCredits() {
    glamCredits.style.display = 'flex';
    canSkip = false;

    // Permitir skip despu√©s de 2 segundos
    setTimeout(() => {
      canSkip = true;
    }, 2000);

    // NO auto-avanzar - solo manual
  }

  // PASO 2: Video personalizado (SIN cr√©ditos encima)
  function showVideo() {
    glamCredits.style.display = 'none';
    videoIntro.style.display = 'flex';
    canSkip = false;

    // SILENCIAR COMPLETAMENTE YouTube durante el video del intro
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube silenciado para el video del intro');
    }

    // Quitar la superposici√≥n de cr√©ditos del video
    const videoCreditsOverlay = document.getElementById('video-credits-overlay');
    if(videoCreditsOverlay) {
      videoCreditsOverlay.style.display = 'none';
    }

    // NO crear subt√≠tulos ya que el video tiene subt√≠tulos incorporados
    const createSubtitles = () => {
      console.log('üìù Subt√≠tulos deshabilitados - el video ya tiene subt√≠tulos incorporados');
      return null;
    };

    // Reproducir el video autom√°ticamente y completo
    const startVideo = () => {
      // Reproducir autom√°ticamente con audio
      introVideo.muted = false;
      introVideo.play().then(() => {
        console.log('Video reproduci√©ndose autom√°ticamente con subt√≠tulos incorporados');
      }).catch(e => {
        console.log('Autoplay bloqueado, requiere interacci√≥n:', e);
        // Si falla, mostrar mensaje para interactuar
        showPlayMessage();
      });
    };

    const showPlayMessage = () => {
      let playMessage = document.createElement('div');
      playMessage.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ffff;
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        text-align: center;
        background: rgba(0,0,0,0.8);
        padding: 20px;
        border: 2px solid #00ffff;
        z-index: 1001;
        animation: pixelBlink 1.5s steps(2) infinite;
        cursor: pointer;
      `;
      playMessage.innerHTML = 'TOCA PARA REPRODUCIR<br>VIDEO COMPLETO CON<br>SUBTITULOS INCORPORADOS';
      videoIntro.appendChild(playMessage);

      // Reproducir cuando se haga clic en el mensaje
      playMessage.addEventListener('click', () => {
        introVideo.muted = false;
        introVideo.play().then(() => {
          playMessage.remove();
          console.log('Video reproduci√©ndose con subt√≠tulos incorporados');
        });
      });

      // Tambi√©n permitir clic en cualquier parte del video
      videoIntro.addEventListener('click', () => {
        introVideo.muted = false;
        introVideo.play().then(() => {
          playMessage.remove();
          console.log('Video reproduci√©ndose con subt√≠tulos incorporados');
        });
      }, {once: true});
    };

    // Iniciar inmediatamente
    startVideo();

    // Mostrar bot√≥n de skip despu√©s de 10 segundos
    setTimeout(() => {
      canSkip = true;
      videoSkipButton.style.display = 'block';
    }, 10000);

    // Auto-avanzar SOLO cuando termine el video
    introVideo.addEventListener('ended', () => {
      if(currentStep === 2) {
        console.log('Video termin√≥, avanzando...');
        nextStep();
      }
    });

    // Detectar duraci√≥n del video y ajustar tiempo
    introVideo.addEventListener('loadedmetadata', () => {
      console.log('Duraci√≥n del video:', introVideo.duration, 'segundos');
    });
  }

  // PASO 3: Pantalla de inicializaci√≥n del juego
  function showGameInitialization() {
    videoIntro.style.display = 'none';

    // MANTENER YouTube silenciado durante la carga
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube mantiene silencio durante carga');
    }

    // Crear pantalla de inicializaci√≥n
    let initScreen = document.createElement('div');
    initScreen.id = 'game-init-screen';
    initScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, #ff0080 2px, transparent 3px),
        radial-gradient(circle at 80% 20%, #00ff80 2px, transparent 3px),
        radial-gradient(circle at 40% 40%, #0080ff 1px, transparent 2px),
        linear-gradient(45deg, #0a0a0a 50%, #1a0a1a 50%);
      background-size: 32px 32px, 32px 32px, 16px 16px, 8px 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-family: 'Press Start 2P', cursive;
    `;

    initScreen.innerHTML = `
      <h1 style="
        color: #00ffff;
        font-size: 24px;
        text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
        margin-bottom: 30px;
        animation: pixel-blink 1s steps(2) infinite;
      ">INICIALIZANDO JUEGO...</h1>

      <div id="init-status" style="
        color: #ffff00;
        font-size: 12px;
        text-shadow: 1px 1px 0px #000;
        margin-bottom: 20px;
      ">CARGANDO SISTEMA...</div>

      <div style="
        width: 400px;
        height: 20px;
        border: 3px solid #00ffff;
        background: repeating-linear-gradient(90deg, #000 0px, #000 2px, #1a1a1a 2px, #1a1a1a 4px);
        box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0,255,255,0.5);
      ">
        <div id="init-progress" style="
          height: 100%;
          width: 0%;
          background: repeating-linear-gradient(90deg, 
            #00ffff 0px, #00ffff 4px, 
            #0080ff 4px, #0080ff 8px,
            #8000ff 8px, #8000ff 12px,
            #ff0080 12px, #ff0080 16px);
          transition: width 0.3s ease;
        "></div>
      </div>
    `;

    document.body.appendChild(initScreen);

    // Simular proceso de carga
    let progress = 0;
    let statusEl = document.getElementById('init-status');
    let progressEl = document.getElementById('init-progress');

    const loadingSteps = [
      "DESCARGANDO PAQUETES DE JUTSU...",
      "INSTALANDO EFECTOS DE CHAKRA...",
      "CARGANDO MODELOS 3D...",
      "CONFIGURANDO ARENA DE COMBATE...",
      "ACTIVANDO SISTEMA DE COMBATE...",
      "SINCRONIZANDO PODERES NINJA...",
      "PREPARANDO EXPERIENCIA COMPLETA..."
    ];

    let stepIndex = 0;
    let loadInterval = setInterval(() => {
      progress += Math.random() * 15 + 5;
      if(progress > 100) progress = 100;

      progressEl.style.width = progress + '%';

      if(stepIndex < loadingSteps.length && progress > (stepIndex + 1) * 14) {
        statusEl.textContent = loadingSteps[stepIndex];
        stepIndex++;
      }

      if(progress >= 100) {
        clearInterval(loadInterval);
        statusEl.textContent = "¬°SISTEMA LISTO!";

        setTimeout(() => {
          initScreen.remove();
          nextStep(); // Ir a la pantalla del t√≠tulo
        }, 1500);
      }
    }, 200);

    canSkip = false;
    setTimeout(() => canSkip = true, 3000);
  }

  // PASO 4: Pantalla de t√≠tulo "Naruto Final Time"
  function showTitleScreen() {
    // MANTENER YouTube silenciado durante la pantalla de t√≠tulo
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
      console.log('YouTube silenciado en pantalla de t√≠tulo');
    }

    // Crear pantalla de t√≠tulo
    let titleScreen = document.createElement('div');
    titleScreen.id = 'title-screen';
    titleScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255,0,128,0.1) 2px, transparent 3px),
        radial-gradient(circle at 75% 75%, rgba(0,255,128,0.1) 2px, transparent 3px),
        repeating-linear-gradient(45deg, 
          rgba(0,0,0,0.95) 0px, rgba(0,0,0,0.95) 2px,
          rgba(26,26,46,0.95) 2px, rgba(26,26,46,0.95) 4px);
      background-size: 32px 32px, 32px 32px, 8px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-family: 'Press Start 2P', cursive;
    `;

    titleScreen.innerHTML = `
      <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        width: 80%;
        max-width: 800px;
        gap: 40px;
      ">
        <img src="https://i.ibb.co/Kjfn5VwH/naruto-image.png" 
             style="
               width: 200px;
               height: 200px;
               object-fit: contain;
               filter: drop-shadow(3px 3px 0px #000) drop-shadow(6px 6px 0px #ff4500);
               animation: pixel-float 3s steps(4) infinite;
               image-rendering: pixelated;
             " 
             onerror="this.style.display='none';"
             alt="Naruto" />

        <div style="text-align: center;">
          <h1 style="
            color: #ff4500;
            font-size: 32px;
            text-shadow: 
              3px 3px 0px #000,
              6px 6px 0px rgba(255,69,0,0.5),
              0 0 20px #ff4500;
            margin: 0 0 20px 0;
            letter-spacing: 4px;
            animation: pixelGlow 2s steps(4) infinite;
          ">NARUTO</h1>

          <h2 style="
            color: #00ffff;
            font-size: 24px;
            text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
            margin: 0 0 40px 0;
            letter-spacing: 3px;
          ">FINAL TIME</h2>

          <button id="play-game-btn" style="
            background: 
              repeating-conic-gradient(from 0deg, 
                rgba(255,69,0,0.8) 0deg 90deg, 
                rgba(255,140,0,0.8) 90deg 180deg);
            border: 3px solid #ff4500;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.2s steps(2);
            box-shadow: 
              0 0 0 1px #000,
              3px 3px 0px #000,
              0 0 15px rgba(255,69,0,0.5);
            text-shadow: 2px 2px 0px #000;
            animation: pixelBlink 2s steps(2) infinite;
          " 
          onmouseover="this.style.transform='scale(1.1)'; this.style.borderColor='#ffff00';"
          onmouseout="this.style.transform='scale(1)'; this.style.borderColor='#ff4500';">
            PLAY GAME
          </button>
        </div>
      </div>
    `;

    // A√±adir estilos de animaci√≥n
    const titleStyles = document.createElement('style');
    titleStyles.textContent = `
      @keyframes pixel-float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }

      @keyframes pixelGlow {
        0%, 100% { 
          text-shadow: 3px 3px 0px #000, 6px 6px 0px rgba(255,69,0,0.5);
        }
        50% { 
          text-shadow: 3px 3px 0px #000, 6px 6px 0px rgba(255,255,0,0.8), 0 0 15px #ff4500;
        }
      }

      @keyframes pixelBlink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.7; }
      }
    `;
    document.head.appendChild(titleStyles);

    document.body.appendChild(titleScreen);

    // Event listener para el bot√≥n de jugar
    document.getElementById('play-game-btn').addEventListener('click', () => {
      titleScreen.remove();
      titleStyles.remove();
      console.log('üéÆ Play button clicked - iniciando m√∫sica de batalla');
      nextStep(); // Ir a selecci√≥n de personajes
    });

    canSkip = false;
    setTimeout(() => canSkip = true, 2000);
  }

  // PASO 5: Selecci√≥n de personajes  
  function showCharacterSelect() {
    // VERIFICAR SI YA EXISTE Y LIMPIAR M√öSICA ANTERIOR
    const existingBattleMusic = document.getElementById('battle-music-video');
    if(existingBattleMusic) {
      existingBattleMusic.remove();
      console.log('üéµ M√∫sica anterior removida');
    }

    // MOSTRAR PANTALLA DE SELECCI√ìN INMEDIATAMENTE
    document.getElementById('loading').style.display = 'none';
    document.getElementById('char-select').style.display = 'flex';
    console.log('üéÆ Pantalla de selecci√≥n mostrada');

    // CREAR Y ACTIVAR M√öSICA DE BATALLA CON M√öLTIPLES INTENTOS
    function createAndPlayBattleMusic() {
      let battleMusicVideo = document.createElement('video');
      battleMusicVideo.id = 'battle-music-video';
      battleMusicVideo.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
      battleMusicVideo.src = 'https://ik.imagekit.io/lcpvlmgbf/copy_3D85FC1D-0C2F-4869-8324-615CD5FE94A5.mov/ik-video.mp4?updatedAt=1748458403027';
      battleMusicVideo.autoplay = true;
      battleMusicVideo.loop = true;
      battleMusicVideo.muted = false;
      battleMusicVideo.volume = 0.7;
      battleMusicVideo.preload = 'auto';

      document.body.appendChild(battleMusicVideo);

      // INTENTAR REPRODUCIR CON M√öLTIPLES M√âTODOS
      const playAttempts = [
        // Intento 1: Reproducci√≥n directa
        () => {
          return battleMusicVideo.play().then(() => {
            console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n directa exitosa');
            return true;
          });
        },

        // Intento 2: Con mute temporal
        () => {
          battleMusicVideo.muted = true;
          return battleMusicVideo.play().then(() => {
            setTimeout(() => {
              battleMusicVideo.muted = false;
              console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n con unmute exitosa');
            }, 200);
            return true;
          });
        },

        // Intento 3: Reiniciar y reproducir
        () => {
          battleMusicVideo.currentTime = 0;
          battleMusicVideo.muted = false;
          return battleMusicVideo.play().then(() => {
            console.log('‚úÖ M√∫sica de batalla: Reproducci√≥n con reinicio exitosa');
            return true;
          });
        }
      ];

      // Ejecutar intentos secuencialmente
      function tryPlayback(attemptIndex = 0) {
        if(attemptIndex >= playAttempts.length) {
          console.log('‚ùå Todos los intentos de reproducci√≥n fallaron');
          // Crear mensaje visual para activar m√∫sica manualmente
          createManualMusicActivator();
          return;
        }

        playAttempts[attemptIndex]().catch(error => {
          console.log(`‚ö†Ô∏è Intento ${attemptIndex + 1} fall√≥:`, error);
          setTimeout(() => tryPlayback(attemptIndex + 1), 300);
        });
      }

      // Iniciar intentos de reproducci√≥n
      setTimeout(() => {
        console.log('üéµ Iniciando reproducci√≥n de m√∫sica de batalla...');
        tryPlayback();
      }, 100);

      // Verificar si la m√∫sica est√° sonando cada segundo
      let musicCheckInterval = setInterval(() => {
        if(!battleMusicVideo.paused && !battleMusicVideo.muted && battleMusicVideo.currentTime > 0) {
          console.log('üéµ M√∫sica de batalla confirmada activa');
          clearInterval(musicCheckInterval);
        }
      }, 1000);

      // Limpiar verificaci√≥n despu√©s de 10 segundos
      setTimeout(() => clearInterval(musicCheckInterval), 10000);
    }

    // Crear activador manual en caso de fallos
    function createManualMusicActivator() {
      if(document.getElementById('manual-music-activator')) return;

      let activator = document.createElement('div');
      activator.id = 'manual-music-activator';
      activator.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255,69,0,0.9);
        color: white;
        padding: 10px 15px;
        border: 2px solid #ffff00;
        font-family: 'Press Start 2P', cursive;
        font-size: 8px;
        cursor: pointer;
        z-index: 1000;
        animation: pixelBlink 1s steps(2) infinite;
      `;
      activator.textContent = 'ACTIVAR M√öSICA';

      activator.addEventListener('click', () => {
        const music = document.getElementById('battle-music-video');
        if(music) {
          music.muted = false;
          music.currentTime = 0;
          music.play().then(() => {
            console.log('üéµ M√∫sica activada manualmente');
            activator.remove();
          });
        }
      });

      document.body.appendChild(activator);

      // Auto-remover despu√©s de 15 segundos
      setTimeout(() => {
        if(activator.parentNode) activator.remove();
      }, 15000);
    }

    // Activar m√∫sica inmediatamente
    createAndPlayBattleMusic();
  }

  // Funci√≥n para avanzar al siguiente paso
  function nextStep() {
    if(!canSkip && currentStep < 5) return; // No permitir skip si no est√° habilitado

    // DETENER Y SILENCIAR VIDEO SI EST√Å REPRODUCI√âNDOSE
    if(introVideo && !introVideo.paused) {
      introVideo.pause();
      introVideo.currentTime = 0;
      introVideo.muted = true;
      console.log('Video del intro detenido por skip');
    }

    currentStep++;
    switch(currentStep) {
      case 2:
        showVideo();
        break;
      case 3:
        showGameInitialization();
        break;
      case 4:
        showTitleScreen();
        break;
      case 5:
        console.log('üéµ Iniciando selecci√≥n de personajes con m√∫sica de batalla');
        showCharacterSelect();
        break;
    }
  }

  // Event listeners para saltar - SOLO cuando canSkip es true
  glamSkip.addEventListener('click', () => {
    if(canSkip) nextStep();
  });

  videoSkipButton.addEventListener('click', () => {
    if(canSkip) {
      // Detener video inmediatamente cuando se presiona skip
      if(introVideo && !introVideo.paused) {
        introVideo.pause();
        introVideo.currentTime = 0;
        introVideo.muted = true;
      }
      nextStep();
    }
  });

  // Clicks en las pantallas - SOLO cuando canSkip es true
  glamCredits.addEventListener('click', () => {
    if(canSkip) nextStep();
  });

  videoIntro.addEventListener('click', () => {
    if(canSkip) {
      // Detener video inmediatamente cuando se hace clic para skip
      if(introVideo && !introVideo.paused) {
        introVideo.pause();
        introVideo.currentTime = 0;
        introVideo.muted = true;
      }
      nextStep();
    }
  });

  // Agregar click handlers para las nuevas pantallas
  document.addEventListener('click', (e) => {
    if(canSkip) {
      if(e.target.closest('#game-init-screen')) {
        nextStep();
      } else if(e.target.closest('#title-screen') && !e.target.closest('#play-game-btn')) {
        nextStep();
      }
    }
  });

  // Event listeners para selector de idioma - MEJORADO
  document.addEventListener('DOMContentLoaded', () => {
    // Configurar botones de idioma inmediatamente
    setupLanguageButtons();
  });

  function setupLanguageButtons() {
    // Intentar configurar botones cada 500ms hasta que existan
    const trySetup = () => {
      const btnJapanese = document.getElementById('btn-japanese');
      const btnSpanish = document.getElementById('btn-spanish');

      if(btnJapanese && btnSpanish) {
        btnJapanese.addEventListener('click', () => {
          currentLanguage = 'japanese';
          updateLanguageButtons();
          console.log('‚úÖ Idioma cambiado a japon√©s - solo subt√≠tulos en japon√©s');
          // Actualizar subt√≠tulos si el video ya est√° reproduci√©ndose
          updateCurrentSubtitles();
        });

        btnSpanish.addEventListener('click', () => {
          currentLanguage = 'spanish';
          updateLanguageButtons();
          console.log('‚úÖ Idioma cambiado a espa√±ol - solo subt√≠tulos en espa√±ol');
          // Actualizar subt√≠tulos si el video ya est√° reproduci√©ndose
          updateCurrentSubtitles();
        });

        updateLanguageButtons();
        console.log('üåê Selector de idioma configurado correctamente');
      } else {
        // Reintentar despu√©s de 500ms
        setTimeout(trySetup, 500);
      }
    };

    trySetup();
  }

  function updateLanguageButtons() {
    const btnJapanese = document.getElementById('btn-japanese');
    const btnSpanish = document.getElementById('btn-spanish');

    if(btnJapanese && btnSpanish) {
      // Resetear estilos
      btnJapanese.style.background = '#FF4500';
      btnJapanese.style.color = '#FFD700';
      btnSpanish.style.background = '#FF4500';
      btnSpanish.style.color = '#FFD700';

      // Destacar idioma seleccionado
      if(currentLanguage === 'japanese') {
        btnJapanese.style.background = '#FFD700';
        btnJapanese.style.color = '#000000';
        btnJapanese.style.fontWeight = 'bold';
        btnSpanish.style.fontWeight = 'normal';
      } else {
        btnSpanish.style.background = '#FFD700';
        btnSpanish.style.color = '#000000';
        btnSpanish.style.fontWeight = 'bold';
        btnJapanese.style.fontWeight = 'normal';
      }
    }
  }

  function updateCurrentSubtitles() {
    // No hay subt√≠tulos para actualizar - el video tiene subt√≠tulos incorporados
    console.log('Subt√≠tulos incorporados en el video - no requiere actualizaci√≥n');
  }

  // Iniciar secuencia
  showGlamCredits();

  // Reproducir m√∫sica de intro con YouTube (opcional)
  let youtubePlayer;

  // Crear el iframe de YouTube
  let ytContainer = document.createElement('div');
  ytContainer.style.cssText = 'display:none;';
  ytContainer.innerHTML = `
    <iframe id="youtube-player" 
            width="560" height="315" 
            src="https://www.youtube.com/embed/6YsxjUhZw1A?enablejsapi=1" 
            allow="autoplay">
    </iframe>`;
  document.body.appendChild(ytContainer);

  // Cargar API de YouTube
  let tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  document.body.appendChild(tag);

  // Funci√≥n que se llama cuando la API est√° lista
  window.onYouTubeIframeAPIReady = function() {
    youtubePlayer = new YT.Player('youtube-player', {
      events: {
        'onReady': onPlayerReady
      }
    });
  };

  function onPlayerReady(event) {
    // Pausar inmediatamente el video de YouTube y mantenerlo silenciado
    youtubePlayer.pauseVideo();
    youtubePlayer.mute();
    console.log('YouTube inicializado y silenciado - esperando selecci√≥n de personaje');
  };

  // Variables globales
  let scene, camera, renderer, player, floor;
  let enemies = [], powers = [], moveDir={x:0,z:0}, velY=0, onGround=true;
  const GRAV=-0.02, enemyHUD={};
  let playerHealth = 5; // 5 vidas
  let gameOver = false; // Detector de muerte

  // Variables para c√°mara libre 360¬∞
  let cameraAngleX = 0; // Rotaci√≥n horizontal (izquierda/derecha)
  let cameraAngleY = 0; // Rotaci√≥n vertical (arriba/abajo)
  let cameraDistance = 10; // Distancia de la c√°mara al jugador
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  const MAX_HEALTH = 5;
  const WORLD_CONFIG = {
    name: 'Mundo de Konoha',
    maxEnemies: 8,
    enemyHealth: 100,
    respawnTime: 10000
  };

  

  function updatePlayerHUD() {
    const container = document.getElementById('health-container');
    container.innerHTML = '';
    for(let i = 0; i < MAX_HEALTH; i++) {
      const heart = document.createElement('div');
      heart.className = `player-heart ${i >= playerHealth ? 'heart-empty' : ''}`;
      container.appendChild(heart);
    }
    document.getElementById('player-level').textContent = 'MUNDO ABIERTO - KONOHA';
    
    // Agregar indicador de salto
    let jumpIndicator = document.createElement('div');
    jumpIndicator.id = 'jump-indicator';
    jumpIndicator.style.cssText = `
      font-size: 6px;
      color: #00FF00;
      text-shadow: 1px 1px 0px #000;
      margin-top: 4px;
    `;
    jumpIndicator.textContent = 'SUELO: S√ç';
    document.getElementById('player-hud').appendChild(jumpIndicator);
  }
  let currentCharacter = '';
let playerSpeed = 0.25; // Velocidad base aumentada
let characterNames = {
  'neji': 'NEJI HYUGA',
  'itachi': 'ITACHI UCHIHA',
  'ino': 'INO YAMANAKA',
  'shikamaru': 'SHIKAMARU NARA',
  'tenten': 'TENTEN',
  'hinata': 'HINATA HYUGA',
  'temari': 'TEMARI',
  'sasuke': 'SASUKE UCHIHA'
};

// Mostrar nombre del personaje
function showCharacterName() {
  let nameDiv = document.createElement('div');
  nameDiv.style.cssText = `
    position: fixed;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    color: #00ffff;
    font-size: 16px;
    font-family: 'Press Start 2P', cursive;
    font-weight: normal;
    text-shadow: 2px 2px 0px #000, 4px 4px 0px rgba(0,255,255,0.5);
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 12px;
    border: 2px solid #00ffff;
    box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0,255,255,0.5);
  `;
  nameDiv.textContent = characterNames[currentCharacter];
  document.body.appendChild(nameDiv);

  // Mostrar controles para PC
  let controlsDiv = document.createElement('div');
  controlsDiv.style.cssText = `
    position: fixed;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    color: #FFD700;
    font-size: 8px;
    font-family: 'Press Start 2P', cursive;
    text-align: center;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 6px 10px;
    border: 2px solid #FFD700;
    box-shadow: 0 0 0 1px #000, 0 0 10px rgba(255,215,0,0.5);
    max-width: 400px;
  `;
  controlsDiv.innerHTML = `
    PC: WASD=MOVER | MOUSE=CAMARA | ESPACIO=SALTO<br>
    PODERES: TECLAS 1-7 O BOTONES | MOVIL: JOYSTICK + BOTONES
  `;
  document.body.appendChild(controlsDiv);

  // Remover despu√©s de 8 segundos
  setTimeout(() => {
    if(nameDiv.parentNode) nameDiv.remove();
    if(controlsDiv.parentNode) controlsDiv.remove();
  }, 8000);
}

  // Sistema de carga con almacenamiento local
  window.onload = () => {
    // Verificar si ya se carg√≥ anteriormente
    if(localStorage.getItem('narutoGameLoaded')) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('char-select').style.display = 'flex';
      return;
    }

    let progress = 0;
    const loadingBar = document.getElementById('loading-progress');
    const loadingStatus = document.getElementById('loading-status');
    const loadingSize = document.getElementById('loading-size');
    const totalSize = 250; // Aumentamos el tama√±o total
    const loadingSteps = [
      {progress: 10, message: "DESCARGANDO MODELOS 3D BASE...", size: 25},
      {progress: 20, message: "CARGANDO TEXTURAS DE PERSONAJES...", size: 50},
      {progress: 30, message: "INSTALANDO EFECTOS DE JUTSU...", size: 75},
      {progress: 40, message: "CARGANDO ANIMACIONES...", size: 100},
      {progress: 50, message: "INSTALANDO EFECTOS DE PARTICULAS...", size: 125},
      {progress: 60, message: "CARGANDO SONIDOS Y MUSICA...", size: 150},
      {progress: 70, message: "CONFIGURANDO FISICA DEL JUEGO...", size: 175},
      {progress: 80, message: "OPTIMIZANDO RENDIMIENTO...", size: 200},
      {progress: 90, message: "FINALIZANDO INSTALACION...", size: 225},
      {progress: 100, message: "INSTALACION COMPLETADA!", size: 250}
    ];

      let currentStep = 0;
      const interval = setInterval(() => {
        if(currentStep < loadingSteps.length) {
          let step = loadingSteps[currentStep];
          if(progress < step.progress) {
            progress += 1;
            loadingBar.style.width = progress + '%';
            loadingSize.textContent = `${Math.floor(progress * totalSize / 100)} MB / ${totalSize} MB`;
          } else {
            loadingStatus.textContent = step.message;
            currentStep++;
          }
        }
        if(progress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            // Guardar en localStorage que ya se carg√≥ el juego
            localStorage.setItem('narutoGameLoaded', 'true');
            document.getElementById('loading').style.display = 'none';
            document.getElementById('char-select').style.display = 'flex';
          }, 1000);
        }
      }, 100); // Aumentamos el intervalo para simular una carga m√°s realista
    };

  function playHoverSound() {
    document.getElementById('hover-sound').play();
  }

  function selectCharacter(char) {
    document.getElementById('select-sound').play();
    currentCharacter = char;

    // Mostrar pantalla de transici√≥n con animaci√≥n
    showCharacterTransition(char);
  }

  function showCharacterTransition(char) {
    // Crear pantalla de transici√≥n
    let transitionScreen = document.createElement('div');
    transitionScreen.id = 'character-transition';
    transitionScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      transition: all 1s ease-in-out;
    `;

    // Obtener datos del personaje
    const characterData = {
      'neji': {
        name: 'NEJI HYUGA',
        image: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_JLthZ20l4C_V-G8cKVR_3hOqAyrTOVTLaw&s',
        abilities: 'BYAKUGAN ‚Ä¢ JUKEN ‚Ä¢ 64 PALMAS'
      },
      'itachi': {
        name: 'ITACHI UCHIHA',
        image: 'https://officialpsds.com/imageview/r0/68/r068ny_large.png?1521316545',
        abilities: 'SHARINGAN ‚Ä¢ AMATERASU ‚Ä¢ TSUKUYOMI'
      },
      'ino': {
        name: 'INO YAMANAKA',
        image: 'https://static.wikia.nocookie.net/naruto/images/c/cc/Ino_Segunda_Guerra_Mundial_Shinobi_HD.png',
        abilities: 'MENTE ‚Ä¢ CONTROL ‚Ä¢ CURACI√ìN'
      },
      'shikamaru': {
        name: 'SHIKAMARU NARA',
        image: 'https://static.wikia.nocookie.net/naruto/images/9/9a/Shikamaru_Nara.png',
        abilities: 'SOMBRAS ‚Ä¢ POSESI√ìN ‚Ä¢ ESTRATEGIA'
      },
      'tenten': {
        name: 'TENTEN',
        image: 'https://static.wikia.nocookie.net/naruto/images/9/92/Tenten_Part_2.png',
        abilities: 'ARMAS ‚Ä¢ INVOCACI√ìN ‚Ä¢ PERGAMINOS'
      },
      'hinata': {
        name: 'HINATA HYUGA',
        image: 'https://static.wikia.nocookie.net/naruto/images/9/97/Hinata.png',
        abilities: 'BYAKUGAN ‚Ä¢ PU√ëO SUAVE ‚Ä¢ LEONES'
      },
      'temari': {
        name: 'TEMARI',
        image: 'https://static.wikia.nocookie.net/naruto/images/7/7c/Temari_Part_2.png',
        abilities: 'ABANICO ‚Ä¢ VIENTO ‚Ä¢ TORBELLINO'
      },
      'sasuke': {
        name: 'SASUKE UCHIHA',
        image: 'https://static.wikia.nocookie.net/naruto/images/2/21/Sasuke_Part_2.png',
        abilities: 'CHIDORI ‚Ä¢ SHARINGAN ‚Ä¢ KIRIN'
      },
      'hashirama': {
        name: 'HASHIRAMA SENJU',
        image: 'https://static.wikia.nocookie.net/naruto/images/7/7e/Hashirama_Senju.png',
        abilities: 'MOKUTON ‚Ä¢ SENJUTSU ‚Ä¢ REGENERACI√ìN'
      }
    };

    const selectedChar = characterData[char];

    transitionScreen.innerHTML = `
      <div style="
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 90%;
        max-width: 1000px;
        height: 80%;
      ">
        <!-- Informaci√≥n del personaje (lado izquierdo) -->
        <div id="char-info-left" style="
          flex: 1;
          padding: 40px;
          text-align: left;
          transform: translateX(-100px);
          opacity: 0;
          transition: all 1.5s ease-out;
        ">
          <h1 style="
            color: #FF4500;
            font-size: 28px;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 
              3px 3px 0px #000,
              6px 6px 0px rgba(255,69,0,0.5),
              0 0 20px #FF4500;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
          ">${selectedChar.name}</h1>

          <div style="
            color: #FFD700;
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 2px 2px 0px #000;
            margin: 20px 0;
            line-height: 1.6;
          ">HABILIDADES:</div>

          <div style="
            color: #00FFFF;
            font-size: 10px;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 1px 1px 0px #000;
            margin: 0 0 40px 0;
            line-height: 1.8;
          ">${selectedChar.abilities}</div>

          <button id="start-battle-btn" style="
            background: 
              repeating-conic-gradient(from 0deg, 
                rgba(255,69,0,0.9) 0deg 90deg, 
                rgba(255,140,0,0.9) 90deg 180deg);
            border: 4px solid #FF4500;
            color: #FFFFFF;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 20px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
              0 0 0 2px #000,
              4px 4px 0px #000,
              0 0 20px rgba(255,69,0,0.6);
            text-shadow: 2px 2px 0px #000;
            letter-spacing: 2px;
            transform: scale(0.8);
            opacity: 0;
            animation: buttonAppear 2s ease-out 2s forwards;
          " 
          onmouseover="this.style.transform='scale(1.1)'; this.style.borderColor='#FFD700'; this.style.boxShadow='0 0 0 2px #000, 4px 4px 0px #000, 0 0 30px rgba(255,215,0,0.8)';"
          onmouseout="this.style.transform='scale(1)'; this.style.borderColor='#FF4500'; this.style.boxShadow='0 0 0 2px #000, 4px 4px 0px #000, 0 0 20px rgba(255,69,0,0.6)';">
            ¬°COMENZAR BATALLA!
          </button>
        </div>

        <!-- Imagen del personaje (lado derecho) -->
        <div id="char-image-container" style="
          flex: 1;
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative;
          transform: translateX(300px);
          opacity: 0;
          transition: all 2s ease-out;
        ">
          <div style="
            width: 350px;
            height: 400px;
            background: 
              url('${selectedChar.image}') center/contain no-repeat,
              repeating-linear-gradient(45deg,
                rgba(255,69,0,0.1) 0px, rgba(255,69,0,0.1) 4px,
                transparent 4px, transparent 8px);
            border: 4px solid #FF4500;
            border-radius: 0px;
            box-shadow: 
              0 0 0 2px #000,
              6px 6px 0px #654321,
              0 0 30px rgba(255,69,0,0.8),
              inset 0 0 20px rgba(255,215,0,0.2);
            position: relative;
            animation: characterFloat 3s ease-in-out infinite;
            image-rendering: pixelated;
          ">
            <!-- Efectos de part√≠culas -->
            <div style="
              position: absolute;
              top: -10px;
              left: -10px;
              right: -10px;
              bottom: -10px;
              background: 
                radial-gradient(circle at 20% 20%, rgba(255,69,0,0.3) 2px, transparent 3px),
                radial-gradient(circle at 80% 80%, rgba(255,215,0,0.3) 2px, transparent 3px);
              background-size: 20px 20px, 25px 25px;
              animation: particleMove 4s linear infinite;
              pointer-events: none;
            "></div>
          </div>
        </div>
      </div>
    `;

    // A√±adir estilos de animaci√≥n
    const transitionStyles = document.createElement('style');
    transitionStyles.textContent = `
      @keyframes characterFloat {
        0%, 100% { transform: translateY(0px) scale(1); }
        50% { transform: translateY(-20px) scale(1.05); }
      }

      @keyframes particleMove {
        0% { background-position: 0 0, 0 0; }
        100% { background-position: 40px 40px, -50px -50px; }
      }

      @keyframes buttonAppear {
        0% { transform: scale(0.8); opacity: 0; }
        50% { transform: scale(1.2); opacity: 0.8; }
        100% { transform: scale(1); opacity: 1; }
      }
    `;
    document.head.appendChild(transitionStyles);

    document.body.appendChild(transitionScreen);

    // Secuencia de animaci√≥n
    setTimeout(() => {
      // Aplicar blur a la pantalla de selecci√≥n
      document.getElementById('char-select').style.filter = 'blur(20px)';
      transitionScreen.style.opacity = '1';
    }, 100);

    setTimeout(() => {
      // Animar entrada de informaci√≥n
      document.getElementById('char-info-left').style.transform = 'translateX(0)';
      document.getElementById('char-info-left').style.opacity = '1';
    }, 800);

    setTimeout(() => {
      // Animar entrada de imagen del personaje
      document.getElementById('char-image-container').style.transform = 'translateX(0)';
      document.getElementById('char-image-container').style.opacity = '1';
    }, 1300);

    // Event listener para el bot√≥n de comenzar batalla
    document.getElementById('start-battle-btn').addEventListener('click', () => {
      // Animar salida
      transitionScreen.style.opacity = '0';
      transitionScreen.style.transform = 'scale(0.9)';

      setTimeout(() => {
        transitionScreen.remove();
        transitionStyles.remove();
        document.getElementById('char-select').style.display = 'none';
        document.getElementById('char-select').style.filter = 'none';

        // Iniciar el juego
        startGameWithCharacter(char);
      }, 1000);
    });
  }

  function startGameWithCharacter(char) {
    currentCharacter = char;
    updatePlayerHUD();
    showCharacterName();

    // DETENER COMPLETAMENTE la m√∫sica de batalla al entrar al campo de batalla
    const battleMusic = document.getElementById('battle-music-video');
    if(battleMusic) {
      battleMusic.pause();
      battleMusic.currentTime = 0;
      battleMusic.muted = true;
      battleMusic.remove();
      console.log('üîá M√∫sica de batalla detenida completamente - entrando al campo de batalla');
    }

    // Remover activador manual si existe
    const manualActivator = document.getElementById('manual-music-activator');
    if(manualActivator) {
      manualActivator.remove();
      console.log('üîá Activador manual removido');
    }

    // Configurar botones seg√∫n el personaje
    const actions = document.getElementById('actions');
    actions.innerHTML = '';

    const addButton = (id, text) => {
      const btn = document.createElement('div');
      btn.id = id;
      btn.className = 'action-btn';
      btn.textContent = text;
      actions.appendChild(btn);
      return btn;
    };

    addButton('jump', 'JUMP');

    if(char === 'neji') {
      // Byakugan
      let byakBtn = addButton('btn-byak', 'BYAK');
      byakBtn.addEventListener('touchstart', e => {e.preventDefault(); activateByakugan();});
      byakBtn.addEventListener('click', activateByakugan);
      
      // Juken
      let jukenBtn = addButton('btn-juken', 'JUKEN');
      jukenBtn.addEventListener('touchstart', e => {e.preventDefault(); activateJuken();});
      jukenBtn.addEventListener('click', activateJuken);
      
      // 64 Palmas
      let palm64Btn = addButton('btn-64', '64P');
      palm64Btn.addEventListener('touchstart', e => {e.preventDefault(); activate64Palms();});
      palm64Btn.addEventListener('click', activate64Palms);
      
      // 128 Palmas
      let palm128Btn = addButton('btn-128', '128P');
      palm128Btn.addEventListener('touchstart', e => {e.preventDefault(); activate128Palms();});
      palm128Btn.addEventListener('click', activate128Palms);
      
      // Kaiten
      let kaitenBtn = addButton('btn-kaiten', 'KAIT');
      kaitenBtn.addEventListener('touchstart', e => {e.preventDefault(); activateKaiten();});
      kaitenBtn.addEventListener('click', activateKaiten);
      
      // Kusho
      let kushoBtn = addButton('btn-kusho', 'KUSH');
      kushoBtn.addEventListener('touchstart', e => {e.preventDefault(); activateKusho();});
      kushoBtn.addEventListener('click', activateKusho);
      
      // Detecci√≥n
      let detectBtn = addButton('btn-det', 'DET');
      detectBtn.addEventListener('touchstart', e => {e.preventDefault(); activateDetect();});
      detectBtn.addEventListener('click', activateDetect);
    } else if(char === 'itachi') {
      // Sharingan
      let sharinganBtn = addButton('btn-sharingan', 'SHAR');
      sharinganBtn.addEventListener('touchstart', e => {e.preventDefault(); activateSharingan();});
      sharinganBtn.addEventListener('click', activateSharingan);
      
      // Amaterasu
      let amaterasuBtn = addButton('btn-amaterasu', 'AMAT');
      amaterasuBtn.addEventListener('touchstart', e => {e.preventDefault(); activateAmaterasu();});
      amaterasuBtn.addEventListener('click', activateAmaterasu);
      
      // Tsukuyomi
      let tsukuyomiBtn = addButton('btn-tsukuyomi', 'TSUK');
      tsukuyomiBtn.addEventListener('touchstart', e => {e.preventDefault(); activateTsukuyomi();});
      tsukuyomiBtn.addEventListener('click', activateTsukuyomi);
      
      // Susanoo
      let susanooBtn = addButton('btn-susanoo', 'SUSA');
      susanooBtn.addEventListener('touchstart', e => {e.preventDefault(); activateSusanoo();});
      susanooBtn.addEventListener('click', activateSusanoo);
    } else if(char === 'ino') {
      // Transferencia Mental
      let mindBtn = addButton('btn-mind-transfer', 'MIND');
      mindBtn.addEventListener('touchstart', e => {e.preventDefault(); activateMindTransfer();});
      mindBtn.addEventListener('click', activateMindTransfer);
      
      // Bomba de Chakra
      let bombBtn = addButton('btn-chakra-bomb', 'BOMB');
      bombBtn.addEventListener('touchstart', e => {e.preventDefault(); activateChakraBomb();});
      bombBtn.addEventListener('click', activateChakraBomb);
      
      // Control Mental
      let ctrlBtn = addButton('btn-mind-control', 'CTRL');
      ctrlBtn.addEventListener('touchstart', e => {e.preventDefault(); activateMindControl();});
      ctrlBtn.addEventListener('click', activateMindControl);
      
      // Curaci√≥n
      let healBtn = addButton('btn-healing', 'HEAL');
      healBtn.addEventListener('touchstart', e => {e.preventDefault(); activateHealing();});
      healBtn.addEventListener('click', activateHealing);
    } else if(char === 'shikamaru') {
      // Posesi√≥n de Sombra
      let possBtn = addButton('btn-shadow-possession', 'POSS');
      possBtn.addEventListener('touchstart', e => {e.preventDefault(); activateShadowPossession();});
      possBtn.addEventListener('click', activateShadowPossession);
      
      // Estrangulaci√≥n de Sombra
      let strnBtn = addButton('btn-shadow-strangle', 'STRN');
      strnBtn.addEventListener('touchstart', e => {e.preventDefault(); activateShadowStrangle();});
      strnBtn.addEventListener('click', activateShadowStrangle);
    } else if(char === 'tenten') {
      // Invocaci√≥n de Armas
      let summBtn = addButton('btn-weapon-summon', 'SUMM');
      summBtn.addEventListener('touchstart', e => {e.preventDefault(); activateWeaponSummoning();});
      summBtn.addEventListener('click', activateWeaponSummoning);
      
      // Lluvia de Kunais
      let rainBtn = addButton('btn-kunai-rain', 'RAIN');
      rainBtn.addEventListener('touchstart', e => {e.preventDefault(); activateKunaiRain();});
      rainBtn.addEventListener('click', activateKunaiRain);
    } else if(char === 'hinata') {
      // Pu√±o Suave
      let gentleBtn = addButton('btn-gentle-fist', 'GENT');
      gentleBtn.addEventListener('touchstart', e => {e.preventDefault(); activateGentleFist();});
      gentleBtn.addEventListener('click', activateGentleFist);
      
      // Leones Gemelos
      let lionBtn = addButton('btn-twin-lions', 'LION');
      lionBtn.addEventListener('touchstart', e => {e.preventDefault(); activateTwinLionFists();});
      lionBtn.addEventListener('click', activateTwinLionFists);
    } else if(char === 'temari') {
      // Danza del Abanico
      let fanBtn = addButton('btn-fan-dance', 'FAN');
      fanBtn.addEventListener('touchstart', e => {e.preventDefault(); activateFanDance();});
      fanBtn.addEventListener('click', activateFanDance);
      
      // Torbellino
      let windBtn = addButton('btn-whirlwind', 'WIND');
      windBtn.addEventListener('touchstart', e => {e.preventDefault(); activateWhirlwind();});
      windBtn.addEventListener('click', activateWhirlwind);
    } else if(char === 'sasuke') {
      // Chidori
      let chidoriBtn = addButton('btn-chidori', 'CHID');
      chidoriBtn.addEventListener('touchstart', e => {e.preventDefault(); activateChidori();});
      chidoriBtn.addEventListener('click', activateChidori);
      
      // Kirin
      let kirinBtn = addButton('btn-kirin', 'KIRI');
      kirinBtn.addEventListener('touchstart', e => {e.preventDefault(); activateKirin();});
      kirinBtn.addEventListener('click', activateKirin);
      
      // Sharingan
      let sharinganBtn2 = addButton('btn-sharingan', 'SHAR');
      sharinganBtn2.addEventListener('touchstart', e => {e.preventDefault(); activateSharingan();});
      sharinganBtn2.addEventListener('click', activateSharingan);
      
      // Amaterasu
      let amaterasuBtn2 = addButton('btn-amaterasu', 'AMAT');
      amaterasuBtn2.addEventListener('touchstart', e => {e.preventDefault(); activateAmaterasu();});
      amaterasuBtn2.addEventListener('click', activateAmaterasu);
    } else if(char === 'hashirama') {
      // Mokuton
      let mokuBtn = addButton('btn-mokuton', 'MOKU');
      mokuBtn.addEventListener('touchstart', e => {e.preventDefault(); activateMokuton();});
      mokuBtn.addEventListener('click', activateMokuton);
      
      // Senjutsu
      let senjBtn = addButton('btn-senjutsu', 'SENJ');
      senjBtn.addEventListener('touchstart', e => {e.preventDefault(); activateSenjutsu();});
      senjBtn.addEventListener('click', activateSenjutsu);
      
      // Regeneraci√≥n
      let regenBtn = addButton('btn-regen', 'REGEN');
      regenBtn.addEventListener('touchstart', e => {e.preventDefault(); activateRegeneration();});
      regenBtn.addEventListener('click', activateRegeneration);
      
      // Goju Mokuton
      let gojuBtn = addButton('btn-goju', 'GOJU');
      gojuBtn.addEventListener('touchstart', e => {e.preventDefault(); activateGojuMokuton();});
      gojuBtn.addEventListener('click', activateGojuMokuton);
    }

    // Habilidades de Hashirama
    function activateMokuton() {
      // Crear plataforma principal de madera
      let mainWood = new THREE.Group(); // Usar un grupo para mejor control

      let woodBase = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.3, 4),
        new THREE.MeshStandardMaterial({
          color: 0x8B4513,
          roughness: 0.8,
          metalness: 0.2
        })
      );
      mainWood.add(woodBase);

      // A√±adir barandillas para mejor estabilidad visual
      for(let x = -1; x <= 1; x += 2) {
        let rail = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 4),
          new THREE.MeshStandardMaterial({color: 0x8B4513})
        );
        rail.position.set(x * 0.9, 0.4, 0);
        mainWood.add(rail);
      }

      // A√±adir detalles decorativos
      for(let i = 0; i < 6; i++) {
        let detail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.05, 0.8),
          new THREE.MeshStandardMaterial({color: 0x8B4513})
        );
        detail.position.set(
          (i % 2 ? 0.9 : -0.9),
          0.3,
          (i/2 - 1) * 1.5
        );
        mainWood.add(detail);
      }

      // Posicionar la plataforma y el jugador
      mainWood.position.copy(player.position);
      mainWood.position.y = player.position.y - 0.5; // Ajustar altura inicial
      scene.add(mainWood);

      // Vincular el jugador a la plataforma
      let playerOffset = new THREE.Vector3(0, 1.75, 0);

      // Animaci√≥n de surfeo mejorada
      let time = 0;
      let woodPath = [];
      let pathInterval = setInterval(() => {
        time += 0.1;

        // Movimiento m√°s suave
        mainWood.position.y += Math.sin(time * 2) * 0.015; // Movimiento vertical m√°s sutil
        mainWood.position.z -= 0.4; // Velocidad reducida para mayor control
        mainWood.rotation.x = Math.sin(time) * 0.05; // Rotaci√≥n m√°s suave

        // Mantener al jugador firmemente sobre la plataforma
        player.position.copy(mainWood.position).add(playerOffset);
        player.rotation.x = mainWood.rotation.x; // Sincronizar rotaci√≥n

        // Crear rastro de madera
        let trail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.1, 2),
          new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            transparent: true,
            opacity: 0.7
          })
        );
        trail.position.copy(mainWood.position).add(new THREE.Vector3(0, -2, 2));
        trail.rotation.x = Math.PI/6;
        scene.add(trail);
        woodPath.push(trail);

        // Desvanecer rastro
        woodPath.forEach((w, i) => {
          w.material.opacity -= 0.05;
          if(w.material.opacity <= 0) {
            scene.remove(w);
            woodPath.splice(i, 1);
          }
        });

        // Efecto de da√±o a enemigos
        enemies.forEach(e => {
          if(e.position.distanceTo(mainWood.position) < 3) {
            e.userData.hp -= 5;
            let impact = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshBasicMaterial({
                color: 0x8B4513,
                transparent: true,
                opacity: 0.5
              })
            );
            impact.position.copy(e.position);
            scene.add(impact);
            setTimeout(() => scene.remove(impact), 300);
          }
        });

      }, 50);

      // Detener animaci√≥n despu√©s de 3 segundos
      setTimeout(() => {
        clearInterval(pathInterval);
        scene.remove(mainWood);
        woodPath.forEach(w => scene.remove(w));
        player.position.y = 1.25; // Volver al suelo
      }, 3000);
    }

    function activateSenjutsu() {
      // Modo Sabio
      player.children.forEach(part => {
        part.material.color.setHex(0xFF4500);
      });
      playerSpeed *= 1.5;
      setTimeout(() => {
        player.children.forEach(part => {
          part.material.color.setHex(0xeeeeee);
        });
        playerSpeed /= 1.5;
      }, 10000);
    }

    function activateRegeneration() {
      // Regeneraci√≥n de vida
      let heal = setInterval(() => {
        if(playerHealth < MAX_HEALTH) {
          playerHealth++;
          updatePlayerHUD();
        }
      }, 500);
      setTimeout(() => clearInterval(heal), 5000);
    }

    function activateGojuMokuton() {
      // Golem de Madera gigante
      let golem = new THREE.Group();
      let body = new THREE.Mesh(
        new THREE.BoxGeometry(4, 6, 3),
        new THREE.MeshStandardMaterial({color: 0x8B4513})
      );
      golem.add(body);
      golem.position.copy(player.position);
      scene.add(golem);

      let cnt = 0;
      let iv = setInterval(() => {
        golem.position.z -= 0.5;
        enemies.forEach(e => {
          if(e.position.distanceTo(golem.position) < 4) {
            e.userData.hp -= 15;
            flash(e.position);
          }
        });
        if(++cnt > 40) {
          clearInterval(iv);
          scene.remove(golem);
        }
      }, 100);
    }

    init();
    animate();
  }

  // Sistema de respawn autom√°tico de enemigos
  function respawnEnemies() {
    // Mantener siempre el n√∫mero m√°ximo de enemigos
    while(enemies.length < WORLD_CONFIG.maxEnemies) {
      addEnemy();
    }
  }



  // Funci√≥n para crear el mundo de Konoha √©pico como en Naruto
  function createKonohaForest() {
    // HOKAGE ROCK - MONTA√ëA DE LOS HOKAGE COMPLETA
    let hokageRock = new THREE.Group();
    hokageRock.userData.isHokageRock = true;

    // Base de la monta√±a m√°s realista
    let mountainBase = new THREE.Mesh(
      new THREE.ConeGeometry(80, 120, 8),
      new THREE.MeshStandardMaterial({
        color: 0x8B7355,
        roughness: 0.9,
        metalness: 0.1
      })
    );
    mountainBase.position.y = 60;

    // Caras de los 4 Hokage talladas
    for(let i = 0; i < 4; i++) {
      let hokageFace = new THREE.Group();
      
      // Cara principal
      let face = new THREE.Mesh(
        new THREE.BoxGeometry(25, 30, 8),
        new THREE.MeshStandardMaterial({
          color: 0xD2B48C,
          roughness: 0.7
        })
      );
      
      // Detalles faciales
      let eyes = new THREE.Mesh(
        new THREE.BoxGeometry(8, 3, 1),
        new THREE.MeshStandardMaterial({color: 0x000000})
      );
      eyes.position.set(0, 5, 4);
      
      let nose = new THREE.Mesh(
        new THREE.BoxGeometry(2, 4, 2),
        new THREE.MeshStandardMaterial({color: 0xC8A882})
      );
      nose.position.set(0, 0, 4);
      
      let mouth = new THREE.Mesh(
        new THREE.BoxGeometry(6, 2, 1),
        new THREE.MeshStandardMaterial({color: 0x8B4513})
      );
      mouth.position.set(0, -8, 4);
      
      hokageFace.add(face, eyes, nose, mouth);
      
      let angle = (i / 4) * Math.PI * 2;
      hokageFace.position.set(
        Math.cos(angle) * 60,
        80 + i * 15,
        Math.sin(angle) * 60
      );
      hokageFace.lookAt(new THREE.Vector3(0, 80, 0));
      
      hokageRock.add(hokageFace);
    }

    hokageRock.add(mountainBase);
    hokageRock.position.set(-200, 0, -300);
    scene.add(hokageRock);

    // Crear cascada principal
    let waterfall = new THREE.Group();
    waterfall.userData.isWater = true;

    // Monta√±a de la cascada
    let waterfallMountain = new THREE.Mesh(
      new THREE.BoxGeometry(25, 60, 15),
      new THREE.MeshStandardMaterial({color: 0x555555})
    );
    waterfallMountain.position.set(80, 30, -80);

    // Agua cayendo (animada)
    for(let i = 0; i < 10; i++) {
      let waterStrip = new THREE.Mesh(
        new THREE.BoxGeometry(2, 50, 1),
        new THREE.MeshStandardMaterial({
          color: 0x00BFFF,
          transparent: true,
          opacity: 0.7,
          emissive: 0x004499,
          emissiveIntensity: 0.2
        })
      );
      waterStrip.position.set(
        80 + (i - 5) * 0.5,
        5,
        -75 + Math.random() * 2
      );
      waterfall.add(waterStrip);
    }

    // Lago al pie de la cascada
    let lake = new THREE.Mesh(
      new THREE.BoxGeometry(30, 0.5, 20),
      new THREE.MeshStandardMaterial({
        color: 0x0077BE,
        transparent: true,
        opacity: 0.8,
        emissive: 0x002244,
        emissiveIntensity: 0.3
      })
    );
    lake.position.set(80, -0.2, -60);

    waterfall.add(waterfallMountain, lake);
    scene.add(waterfall);

    // Crear r√≠o que fluye desde el lago
    for(let i = 0; i < 15; i++) {
      let riverSegment = new THREE.Mesh(
        new THREE.BoxGeometry(8, 0.3, 6),
        new THREE.MeshStandardMaterial({
          color: 0x4169E1,
          transparent: true,
          opacity: 0.7
        })
      );
      riverSegment.userData.isWater = true;
      riverSegment.position.set(
        70 - i * 5,
        -0.1,
        -50 + Math.sin(i * 0.5) * 10
      );
      riverSegment.rotation.y = Math.sin(i * 0.3) * 0.2;
      scene.add(riverSegment);
    }

    // TORRE HOKAGE - Edificio ic√≥nico de Konoha
    let hokageTower = new THREE.Group();
    hokageTower.userData.isScenery = true;
    
    // Base de la torre
    let towerBase = new THREE.Mesh(
      new THREE.BoxGeometry(8, 25, 8),
      new THREE.MeshStandardMaterial({
        color: 0xD2691E,
        roughness: 0.8
      })
    );
    towerBase.position.y = 12.5;
    
    // Techo rojo tradicional
    let roof = new THREE.Mesh(
      new THREE.BoxGeometry(12, 3, 12),
      new THREE.MeshStandardMaterial({
        color: 0x8B0000,
        roughness: 0.7
      })
    );
    roof.position.y = 26.5;
    
    // S√≠mbolo de Konoha en la torre
    let konohaSymbol = new THREE.Mesh(
      new THREE.BoxGeometry(4, 4, 0.2),
      new THREE.MeshStandardMaterial({
        color: 0xFFD700,
        metalness: 0.8,
        roughness: 0.2
      })
    );
    konohaSymbol.position.set(0, 20, 4.1);
    
    hokageTower.add(towerBase, roof, konohaSymbol);
    hokageTower.position.set(0, 0, -40);
    scene.add(hokageTower);

    // ACADEMIA NINJA COMPLETA
    let ninjaAcademy = new THREE.Group();
    
    // Edificio principal de la academia
    let academyMain = new THREE.Mesh(
      new THREE.BoxGeometry(25, 15, 40),
      new THREE.MeshStandardMaterial({color: 0xDEB887, roughness: 0.8})
    );
    academyMain.position.y = 7.5;
    
    // Techo de la academia
    let academyRoof = new THREE.Mesh(
      new THREE.BoxGeometry(28, 3, 43),
      new THREE.MeshStandardMaterial({color: 0x8B0000, roughness: 0.7})
    );
    academyRoof.position.y = 16.5;
    
    // Aulas (ventanas)
    for(let i = 0; i < 8; i++) {
      let classroom = new THREE.Mesh(
        new THREE.BoxGeometry(4, 3, 0.2),
        new THREE.MeshStandardMaterial({color: 0x87CEEB, transparent: true, opacity: 0.6})
      );
      classroom.position.set(
        -10 + (i % 4) * 6,
        10,
        i < 4 ? 20.1 : -20.1
      );
      ninjaAcademy.add(classroom);
    }
    
    // Campo de entrenamiento
    let trainingField = new THREE.Mesh(
      new THREE.BoxGeometry(50, 0.2, 30),
      new THREE.MeshStandardMaterial({color: 0x8FBC8F, roughness: 0.9})
    );
    trainingField.position.set(0, 0.1, 50);
    
    // Postes de entrenamiento
    for(let i = 0; i < 6; i++) {
      let post = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 6, 0.8),
        new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.9})
      );
      post.position.set(
        -15 + (i % 3) * 15,
        3,
        40 + Math.floor(i / 3) * 20
      );
      ninjaAcademy.add(post);
    }
    
    ninjaAcademy.add(academyMain, academyRoof, trainingField);
    ninjaAcademy.position.set(80, 0, 20);
    scene.add(ninjaAcademy);

    // CASAS RESIDENCIALES DE KONOHA
    for(let i = 0; i < 30; i++) {
      let house = new THREE.Group();
      
      // Base de la casa
      let houseBase = new THREE.Mesh(
        new THREE.BoxGeometry(8, 6, 10),
        new THREE.MeshStandardMaterial({color: 0xD2691E, roughness: 0.8})
      );
      houseBase.position.y = 3;
      
      // Techo
      let houseRoof = new THREE.Mesh(
        new THREE.BoxGeometry(10, 2, 12),
        new THREE.MeshStandardMaterial({color: 0x8B0000, roughness: 0.7})
      );
      houseRoof.position.y = 7;
      
      // Puerta
      let door = new THREE.Mesh(
        new THREE.BoxGeometry(2, 4, 0.2),
        new THREE.MeshStandardMaterial({color: 0x654321, roughness: 0.9})
      );
      door.position.set(0, 2, 5.1);
      
      // Ventanas
      for(let j = 0; j < 2; j++) {
        let window = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 1.5, 0.2),
          new THREE.MeshStandardMaterial({color: 0x87CEEB, transparent: true, opacity: 0.6})
        );
        window.position.set(j === 0 ? -2.5 : 2.5, 4, 5.1);
        house.add(window);
      }
      
      house.add(houseBase, houseRoof, door);
      
      // Distribuci√≥n en calles
      let row = Math.floor(i / 6);
      let col = i % 6;
      house.position.set(
        -60 + col * 20,
        0,
        20 + row * 25
      );
      
      scene.add(house);
    }

    // √ÅRBOLES REALISTAS DEL ANIME DE NARUTO - SIN ESFERAS
    for(let i = 0; i < 200; i++) {
      let tree = new THREE.Group();
      tree.userData.isTree = true;
      
      let treeType = Math.random();
      
      if(treeType < 0.15) {
        // √ÅRBOLES GIGANTES COMO EN EL ANIME
        let trunk = new THREE.Mesh(
          new THREE.BoxGeometry(6, 40, 6),
          new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.9})
        );
        trunk.position.y = 20;
        
        // Copa irregular con bloques
        for(let j = 0; j < 12; j++) {
          let leafBlock = new THREE.Mesh(
            new THREE.BoxGeometry(
              8 + Math.random() * 6,
              6 + Math.random() * 4,
              8 + Math.random() * 6
            ),
            new THREE.MeshStandardMaterial({color: 0x228B22, roughness: 0.8})
          );
          let angle = (j / 12) * Math.PI * 2;
          leafBlock.position.set(
            Math.cos(angle) * (15 + Math.random() * 8),
            35 + Math.random() * 15,
            Math.sin(angle) * (15 + Math.random() * 8)
          );
          tree.add(leafBlock);
        }
        
        tree.add(trunk);
        tree.scale.setScalar(1.2 + Math.random() * 0.5);
        
      } else if(treeType < 0.8) {
        // √ÅRBOLES NORMALES PIXELADOS
        let trunk = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 25, 2.5),
          new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.9})
        );
        trunk.position.y = 12.5;
        
        // Copa con bloques irregulares
        for(let j = 0; j < 8; j++) {
          let leafPart = new THREE.Mesh(
            new THREE.BoxGeometry(
              5 + Math.random() * 4,
              4 + Math.random() * 3,
              5 + Math.random() * 4
            ),
            new THREE.MeshStandardMaterial({color: 0x228B22, roughness: 0.8})
          );
          leafPart.position.set(
            (Math.random() - 0.5) * 12,
            22 + Math.random() * 8,
            (Math.random() - 0.5) * 12
          );
          tree.add(leafPart);
        }
        
        tree.add(trunk);
        tree.scale.setScalar(0.7 + Math.random() * 0.6);
        
      } else {
        // CEREZOS CON FLORES ROSAS
        let trunk = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 18, 1.8),
          new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.9})
        );
        trunk.position.y = 9;
        
        // Flores de cerezo en bloques
        for(let j = 0; j < 15; j++) {
          let blossom = new THREE.Mesh(
            new THREE.BoxGeometry(
              3 + Math.random() * 2,
              2.5 + Math.random(),
              3 + Math.random() * 2
            ),
            new THREE.MeshStandardMaterial({color: 0xFFB6C1, roughness: 0.7})
          );
          let angle = (j / 15) * Math.PI * 2;
          blossom.position.set(
            Math.cos(angle) * (5 + Math.random() * 4),
            15 + Math.random() * 6,
            Math.sin(angle) * (5 + Math.random() * 4)
          );
          tree.add(blossom);
        }
        
        tree.add(trunk);
        tree.scale.setScalar(0.6 + Math.random() * 0.4);
      }
      
      // Distribuci√≥n natural
      let angle = Math.random() * Math.PI * 2;
      let distance = 60 + Math.random() * 350;
      
      tree.position.set(
        Math.cos(angle) * distance,
        0,
        Math.sin(angle) * distance
      );
      
      tree.rotation.y = Math.random() * Math.PI * 2;
      scene.add(tree);
    }
    }
    
    // ALDEAS NINJA DISPERSAS
    for(let village = 0; village < 4; village++) {
      let villageGroup = new THREE.Group();
      villageGroup.userData.isScenery = true;
      
      // Casas ninja
      for(let house = 0; house < 6; house++) {
        let ninjaHouse = new THREE.Group();
        
        // Base de la casa
        let houseBase = new THREE.Mesh(
          new THREE.BoxGeometry(6, 4, 8),
          new THREE.MeshStandardMaterial({
            color: 0xD2691E,
            roughness: 0.8
          })
        );
        houseBase.position.y = 2;
        
        // Techo ninja
        let roof = new THREE.Mesh(
          new THREE.BoxGeometry(8, 2, 10),
          new THREE.MeshStandardMaterial({
            color: 0x8B0000,
            roughness: 0.7
          })
        );
        roof.position.y = 5;
        
        ninjaHouse.add(houseBase, roof);
        ninjaHouse.position.set(
          (house % 3) * 12 - 12,
          0,
          Math.floor(house / 3) * 12 - 6
        );
        villageGroup.add(ninjaHouse);
      }
      
      // Posicionar aldea
      let villageAngle = (village / 4) * Math.PI * 2;
      villageGroup.position.set(
        Math.cos(villageAngle) * 200,
        0,
        Math.sin(villageAngle) * 200
      );
      scene.add(villageGroup);
    }

    // POSTES DE ENTRENAMIENTO NINJA
    for(let i = 0; i < 12; i++) {
      let trainingPost = new THREE.Group();
      trainingPost.userData.isScenery = true;
      
      let post = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 6, 0.8),
        new THREE.MeshStandardMaterial({
          color: 0x8B4513,
          roughness: 0.9
        })
      );
      post.position.y = 3;
      
      // Marcas de kunai en el poste
      for(let j = 0; j < 5; j++) {
        let mark = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.3, 0.1),
          new THREE.MeshStandardMaterial({color: 0x2F4F4F})
        );
        mark.position.set(
          0.45,
          1 + j * 1.2,
          Math.random() * 0.4 - 0.2
        );
        trainingPost.add(mark);
      }
      
      trainingPost.add(post);
      trainingPost.position.set(
        Math.random() * 400 - 200,
        0,
        Math.random() * 400 - 200
      );
      scene.add(trainingPost);
    }

    // Crear rocas dispersas
    for(let i = 0; i < 30; i++) {
      let rock = new THREE.Mesh(
        new THREE.BoxGeometry(
          2 + Math.random() * 3,
          1 + Math.random() * 2,
          2 + Math.random() * 3
        ),
        new THREE.MeshStandardMaterial({
          color: 0x696969,
          roughness: 0.95,
          metalness: 0.05
        })
      );
      rock.userData.isRock = true;
      rock.position.set(
        Math.random() * 160 - 80,
        rock.geometry.parameters.height / 2,
        Math.random() * 160 - 80
      );
      rock.rotation.set(
        Math.random() * 0.3,
        Math.random() * Math.PI * 2,
        Math.random() * 0.3
      );
      scene.add(rock);
    }

    // Crear flores y arbustos peque√±os
    for(let i = 0; i < 100; i++) {
      if(Math.random() < 0.7) {
        // Arbustos
        let bush = new THREE.Mesh(
          new THREE.BoxGeometry(
            1 + Math.random(),
            0.8 + Math.random() * 0.5,
            1 + Math.random()
          ),
          new THREE.MeshStandardMaterial({
            color: 0x228B22,
            roughness: 0.9
          })
        );
        bush.userData.isScenery = true;
        bush.position.set(
          Math.random() * 140 - 70,
          bush.geometry.parameters.height / 2,
          Math.random() * 140 - 70
        );
        scene.add(bush);
      } else {
        // Flores
        let flower = new THREE.Group();
        flower.userData.isScenery = true;

        let stem = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 1, 0.1),
          new THREE.MeshStandardMaterial({color: 0x228B22})
        );
        stem.position.y = 0.5;

        let petal = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.1, 0.4),
          new THREE.MeshStandardMaterial({
            color: Math.random() < 0.5 ? 0xFF69B4 : 0xFFFFFF
          })
        );
        petal.position.y = 1;

        flower.add(stem, petal);
        flower.position.set(
          Math.random() * 120 - 60,
          0,
          Math.random() * 120 - 60
        );
        scene.add(flower);
      }
    }

    // PUENTE NINJA DE MADERA - Como en las misiones
    let ninjaBridge = new THREE.Group();
    ninjaBridge.userData.isScenery = true;
    
    // Tablones del puente
    for(let i = 0; i < 20; i++) {
      let plank = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.3, 8),
        new THREE.MeshStandardMaterial({
          color: 0x8B4513,
          roughness: 0.9
        })
      );
      plank.position.set(i * 2 - 20, 2, 60);
      ninjaBridge.add(plank);
    }
    
    // Barandillas del puente
    for(let side = 0; side < 2; side++) {
      for(let i = 0; i < 10; i++) {
        let rail = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 2, 0.2),
          new THREE.MeshStandardMaterial({color: 0x654321})
        );
        rail.position.set(
          i * 4 - 18,
          3,
          60 + (side ? 3.5 : -3.5)
        );
        ninjaBridge.add(rail);
      }
    }
    scene.add(ninjaBridge);

    // SANTUARIO NINJA - Lugar sagrado
    let ninjaShrine = new THREE.Group();
    ninjaShrine.userData.isScenery = true;
    
    // Base del santuario
    let shrineBase = new THREE.Mesh(
      new THREE.BoxGeometry(6, 1, 6),
      new THREE.MeshStandardMaterial({
        color: 0x696969,
        roughness: 0.8
      })
    );
    shrineBase.position.y = 0.5;
    
    // Estructura principal
    let shrineMain = new THREE.Mesh(
      new THREE.BoxGeometry(4, 4, 4),
      new THREE.MeshStandardMaterial({
        color: 0x8B0000,
        roughness: 0.7
      })
    );
    shrineMain.position.y = 3;
    
    // Techo del santuario
    let shrineRoof = new THREE.Mesh(
      new THREE.BoxGeometry(5, 1, 5),
      new THREE.MeshStandardMaterial({
        color: 0x2F4F4F,
        roughness: 0.8
      })
    );
    shrineRoof.position.y = 5.5;
    
    // Torii (puerta tradicional)
    let torii = new THREE.Group();
    
    // Postes verticales
    for(let i = 0; i < 2; i++) {
      let post = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 6, 0.5),
        new THREE.MeshStandardMaterial({color: 0x8B0000})
      );
      post.position.set(i ? 3 : -3, 3, -8);
      torii.add(post);
    }
    
    // Viga horizontal superior
    let beam = new THREE.Mesh(
      new THREE.BoxGeometry(8, 0.8, 0.8),
      new THREE.MeshStandardMaterial({color: 0x8B0000})
    );
    beam.position.set(0, 6, -8);
    torii.add(beam);
    
    ninjaShrine.add(shrineBase, shrineMain, shrineRoof, torii);
    ninjaShrine.position.set(-60, 0, -20);
    scene.add(ninjaShrine);

    // CAMPO DE ENTRENAMIENTO CON DIANAS
    for(let i = 0; i < 8; i++) {
      let target = new THREE.Group();
      target.userData.isScenery = true;
      
      // Poste de la diana
      let targetPost = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 4, 0.3),
        new THREE.MeshStandardMaterial({color: 0x8B4513})
      );
      targetPost.position.y = 2;
      
      // Diana circular
      let targetBoard = new THREE.Mesh(
        new THREE.RingGeometry(0.5, 1.5, 16),
        new THREE.MeshStandardMaterial({
          color: i % 2 ? 0xFF0000 : 0xFFFFFF,
          side: THREE.DoubleSide
        })
      );
      targetBoard.position.y = 3;
      targetBoard.rotation.y = Math.PI;
      
      target.add(targetPost, targetBoard);
      target.position.set(
        Math.cos(i * Math.PI / 4) * 25,
        0,
        Math.sin(i * Math.PI / 4) * 25 + 30
      );
      scene.add(target);
    }

    // Animar la cascada
    let waterfallAnimation = () => {
      waterfall.children.forEach((child, index) => {
        if(child.geometry && child.geometry.parameters.height > 40) {
          child.position.y = 5 + Math.sin(Date.now() * 0.003 + index) * 2;
          child.material.opacity = 0.5 + Math.sin(Date.now() * 0.004 + index) * 0.2;
        }
      });
      requestAnimationFrame(waterfallAnimation);
    };
    waterfallAnimation();

    console.log('üå≤ Bosque de Konoha creado con monta√±as, cascada y vegetaci√≥n detallada');
  }

  function addRainEffect() {
    const rainCount = 1000;
    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = [];

    for(let i = 0; i < rainCount; i++) {
      rainPositions.push(
        Math.random() * 200 - 100,
        Math.random() * 50,
        Math.random() * 200 - 100
      );
    }

    rainGeometry.setAttribute('position', 
      new THREE.Float32BufferAttribute(rainPositions, 3)
    );

    const rainMaterial = new THREE.PointsMaterial({
      color: 0x99ccff,
      size: 0.1,
      transparent: true,
      opacity: 0.6
    });

    const rain = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rain);

    // Animaci√≥n de lluvia
    function animateRain() {
      const positions = rain.geometry.attributes.position.array;
      for(let i = 0; i < positions.length; i += 3) {
        positions[i + 1] -= 0.5;
        if(positions[i + 1] < 0) positions[i + 1] = 50;
      }
      rain.geometry.attributes.position.needsUpdate = true;
      requestAnimationFrame(animateRain);
    }
    animateRain();
  }

  function init(){
    scene=new THREE.Scene();
    scene.background = new THREE.Color(0x000033);
    scene.fog = new THREE.FogExp2(0x000033, 0.02);
    camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,500);

    // MUNDO ABIERTO SIN PAREDES - EXPANDIDO
    // Crear niebla para l√≠mites naturales
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.001);

    camera.position.set(0,5,10);
    renderer=new THREE.WebGLRenderer({antialias:false});
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);

    // luces
    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));
    let dl=new THREE.DirectionalLight(0xffffff,0.8);
    dl.position.set(5,10,7); scene.add(dl);

    // SUELO EXPANDIDO - MUNDO GIGANTE
    floor=new THREE.Mesh(
      new THREE.PlaneGeometry(1000,1000),
      new THREE.MeshStandardMaterial({color:0x228B22})
    ); floor.rotation.x=-Math.PI/2; scene.add(floor);
    
    // Terreno adicional con texturas variadas
    for(let i = 0; i < 9; i++) {
      let terrain = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 500),
        new THREE.MeshStandardMaterial({
          color: i % 3 === 0 ? 0x228B22 : (i % 3 === 1 ? 0x8FBC8F : 0x9ACD32)
        })
      );
      terrain.rotation.x = -Math.PI/2;
      terrain.position.set(
        (i % 3 - 1) * 500,
        -0.1,
        (Math.floor(i/3) - 1) * 500
      );
      scene.add(terrain);
    }

    // HIERBA EXPANDIDA POR TODO EL MUNDO
    for(let i=0;i<2000;i++){
      let grass=new THREE.Mesh(
        new THREE.BoxGeometry(0.04,0.6,0.04),
        new THREE.MeshStandardMaterial({color:0x00aa00})
      );
      grass.position.set(Math.random()*900-450,0.3,Math.random()*900-450);
      grass.rotation.z=(Math.random()-0.5)*0.5;
      scene.add(grass);
    }

    // Crear modelo espec√≠fico seg√∫n el personaje seleccionado
    function createCharacterModel(characterType) {
      let characterGroup = new THREE.Group();

      if(characterType === 'neji') {
        // Cuerpo de Neji con ropa t√≠pica de Konoha
        let body = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.5, 0.8),
          new THREE.MeshStandardMaterial({
            color: 0xF5F5DC, // Beige claro para la ropa
            roughness: 0.8,
            metalness: 0.1
          })
        );

        // Chaleco verde de Konoha
        let vest = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 1.8, 0.85),
          new THREE.MeshStandardMaterial({
            color: 0x228B22, // Verde Konoha
            roughness: 0.9
          })
        );
        vest.position.y = 0.3;

        // Cabeza con tono de piel realista
        let head = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({
            color: 0xFFDBB3, // Tono de piel
            roughness: 0.6
          })
        );
        head.position.y = 1.8;

        // CABELLO LARGO DE NEJI - Mejorado para ser m√°s fiel al personaje
        // Cabello principal largo hasta los hombros
        let hairMain = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.2, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423, // Marr√≥n m√°s claro y realista
            roughness: 0.7
          })
        );
        hairMain.position.set(0, 2.1, 0);

        // Cabello trasero largo hasta la cintura - MECH√ìN PRINCIPAL
        let hairBack = new THREE.Mesh(
          new THREE.BoxGeometry(1.0, 3.5, 0.4),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423, // Mismo tono
            roughness: 0.7
          })
        );
        hairBack.position.set(0, 1.0, -0.6);

        // MECH√ìN TRASERO EXTRA LARGO caracter√≠stico de Neji
        let hairBackLong = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 4.2, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairBackLong.position.set(0, 0.5, -0.8); // M√°s atr√°s y m√°s largo

        // Mech√≥n trasero que llega hasta la espalda baja
        let hairTail = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 2.8, 0.2),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairTail.position.set(0, -0.8, -0.9); // Llega hasta la espalda baja

        // Mechones laterales largos caracter√≠sticos
        let hairLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 2.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairLeft.position.set(-0.65, 1.2, 0.2);

        let hairRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 2.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairRight.position.set(0.65, 1.2, 0.2);

        // Flequillo dividido caracter√≠stico de Neji
        let hairFrontLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairFrontLeft.position.set(-0.3, 2.3, 0.5);

        let hairFrontRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6B4423,
            roughness: 0.7
          })
        );
        hairFrontRight.position.set(0.3, 2.3, 0.5);

        // Brazos con guantes ninja
        let leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xF5F5DC})
        );
        let rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xF5F5DC})
        );
        leftArm.position.set(-0.8, 0.5, 0);
        rightArm.position.set(0.8, 0.5, 0);

        // Guantes ninja pixelados
        let leftGlove = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.6, 0.45),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        let rightGlove = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.6, 0.45),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        leftGlove.position.set(-0.8, -0.2, 0);
        rightGlove.position.set(0.8, -0.2, 0);

        // Piernas con pantalones ninja
        let leftLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F}) // Verde oscuro
        );
        let rightLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0x2F4F2F})
        );
        leftLeg.position.set(-0.4, -0.8, 0);
        rightLeg.position.set(0.4, -0.8, 0);

        // Sandalias ninja pixeladas
        let leftSandal = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.3, 0.8),
          new THREE.MeshStandardMaterial({color: 0x000080}) // Azul oscuro
        );
        let rightSandal = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.3, 0.8),
          new THREE.MeshStandardMaterial({color: 0x000080})
        );
        leftSandal.position.set(-0.4, -1.9, 0.1);
        rightSandal.position.set(0.4, -1.9, 0.1);

        // Banda ninja en la frente
        let headband = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.3, 0.2),
          new THREE.MeshStandardMaterial({
            color: 0x000080, // Azul Konoha
            metalness: 0.6,
            roughness: 0.3
          })
        );
        headband.position.set(0, 2.3, 0.4);

        // S√≠mbolo de Konoha en la banda
        let konohaSymbol = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.2, 0.05),
          new THREE.MeshStandardMaterial({
            color: 0xFFD700, // Dorado
            metalness: 0.8,
            roughness: 0.2
          })
        );
        konohaSymbol.position.set(0, 2.3, 0.5);

        // Efectos especiales para Byakugan
        let byakuganAura = new THREE.Mesh(
          new THREE.SphereGeometry(2.5, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.1,
            side: THREE.DoubleSide
          })
        );
        byakuganAura.visible = false; // Solo visible cuando se activa Byakugan

        characterGroup.add(
          body, vest, head, hairMain, hairBack, hairBackLong, hairTail, hairLeft, hairRight, 
          hairFrontLeft, hairFrontRight,
          leftArm, rightArm, leftGlove, rightGlove,
          leftLeg, rightLeg, leftSandal, rightSandal,
          headband, konohaSymbol, byakuganAura
        );

        // Guardar referencias para animaciones
        characterGroup.userData.byakuganAura = byakuganAura;
        characterGroup.userData.body = body;
        characterGroup.userData.head = head;
        characterGroup.userData.leftArm = leftArm;
        characterGroup.userData.rightArm = rightArm;
        characterGroup.userData.leftLeg = leftLeg;
        characterGroup.userData.rightLeg = rightLeg;

      } else {
        // Modelo gen√©rico para otros personajes
        let body = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 2.5, 0.8),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let head = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({color: 0xdddddd})
        );
        head.position.y = 1.8;

        let leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 1.5, 0.4),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        leftArm.position.set(-0.8, 0.5, 0);
        rightArm.position.set(0.8, 0.5, 0);

        let leftLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        let rightLeg = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 2, 0.5),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        leftLeg.position.set(-0.4, -0.8, 0);
        rightLeg.position.set(0.4, -0.8, 0);

        characterGroup.add(body, head, leftArm, rightArm, leftLeg, rightLeg);
      }

      return characterGroup;
    }

    // Crear el modelo del personaje seg√∫n el tipo seleccionado
    player = createCharacterModel(currentCharacter);
    player.position.set(0,1.25,0); scene.add(player);

    // Crear mundo de Konoha
    scene.background = new THREE.Color(0x87CEEB);
    createKonohaForest();
    
    // enemigos iniciales
    for(let i=0;i<WORLD_CONFIG.maxEnemies;i++) addEnemy();
    
    // Sistema de respawn continuo
    setInterval(respawnEnemies, WORLD_CONFIG.respawnTime);

    // JOYSTICK M√ìVIL MEJORADO
    const joy=document.getElementById('joystick'),
          thumb=document.getElementById('joy-thumb');
    let origin={x:0,y:0}, tracking=false;
    
    // Eventos t√°ctiles
    joy.addEventListener('touchstart',e=>{
      e.preventDefault();
      let t=e.touches[0];
      const rect=joy.getBoundingClientRect();
      origin={x:rect.left+rect.width/2,y:rect.top+rect.height/2};
      tracking=true;
    });
    
    joy.addEventListener('touchmove',e=>{
      e.preventDefault();
      if(!tracking) return;
      let t=e.touches[0],
          dx=t.clientX-origin.x,
          dy=t.clientY-origin.y,
          dist=Math.hypot(dx,dy),
          max=40;
      if(dist>max){ dx*=max/dist; dy*=max/dist; }
      thumb.style.transform=`translate(${dx}px,${dy}px)`;
      moveDir.x=dx/max*playerSpeed; 
      moveDir.z=dy/max*playerSpeed;
    });
    
    joy.addEventListener('touchend',e=>{
      e.preventDefault();
      tracking=false;
      thumb.style.transform='translate(0,0)';
      moveDir={x:0,z:0};
    });
    
    // Eventos de mouse para PC
    joy.addEventListener('mousedown',e=>{
      const rect=joy.getBoundingClientRect();
      origin={x:rect.left+rect.width/2,y:rect.top+rect.height/2};
      tracking=true;
    });
    
    joy.addEventListener('mousemove',e=>{
      if(!tracking) return;
      let dx=e.clientX-origin.x,
          dy=e.clientY-origin.y,
          dist=Math.hypot(dx,dy),
          max=40;
      if(dist>max){ dx*=max/dist; dy*=max/dist; }
      thumb.style.transform=`translate(${dx}px,${dy}px)`;
      moveDir.x=dx/max*playerSpeed;
      moveDir.z=dy/max*playerSpeed;
    });
    
    joy.addEventListener('mouseup',()=>{
      tracking=false;
      thumb.style.transform='translate(0,0)';
      moveDir={x:0,z:0};
    });

    // BOTONES M√ìVILES MEJORADOS
    const jumpBtn = document.getElementById('jump');
    
    // Eventos t√°ctiles mejorados
    jumpBtn.addEventListener('touchstart', e => {
      e.preventDefault();
      if(onGround) {
        velY = 0.6;
        onGround = false;
        console.log('Salto t√°ctil activado!');
      }
    });
    
    // Eventos de mouse para PC mejorados
    jumpBtn.addEventListener('mousedown', e => {
      e.preventDefault();
      if(onGround) {
        velY = 0.6;
        onGround = false;
        console.log('Salto con mouse activado!');
      }
    });
    
    // Tambi√©n agregar evento click para mayor compatibilidad
    jumpBtn.addEventListener('click', e => {
      e.preventDefault();
      if(onGround) {
        velY = 0.6;
        onGround = false;
        console.log('Salto con click activado!');
      }
    });
    
    // Hacer botones m√°s grandes en m√≥vil
    if(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      document.querySelectorAll('.action-btn').forEach(btn => {
        btn.style.width = '60px';
        btn.style.height = '60px';
        btn.style.fontSize = '10px';
        btn.style.lineHeight = '60px';
      });
      
      // Joystick m√°s grande en m√≥vil
      joy.style.width = '120px';
      joy.style.height = '120px';
      thumb.style.width = '50px';
      thumb.style.height = '50px';
      thumb.style.top = '35px';
      thumb.style.left = '35px';
    }

    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  }

  function addEnemy(){
    let g=new THREE.Group();
    // Cuerpo pixelado
    let b=new THREE.Mesh(
      new THREE.BoxGeometry(1,1.5,1),
      new THREE.MeshStandardMaterial({
        color:0xAA0000,
        roughness: 0.8,
        metalness: 0.5
      })
    );

    g.userData = {
      hp: WORLD_CONFIG.enemyHealth,
      id: THREE.MathUtils.generateUUID()
    };
    // Cabeza pixelada
    let h=new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({
        color:0xFF4444,
        emissive: 0xFF0000,
        emissiveIntensity: 0.5
      })
    );
    h.position.y=1.25;

    // Garras pixeladas
    let clawGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.1);
    for(let i = 0; i < 3; i++) {
      let claw = new THREE.Mesh(clawGeometry, new THREE.MeshStandardMaterial({color: 0x660000}));
      claw.position.set(0.3 * (i-1), 0, 0.6);
      b.add(claw);
    }
    g.add(b,h);

    // Efecto de distorsi√≥n en Tsukuyomi
    g.userData.originalScale = g.scale.clone();
    g.userData.tsukuyomiActive = false;
    g.position.set(Math.random()*40-20,0.75,Math.random()*40-20);
    g.userData={hp:200,id:THREE.MathUtils.generateUUID()};
    scene.add(g); enemies.push(g);
    // HUD
    let container=document.createElement('div');
    document.body.appendChild(container);
    enemyHUD[g.userData.id]=container;
  }

  

function animate(){
    requestAnimationFrame(animate);

    // Detener todo si el juego termin√≥
    if(gameOver) {
      renderer.render(scene,camera);
      return;
    }

    // Actualizar movimiento con teclado para PC
    updateKeyboardMovement();

    // Animaci√≥n de brazos y piernas al moverse - MEJORADA
    if(moveDir.x !== 0 || moveDir.z !== 0) {
      let time = Date.now() * 0.002; // Velocidad m√°s lenta para animaci√≥n m√°s natural

      // Usar referencias espec√≠ficas para animaciones m√°s precisas
      if(player.userData.leftArm) {
        player.userData.leftArm.rotation.x = Math.sin(time * 4) * 0.3; // Movimiento m√°s sutil
      }
      if(player.userData.rightArm) {
        player.userData.rightArm.rotation.x = Math.sin(time * 4 + Math.PI) * 0.3;
      }
      if(player.userData.leftLeg) {
        player.userData.leftLeg.rotation.x = Math.sin(time * 4 + Math.PI) * 0.4;
      }
      if(player.userData.rightLeg) {
        player.userData.rightLeg.rotation.x = Math.sin(time * 4) * 0.4;
      }

      // Balanceo sutil del cuerpo
      if(player.userData.body) {
        player.userData.body.rotation.z = Math.sin(time * 2) * 0.05;
      }
    } else {
      // Resetear posiciones cuando no se mueve
      if(player.userData.leftArm) player.userData.leftArm.rotation.x = 0;
      if(player.userData.rightArm) player.userData.rightArm.rotation.x = 0;
      if(player.userData.leftLeg) player.userData.leftLeg.rotation.x = 0;
      if(player.userData.rightLeg) player.userData.rightLeg.rotation.x = 0;
      if(player.userData.body) player.userData.body.rotation.z = 0;
    }
    // movimiento + salto + colisiones con paredes (ahora relativo a la c√°mara)
    updateMovementDirection();

    // Sistema de f√≠sica mejorado
    velY += GRAV;
    player.position.y += velY;
    
    // Detecci√≥n del suelo mejorada
    const GROUND_LEVEL = 1.25;
    if(player.position.y <= GROUND_LEVEL) {
      player.position.y = GROUND_LEVEL;
      velY = 0;
      if(!onGround) {
        onGround = true;
      }
    } else {
      onGround = false;
    }
    
    // Actualizar indicador de salto
    const jumpIndicator = document.getElementById('jump-indicator');
    if(jumpIndicator) {
      jumpIndicator.textContent = onGround ? 'SUELO: S√ç' : 'AIRE: VOLANDO';
      jumpIndicator.style.color = onGround ? '#00FF00' : '#FF4500';
    }
    // C√°mara libre 360¬∞ tipo Roblox
    updateFreeCamera();
    // poderes y colisiones (como antes)...
    powers.forEach((p,i)=>{
      p.mesh.position.add(p.vel);
      p.life--;
      enemies.forEach(e=>{
        if(p.life>0 && p.mesh.position.distanceTo(e.position)<1.2){
          e.userData.hp-=p.damage; p.life=0; flash(e.position);
          // Reproducir sonido de impacto cuando el poder golpea al enemigo
          playImpactSound();
        }
      });
      if(p.life<=0){ scene.remove(p.mesh); powers.splice(i,1); }
    });
    // IA enemigos + HUD + muerte + da√±o al jugador
    enemies.forEach((e,i)=>{
      let dir=player.position.clone().sub(e.position).setY(0).normalize().multiplyScalar(0.005);
      e.position.add(dir);

      // Actualizar barra de vida del enemigo
      let container = enemyHUD[e.userData.id],
          vp=e.position.clone().project(camera),
          x=(vp.x*0.5+0.5)*innerWidth,
          y=(-vp.y*0.5+0.5)*innerHeight - 50;
      container.innerHTML = '';
      container.className = 'enemy-hearts';
      container.style.transform = `translate(${x}px,${y}px)`;
      for(let i = 0; i < WORLD_CONFIG.enemyHealth; i++) {
        const heart = document.createElement('div');
        heart.className = `enemy-heart ${i >= e.userData.hp ? 'heart-empty' : ''}`;
        container.appendChild(heart);
      }

      // Da√±o al jugador cuando est√° cerca - SOLO si no est√° muerto
      if(!gameOver && e.position.distanceTo(player.position) < 2) {
        playerHealth -= 1; // Quitar 1 vida por golpe
        // Reproducir sonido de impacto cuando el enemigo golpea al jugador
        playImpactSound();

        // Efecto visual de da√±o
        let dmgFlash = document.createElement('div');
        dmgFlash.style.cssText = `
          position:fixed;top:0;left:0;width:100%;height:100%;
          background:rgba(255,0,0,0.3);pointer-events:none;
          animation:flash 0.5s forwards;
        `;
        document.body.appendChild(dmgFlash);
        setTimeout(() => dmgFlash.remove(), 500);

        updatePlayerHUD();
        if(playerHealth <= 0) {
          gameOver = true; // Marcar que el juego termin√≥
          showGameOverScreen();
        }
      }

      if(e.userData.hp<=0){
        scene.remove(e); container.remove();
        enemies.splice(i,1); delete enemyHUD[e.userData.id];

        // Respawn autom√°tico despu√©s de un tiempo
        setTimeout(() => {
          if(enemies.length < WORLD_CONFIG.maxEnemies) {
            addEnemy();
          }
        }, WORLD_CONFIG.respawnTime);
      }
    });
    renderer.render(scene,camera);
  }

  function flash(pos){
    let m=new THREE.Mesh(
      new THREE.BoxGeometry(1,1,1),
      new THREE.MeshBasicMaterial({color:0xffff00})
    );
    m.position.copy(pos); scene.add(m);
    setTimeout(()=>scene.remove(m),200);
  }

  // Funci√≥n para reproducir sonido de poder a distancia
  function playProjectileSound() {
    let projectileSound = document.createElement('video');
    projectileSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    projectileSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-975843560396402730.mp4?updatedAt=1748455137385';
    projectileSound.autoplay = true;
    projectileSound.muted = false;
    projectileSound.volume = 0.7;
    projectileSound.preload = 'auto';

    document.body.appendChild(projectileSound);

    projectileSound.play().catch(e => {
      console.log('Projectile sound autoplay error:', e);
      projectileSound.muted = true;
      projectileSound.play().then(() => {
        projectileSound.muted = false;
      });
    });

    // Remover despu√©s de 2 segundos
    setTimeout(() => {
      projectileSound.remove();
    }, 2000);
  }

  // Funci√≥n para reproducir sonido de impacto/golpe
  function playImpactSound() {
    let impactSound = document.createElement('video');
    impactSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    impactSound.src = 'https://ik.imagekit.io/lcpvlmgbf/copy_21E0A2DA-745D-4447-B493-140B9050A5A2.mov/ik-video.mp4?updatedAt=1748454860763';
    impactSound.autoplay = true;
    impactSound.muted = false;
    impactSound.volume = 0.8;
    impactSound.preload = 'auto';

    document.body.appendChild(impactSound);

    impactSound.play().catch(e => {
      console.log('Impact sound autoplay error:', e);
      impactSound.muted = true;
      impactSound.play().then(() => {
        impactSound.muted = false;
      });
    });

    // Remover despu√©s de 1.5 segundos
    setTimeout(() => {
      impactSound.remove();
    }, 1500);
  }

  // ‚îÄ‚îÄ‚îÄ T√âCNICAS ‚îÄ‚îÄ‚îÄ

  function activateByakugan(){
    // ANIMACI√ìN √âPICA DE BYAKUGAN
    animateCharacterPower('byakugan');
    
    // Pausar YouTube mientras suena el Byakugan
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Byakugan mejorado con video HTML5
    let byakuganSound = document.createElement('video');
    byakuganSound.id = 'byakugan-sound';
    byakuganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    byakuganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-4196672225765940788.mp4?updatedAt=1748454278148';
    byakuganSound.autoplay = true;
    byakuganSound.muted = false;
    byakuganSound.volume = 1.0;
    byakuganSound.preload = 'auto';

    // Forzar reproducci√≥n inmediata
    document.body.appendChild(byakuganSound);

    byakuganSound.play().then(() => {
      console.log('Byakugan sound playing!');
    }).catch(e => {
      console.log('Byakugan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      byakuganSound.muted = true;
      byakuganSound.play().then(() => {
        byakuganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      byakuganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Byakugan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 3000);

    // EFECTO √âPICO DE BYAKUGAN - COMO EN LA SERIE ORIGINAL
    // Crear efecto de ondas de chakra expandi√©ndose
    let chakraWaves = [];
    for(let i = 0; i < 5; i++) {
      let wave = new THREE.Mesh(
        new THREE.RingGeometry(0.5, 1, 16),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        })
      );
      wave.rotation.x = -Math.PI/2;
      wave.position.copy(player.position);
      wave.position.y += 0.1;
      scene.add(wave);
      chakraWaves.push(wave);
    }

    // Animaci√≥n de ondas expandi√©ndose
    let waveTime = 0;
    let waveInterval = setInterval(() => {
      waveTime += 0.1;
      chakraWaves.forEach((wave, index) => {
        let scale = 1 + (waveTime - index * 0.3) * 3;
        if(scale > 0) {
          wave.scale.setScalar(scale);
          wave.material.opacity = Math.max(0, 0.8 - (scale - 1) * 0.2);
        }
      });

      if(waveTime > 3) {
        clearInterval(waveInterval);
        chakraWaves.forEach(wave => scene.remove(wave));
      }
    }, 50);

    // Activar aura de Byakugan en Neji con efectos mejorados
    if(player.userData.byakuganAura) {
      player.userData.byakuganAura.visible = true;
      let pulseTime = 0;
      let pulseInterval = setInterval(() => {
        pulseTime += 0.1;
        player.userData.byakuganAura.material.opacity = 0.2 + Math.sin(pulseTime * 6) * 0.3;
        player.userData.byakuganAura.scale.setScalar(1.2 + Math.sin(pulseTime * 4) * 0.3);
      }, 50);

      setTimeout(() => {
        clearInterval(pulseInterval);
        player.userData.byakuganAura.visible = false;
      }, 8000);
    }

    // EFECTO VISUAL √âPICO - VENAS BYAKUGAN
    let byakuganOverlay = document.createElement('div');
    byakuganOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 50% 50%, rgba(255,255,255,0.6) 10%, transparent 40%),
        repeating-linear-gradient(45deg,
          rgba(255,255,255,0.4) 0px, rgba(255,255,255,0.4) 2px,
          transparent 2px, transparent 6px),
        repeating-linear-gradient(-45deg,
          rgba(200,200,255,0.3) 0px, rgba(200,200,255,0.3) 1px,
          transparent 1px, transparent 3px),
        repeating-linear-gradient(0deg,
          rgba(255,255,255,0.2) 0px, rgba(255,255,255,0.2) 1px,
          transparent 1px, transparent 8px),
        repeating-linear-gradient(90deg,
          rgba(255,255,255,0.2) 0px, rgba(255,255,255,0.2) 1px,
          transparent 1px, transparent 8px);
      pointer-events: none;
      animation: byakuganVeins 2s steps(8) infinite;
      box-shadow: 
        inset 0 0 200px rgba(255,255,255,0.4),
        inset 0 0 100px rgba(200,200,255,0.3);
      z-index: 1000;
    `;

    // A√±adir estilos de animaci√≥n para las venas
    let byakuganStyles = document.createElement('style');
    byakuganStyles.textContent = `
      @keyframes byakuganVeins {
        0% { 
          background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
          filter: hue-rotate(0deg) brightness(100%);
        }
        25% { 
          background-position: 4px 4px, -4px 4px, 0 2px, 2px 0, 0 2px;
          filter: hue-rotate(10deg) brightness(120%);
        }
        50% { 
          background-position: 8px 8px, -8px 8px, 0 4px, 4px 0, 0 4px;
          filter: hue-rotate(20deg) brightness(140%);
        }
        75% { 
          background-position: 4px 4px, -4px 4px, 0 2px, 2px 0, 0 2px;
          filter: hue-rotate(10deg) brightness(120%);
        }
        100% { 
          background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
          filter: hue-rotate(0deg) brightness(100%);
        }
      }
    `;
    document.head.appendChild(byakuganStyles);
    document.body.appendChild(byakuganOverlay);

    setTimeout(() => {
      byakuganOverlay.remove();
      byakuganStyles.remove();
    }, 8000);

    // DETECCI√ìN DE ENEMIGOS √âPICA - COMO EN LA SERIE
    enemies.forEach((e, index) => {
      // Crear sistema de chakra visible alrededor del enemigo
      let chakraSystem = new THREE.Group();
      
      // Puntos de chakra principales (como en la serie)
      let chakraPoints = [
        {pos: [0, 1.8, 0], size: 0.3, color: 0x00FFFF}, // Cabeza
        {pos: [0, 1.2, 0], size: 0.25, color: 0x0080FF}, // Coraz√≥n
        {pos: [0, 0.8, 0], size: 0.2, color: 0x4080FF}, // Est√≥mago
        {pos: [-0.6, 1.2, 0], size: 0.15, color: 0x8080FF}, // Brazo izq
        {pos: [0.6, 1.2, 0], size: 0.15, color: 0x8080FF}, // Brazo der
        {pos: [-0.3, 0.2, 0], size: 0.15, color: 0x8080FF}, // Pierna izq
        {pos: [0.3, 0.2, 0], size: 0.15, color: 0x8080FF}  // Pierna der
      ];

      chakraPoints.forEach((point, i) => {
        let chakraPoint = new THREE.Mesh(
          new THREE.SphereGeometry(point.size, 8, 8),
          new THREE.MeshBasicMaterial({
            color: point.color,
            transparent: true,
            opacity: 0.8
          })
        );
        chakraPoint.position.set(...point.pos);
        chakraSystem.add(chakraPoint);

        // L√≠neas de chakra conectando los puntos
        if(i > 0) {
          let lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(...chakraPoints[0].pos),
            new THREE.Vector3(...point.pos)
          ]);
          let line = new THREE.Line(
            lineGeometry,
            new THREE.LineBasicMaterial({
              color: 0x00FFFF,
              transparent: true,
              opacity: 0.6
            })
          );
          chakraSystem.add(line);
        }
      });

      chakraSystem.position.copy(e.position);
      scene.add(chakraSystem);

      // Animaci√≥n del sistema de chakra
      let chakraTime = 0;
      let chakraInterval = setInterval(() => {
        chakraTime += 0.1;
        chakraSystem.children.forEach((child, i) => {
          if(child.geometry && child.geometry.type === 'SphereGeometry') {
            child.scale.setScalar(1 + Math.sin(chakraTime * 4 + i) * 0.3);
            child.material.opacity = 0.6 + Math.sin(chakraTime * 6 + i) * 0.4;
          }
        });
        chakraSystem.rotation.y += 0.02;
      }, 50);

      // Aura de detecci√≥n expandi√©ndose
      let detectionAura = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 16, 16),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.3,
          wireframe: true
        })
      );
      detectionAura.position.copy(e.position);
      scene.add(detectionAura);

      let auraScale = 0.5;
      let auraInterval = setInterval(() => {
        auraScale += 0.1;
        detectionAura.scale.setScalar(auraScale);
        detectionAura.material.opacity = Math.max(0, 0.5 - auraScale * 0.1);
      }, 50);

      setTimeout(() => {
        clearInterval(chakraInterval);
        clearInterval(auraInterval);
        scene.remove(chakraSystem);
        scene.remove(detectionAura);
      }, 8000);
    });

    // Aumentar temporalmente la percepci√≥n y velocidad
    let originalSpeed = playerSpeed;
    playerSpeed *= 1.8;
    
    setTimeout(() => {
      playerSpeed = originalSpeed;
    }, 8000);
  }

  function activateJuken(){
    // ANIMACI√ìN √âPICA DE JUKEN
    animateCharacterPower('juken');
    
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    // JUKEN √âPICO - GOLPE SUAVE CON EFECTOS VISUALES ESPECTACULARES
    
    // Crear aura de chakra en las manos
    let rightHandAura = new THREE.Group();
    let leftHandAura = new THREE.Group();

    // Efectos de chakra en las palmas
    for(let i = 0; i < 3; i++) {
      let chakraOrb = new THREE.Mesh(
        new THREE.SphereGeometry(0.2 + i * 0.1, 8, 8),
        new THREE.MeshBasicMaterial({
          color: i === 0 ? 0x00FFFF : (i === 1 ? 0x4080FF : 0x8080FF),
          transparent: true,
          opacity: 0.7 - i * 0.2
        })
      );
      rightHandAura.add(chakraOrb);
      
      let chakraOrb2 = chakraOrb.clone();
      leftHandAura.add(chakraOrb2);
    }

    // Posicionar auras en las manos
    rightHandAura.position.copy(player.position).add(new THREE.Vector3(0.8, 1.5, 0.3));
    leftHandAura.position.copy(player.position).add(new THREE.Vector3(-0.8, 1.5, 0.3));
    scene.add(rightHandAura);
    scene.add(leftHandAura);

    // Animaci√≥n de las auras
    let auraTime = 0;
    let auraInterval = setInterval(() => {
      auraTime += 0.2;
      [rightHandAura, leftHandAura].forEach(aura => {
        aura.children.forEach((orb, i) => {
          orb.scale.setScalar(1 + Math.sin(auraTime * 4 + i) * 0.4);
          orb.rotation.x += 0.1;
          orb.rotation.y += 0.15;
        });
      });
    }, 50);

    // Crear proyectil de Juken con efectos mejorados
    let jukenStrike = new THREE.Group();
    
    // N√∫cleo del golpe
    let core = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 12, 12),
      new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.9
      })
    );
    jukenStrike.add(core);

    // Anillos de chakra giratorios
    for(let i = 0; i < 4; i++) {
      let ring = new THREE.Mesh(
        new THREE.RingGeometry(0.6 + i * 0.2, 0.8 + i * 0.2, 16),
        new THREE.MeshBasicMaterial({
          color: 0x4080FF,
          transparent: true,
          opacity: 0.6 - i * 0.1,
          side: THREE.DoubleSide
        })
      );
      ring.rotation.x = Math.random() * Math.PI;
      ring.rotation.y = Math.random() * Math.PI;
      jukenStrike.add(ring);
    }

    // Espirales de energ√≠a
    for(let i = 0; i < 8; i++) {
      let spiral = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 1.5),
        new THREE.MeshBasicMaterial({
          color: 0x80FFFF,
          transparent: true,
          opacity: 0.8
        })
      );
      spiral.position.set(
        Math.cos(i * Math.PI / 4) * 0.8,
        Math.sin(i * Math.PI / 4) * 0.8,
        0
      );
      spiral.lookAt(new THREE.Vector3(0, 0, 1));
      jukenStrike.add(spiral);
    }

    jukenStrike.position.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));
    scene.add(jukenStrike);

    // Animaci√≥n del proyectil
    let strikeTime = 0;
    let strikeInterval = setInterval(() => {
      strikeTime += 0.3;
      
      // Rotar anillos
      jukenStrike.children.forEach((child, i) => {
        if(child.geometry && child.geometry.type === 'RingGeometry') {
          child.rotation.z += 0.2 * (i % 2 ? 1 : -1);
        }
        if(child.geometry && child.geometry.type === 'BoxGeometry') {
          child.rotation.z += 0.3;
        }
      });

      // Pulso del n√∫cleo
      core.scale.setScalar(1 + Math.sin(strikeTime * 8) * 0.3);
    }, 50);

    // A√±adir a poderes con efectos mejorados
    powers.push({
      mesh: jukenStrike,
      vel: new THREE.Vector3(0, 0, -1.2),
      life: 50,
      damage: 75,
      onHit: (enemy) => {
        // Efecto especial al impactar
        let impactEffect = new THREE.Group();
        
        // Explosi√≥n de chakra
        for(let i = 0; i < 12; i++) {
          let fragment = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshBasicMaterial({
              color: 0x00FFFF,
              transparent: true,
              opacity: 0.8
            })
          );
          fragment.position.copy(enemy.position);
          fragment.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            Math.random() * 2,
            (Math.random() - 0.5) * 2
          );
          impactEffect.add(fragment);
        }
        
        scene.add(impactEffect);
        
        // Animar fragmentos
        let fragmentTime = 0;
        let fragmentInterval = setInterval(() => {
          fragmentTime += 0.1;
          impactEffect.children.forEach(fragment => {
            fragment.position.add(fragment.velocity.clone().multiplyScalar(0.1));
            fragment.velocity.y -= 0.02; // Gravedad
            fragment.material.opacity -= 0.05;
            fragment.rotation.x += 0.2;
            fragment.rotation.y += 0.2;
          });
          
          if(fragmentTime > 2) {
            clearInterval(fragmentInterval);
            scene.remove(impactEffect);
          }
        }, 50);
      }
    });

    // Limpiar efectos despu√©s de un tiempo
    setTimeout(() => {
      clearInterval(auraInterval);
      clearInterval(strikeInterval);
      scene.remove(rightHandAura);
      scene.remove(leftHandAura);
    }, 3000);
  }

  function activate64Palms(){
    // ANIMACI√ìN √âPICA DE 64 PALMAS
    animateCharacterPower('64palms');
    
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    // HAKKE ROKUJ≈™YONSH≈å - 64 PALMAS √âPICAS
    
    // Crear c√≠rculo de 8 trigramas en el suelo
    let trigramCircle = new THREE.Group();
    
    // C√≠rculo base de los 8 trigramas
    let baseCircle = new THREE.Mesh(
      new THREE.RingGeometry(4, 4.5, 64),
      new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      })
    );
    baseCircle.rotation.x = -Math.PI/2;
    trigramCircle.add(baseCircle);

    // L√≠neas de los 8 trigramas
    for(let i = 0; i < 8; i++) {
      let angle = (i / 8) * Math.PI * 2;
      let lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0.1, 0),
        new THREE.Vector3(Math.cos(angle) * 4.2, 0.1, Math.sin(angle) * 4.2)
      ]);
      let line = new THREE.Line(
        lineGeometry,
        new THREE.LineBasicMaterial({
          color: 0x80FFFF,
          transparent: true,
          opacity: 0.9
        })
      );
      trigramCircle.add(line);

      // S√≠mbolos de trigramas en cada secci√≥n
      let symbol = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 0.1, 0.8),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.9
        })
      );
      symbol.position.set(
        Math.cos(angle) * 3.5,
        0.2,
        Math.sin(angle) * 3.5
      );
      symbol.rotation.y = angle;
      trigramCircle.add(symbol);
    }

    trigramCircle.position.copy(player.position);
    scene.add(trigramCircle);

    // Animaci√≥n del c√≠rculo de trigramas
    let circleTime = 0;
    let circleInterval = setInterval(() => {
      circleTime += 0.1;
      trigramCircle.rotation.y += 0.05;
      trigramCircle.children.forEach((child, i) => {
        if(child.material) {
          child.material.opacity = 0.6 + Math.sin(circleTime * 4 + i) * 0.3;
        }
      });
    }, 50);

    // Crear las 64 palmas en secuencia √©pica
    let palmCount = 0;
    let palmSequence = [
      2, 4, 8, 16, 32, 64 // Secuencia tradicional: 2, 4, 8, 16, 32, 64 palmas
    ];
    
    let currentSequence = 0;
    let palmsInSequence = 0;
    
    let palmInterval = setInterval(() => {
      if(palmCount >= 64) {
        clearInterval(palmInterval);
        return;
      }

      // Calcular posici√≥n de la palma
      let sequenceAngle = (palmCount / 64) * Math.PI * 2;
      let radius = 1.5 + (palmCount % 8) * 0.3;
      let height = 1 + Math.sin(palmCount * 0.2) * 0.5;

      // Crear efecto de palma individual
      let palm = new THREE.Group();
      
      // N√∫cleo de la palma
      let palmCore = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 8, 8),
        new THREE.MeshBasicMaterial({
          color: 0x00FFFF,
          transparent: true,
          opacity: 0.9
        })
      );
      palm.add(palmCore);

      // Ondas de chakra alrededor de la palma
      for(let i = 0; i < 3; i++) {
        let wave = new THREE.Mesh(
          new THREE.RingGeometry(0.3 + i * 0.2, 0.4 + i * 0.2, 12),
          new THREE.MeshBasicMaterial({
            color: 0x4080FF,
            transparent: true,
            opacity: 0.6 - i * 0.15,
            side: THREE.DoubleSide
          })
        );
        wave.rotation.x = Math.random() * Math.PI;
        palm.add(wave);
      }

      // Posicionar palma
      palm.position.copy(player.position).add(new THREE.Vector3(
        Math.cos(sequenceAngle) * radius,
        height,
        Math.sin(sequenceAngle) * radius
      ));
      
      scene.add(palm);

      // Direcci√≥n hacia el enemigo m√°s cercano o hacia adelante
      let targetDirection = new THREE.Vector3(0, 0, -1);
      if(enemies.length > 0) {
        let closestEnemy = enemies[0];
        let minDist = player.position.distanceTo(closestEnemy.position);
        enemies.forEach(enemy => {
          let dist = player.position.distanceTo(enemy.position);
          if(dist < minDist) {
            minDist = dist;
            closestEnemy = enemy;
          }
        });
        targetDirection = closestEnemy.position.clone().sub(palm.position).normalize();
      }

      // A√±adir a poderes
      powers.push({
        mesh: palm,
        vel: targetDirection.multiplyScalar(0.8),
        life: 60,
        damage: 15,
        palmIndex: palmCount,
        onHit: (enemy) => {
          // Efecto especial de impacto de palma
          let impactRing = new THREE.Mesh(
            new THREE.RingGeometry(0.5, 1.5, 16),
            new THREE.MeshBasicMaterial({
              color: 0x00FFFF,
              transparent: true,
              opacity: 0.8,
              side: THREE.DoubleSide
            })
          );
          impactRing.position.copy(enemy.position);
          impactRing.lookAt(camera.position);
          scene.add(impactRing);

          // Animar anillo de impacto
          let impactTime = 0;
          let impactInterval = setInterval(() => {
            impactTime += 0.2;
            impactRing.scale.setScalar(1 + impactTime);
            impactRing.material.opacity = Math.max(0, 0.8 - impactTime);
            
            if(impactTime > 1) {
              clearInterval(impactInterval);
              scene.remove(impactRing);
            }
          }, 50);
        }
      });

      palmCount++;
      palmsInSequence++;

      // Verificar si completamos una secuencia
      if(currentSequence < palmSequence.length && palmsInSequence >= palmSequence[currentSequence]) {
        currentSequence++;
        palmsInSequence = 0;
        
        // Efecto especial al completar cada secuencia
        let sequenceEffect = new THREE.Mesh(
          new THREE.RingGeometry(2, 3, 32),
          new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
          })
        );
        sequenceEffect.position.copy(player.position);
        sequenceEffect.rotation.x = -Math.PI/2;
        scene.add(sequenceEffect);

        // Animar efecto de secuencia
        let seqTime = 0;
        let seqInterval = setInterval(() => {
          seqTime += 0.3;
          sequenceEffect.scale.setScalar(1 + seqTime * 2);
          sequenceEffect.material.opacity = Math.max(0, 0.9 - seqTime);
          
          if(seqTime > 0.8) {
            clearInterval(seqInterval);
            scene.remove(sequenceEffect);
          }
        }, 50);
      }
    }, 80); // Una palma cada 80ms para efecto r√°pido

    // Limpiar c√≠rculo de trigramas despu√©s de la t√©cnica
    setTimeout(() => {
      clearInterval(circleInterval);
      scene.remove(trigramCircle);
    }, 8000);
  }

  function activate128Palms(){
    // ANIMACI√ìN √âPICA DE 128 PALMAS
    animateCharacterPower('128palms');
    
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    // HAKKE HYAKUNIJ≈™HACHISH≈å - 128 PALMAS DEFINITIVAS
    
    // Crear campo de batalla de 8 trigramas expandido
    let ultimateField = new THREE.Group();
    
    // C√≠rculo exterior m√°s grande
    let outerCircle = new THREE.Mesh(
      new THREE.RingGeometry(6, 7, 128),
      new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      })
    );
    outerCircle.rotation.x = -Math.PI/2;
    ultimateField.add(outerCircle);

    // C√≠rculo interior
    let innerCircle = new THREE.Mesh(
      new THREE.RingGeometry(3, 4, 64),
      new THREE.MeshBasicMaterial({
        color: 0x80FFFF,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
      })
    );
    innerCircle.rotation.x = -Math.PI/2;
    ultimateField.add(innerCircle);

    // 16 l√≠neas de poder (doble de las normales)
    for(let i = 0; i < 16; i++) {
      let angle = (i / 16) * Math.PI * 2;
      let lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0.1, 0),
        new THREE.Vector3(Math.cos(angle) * 6.5, 0.1, Math.sin(angle) * 6.5)
      ]);
      let line = new THREE.Line(
        lineGeometry,
        new THREE.LineBasicMaterial({
          color: i % 2 ? 0x00FFFF : 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        })
      );
      ultimateField.add(line);

      // S√≠mbolos de poder en cada l√≠nea
      for(let j = 0; j < 3; j++) {
        let symbol = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.1, 0.6),
          new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.9
          })
        );
        symbol.position.set(
          Math.cos(angle) * (2 + j * 1.5),
          0.2,
          Math.sin(angle) * (2 + j * 1.5)
        );
        symbol.rotation.y = angle;
        ultimateField.add(symbol);
      }
    }

    ultimateField.position.copy(player.position);
    scene.add(ultimateField);

    // Animaci√≥n del campo definitivo
    let fieldTime = 0;
    let fieldInterval = setInterval(() => {
      fieldTime += 0.15;
      ultimateField.rotation.y += 0.08;
      
      // Pulso de energ√≠a
      outerCircle.scale.setScalar(1 + Math.sin(fieldTime * 3) * 0.1);
      innerCircle.scale.setScalar(1 + Math.sin(fieldTime * 4) * 0.15);
      
      ultimateField.children.forEach((child, i) => {
        if(child.material) {
          child.material.opacity = 0.5 + Math.sin(fieldTime * 5 + i) * 0.4;
        }
      });
    }, 50);

    // Crear las 128 palmas en formaci√≥n √©pica
    let palmCount = 0;
    let waveCount = 0;
    const PALMS_PER_WAVE = 16;
    const TOTAL_WAVES = 8;
    
    let palmInterval = setInterval(() => {
      if(palmCount >= 128) {
        clearInterval(palmInterval);
        return;
      }

      // Crear oleada de palmas simult√°neas
      for(let i = 0; i < PALMS_PER_WAVE && palmCount < 128; i++) {
        let waveAngle = (i / PALMS_PER_WAVE) * Math.PI * 2;
        let spiralRadius = 2 + (waveCount * 0.5);
        let height = 1.5 + Math.sin(waveAngle * 2) * 0.8;

        // Crear palma definitiva
        let ultimatePalm = new THREE.Group();
        
        // N√∫cleo de poder intensificado
        let palmCore = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 12, 12),
          new THREE.MeshBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 1.0
          })
        );
        ultimatePalm.add(palmCore);

        // M√∫ltiples anillos de chakra
        for(let j = 0; j < 5; j++) {
          let ring = new THREE.Mesh(
            new THREE.RingGeometry(0.4 + j * 0.15, 0.5 + j * 0.15, 16),
            new THREE.MeshBasicMaterial({
              color: j % 2 ? 0x4080FF : 0x80FFFF,
              transparent: true,
              opacity: 0.8 - j * 0.1,
              side: THREE.DoubleSide
            })
          );
          ring.rotation.x = Math.random() * Math.PI;
          ring.rotation.y = Math.random() * Math.PI;
          ultimatePalm.add(ring);
        }

        // Rayos de energ√≠a
        for(let k = 0; k < 6; k++) {
          let ray = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.05, 1.2),
            new THREE.MeshBasicMaterial({
              color: 0xFFFFFF,
              transparent: true,
              opacity: 0.9
            })
          );
          ray.position.set(
            Math.cos(k * Math.PI / 3) * 0.6,
            Math.sin(k * Math.PI / 3) * 0.6,
            0
          );
          ray.rotation.z = k * Math.PI / 3;
          ultimatePalm.add(ray);
        }

        // Posicionar palma en espiral
        ultimatePalm.position.copy(player.position).add(new THREE.Vector3(
          Math.cos(waveAngle) * spiralRadius,
          height,
          Math.sin(waveAngle) * spiralRadius
        ));
        
        scene.add(ultimatePalm);

        // Direcci√≥n inteligente hacia enemigos
        let targetDirection = new THREE.Vector3(
          Math.cos(waveAngle),
          0,
          Math.sin(waveAngle)
        ).normalize();

        if(enemies.length > 0) {
          // Distribuir palmas entre todos los enemigos
          let targetEnemy = enemies[i % enemies.length];
          targetDirection = targetEnemy.position.clone().sub(ultimatePalm.position).normalize();
        }

        // A√±adir a poderes con efectos mejorados
        powers.push({
          mesh: ultimatePalm,
          vel: targetDirection.multiplyScalar(1.2),
          life: 70,
          damage: 12,
          palmIndex: palmCount,
          waveIndex: waveCount,
          onHit: (enemy) => {
            // Efecto de impacto definitivo
            let ultimateImpact = new THREE.Group();
            
            // Explosi√≥n central
            let explosion = new THREE.Mesh(
              new THREE.SphereGeometry(1, 16, 16),
              new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.8,
                wireframe: true
              })
            );
            ultimateImpact.add(explosion);

            // Ondas de choque
            for(let wave = 0; wave < 4; wave++) {
              let shockwave = new THREE.Mesh(
                new THREE.RingGeometry(0.5 + wave * 0.5, 1 + wave * 0.5, 24),
                new THREE.MeshBasicMaterial({
                  color: 0x80FFFF,
                  transparent: true,
                  opacity: 0.6 - wave * 0.1,
                  side: THREE.DoubleSide
                })
              );
              shockwave.rotation.x = -Math.PI/2;
              shockwave.position.y = wave * 0.2;
              ultimateImpact.add(shockwave);
            }

            ultimateImpact.position.copy(enemy.position);
            scene.add(ultimateImpact);

            // Animar impacto definitivo
            let impactTime = 0;
            let impactInterval = setInterval(() => {
              impactTime += 0.2;
              
              explosion.scale.setScalar(1 + impactTime * 2);
              explosion.material.opacity = Math.max(0, 0.8 - impactTime);
              
              ultimateImpact.children.forEach((child, index) => {
                if(child.geometry && child.geometry.type === 'RingGeometry') {
                  child.scale.setScalar(1 + impactTime * (index + 1));
                  child.material.opacity = Math.max(0, 0.6 - impactTime * (index + 1) * 0.3);
                }
              });
              
              if(impactTime > 1.5) {
                clearInterval(impactInterval);
                scene.remove(ultimateImpact);
              }
            }, 50);
          }
        });

        palmCount++;
      }

      waveCount++;

      // Efecto especial cada oleada completa
      let waveEffect = new THREE.Mesh(
        new THREE.RingGeometry(4, 5, 64),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 1.0,
          side: THREE.DoubleSide
        })
      );
      waveEffect.position.copy(player.position);
      waveEffect.rotation.x = -Math.PI/2;
      scene.add(waveEffect);

      // Animar efecto de oleada
      let waveTime = 0;
      let waveInterval = setInterval(() => {
        waveTime += 0.4;
        waveEffect.scale.setScalar(1 + waveTime * 3);
        waveEffect.material.opacity = Math.max(0, 1.0 - waveTime);
        
        if(waveTime > 1) {
          clearInterval(waveInterval);
          scene.remove(waveEffect);
        }
      }, 50);

    }, 200); // Una oleada cada 200ms

    // Limpiar campo definitivo
    setTimeout(() => {
      clearInterval(fieldInterval);
      scene.remove(ultimateField);
    }, 12000);
  }

  function activateKaiten(){
    // ANIMACI√ìN √âPICA DE KAITEN
    animateCharacterPower('kaiten');
    // HAKKESH≈å KAITEN - ROTACI√ìN CELESTIAL DE LOS 8 TRIGRAMAS
    
    // Crear sistema de rotaci√≥n m√∫ltiple
    let kaitenSystem = new THREE.Group();
    
    // Domo principal de protecci√≥n
    let mainDome = new THREE.Mesh(
      new THREE.SphereGeometry(4, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
      new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        wireframe: true
      })
    );
    kaitenSystem.add(mainDome);

    // Anillos de chakra giratorios
    let rings = [];
    for(let i = 0; i < 6; i++) {
      let ring = new THREE.Mesh(
        new THREE.RingGeometry(2 + i * 0.5, 2.3 + i * 0.5, 32),
        new THREE.MeshBasicMaterial({
          color: i % 2 ? 0x4080FF : 0x80FFFF,
          transparent: true,
          opacity: 0.8 - i * 0.1,
          side: THREE.DoubleSide
        })
      );
      
      // Diferentes orientaciones para cada anillo
      if(i % 3 === 0) ring.rotation.x = Math.PI / 2;
      else if(i % 3 === 1) ring.rotation.y = Math.PI / 2;
      else ring.rotation.z = Math.PI / 2;
      
      kaitenSystem.add(ring);
      rings.push(ring);
    }

    // Espirales de energ√≠a
    let spirals = [];
    for(let i = 0; i < 12; i++) {
      let spiral = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 3),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.9
        })
      );
      
      let angle = (i / 12) * Math.PI * 2;
      spiral.position.set(
        Math.cos(angle) * 2.5,
        Math.sin(i * 0.5) * 1.5,
        Math.sin(angle) * 2.5
      );
      spiral.lookAt(new THREE.Vector3(0, 0, 0));
      
      kaitenSystem.add(spiral);
      spirals.push(spiral);
    }

    // Puntos de chakra orbitales
    let chakraOrbs = [];
    for(let i = 0; i < 8; i++) {
      let orb = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({
          color: 0x00FFFF,
          transparent: true,
          opacity: 0.9
        })
      );
      
      let angle = (i / 8) * Math.PI * 2;
      orb.position.set(
        Math.cos(angle) * 3.5,
        Math.sin(angle * 2) * 0.5,
        Math.sin(angle) * 3.5
      );
      
      kaitenSystem.add(orb);
      chakraOrbs.push(orb);
    }

    // Posicionar sistema en el jugador
    kaitenSystem.position.copy(player.position);
    scene.add(kaitenSystem);

    // Variables de animaci√≥n
    let rotationSpeed = 0.1;
    let kaitenTime = 0;
    let maxSpeed = 1.2;
    let acceleration = 0.05;
    
    let kaitenInterval = setInterval(() => {
      kaitenTime += 0.1;
      
      // Acelerar gradualmente
      if(rotationSpeed < maxSpeed) {
        rotationSpeed += acceleration;
      }
      
      // Rotar sistema principal
      kaitenSystem.rotation.y += rotationSpeed;
      kaitenSystem.rotation.x += rotationSpeed * 0.3;
      
      // Rotar anillos individuales
      rings.forEach((ring, i) => {
        if(i % 3 === 0) {
          ring.rotation.z += rotationSpeed * (i % 2 ? 1 : -1);
        } else if(i % 3 === 1) {
          ring.rotation.x += rotationSpeed * (i % 2 ? 1 : -1);
        } else {
          ring.rotation.y += rotationSpeed * (i % 2 ? 1 : -1);
        }
        
        // Efecto de pulso
        ring.scale.setScalar(1 + Math.sin(kaitenTime * 8 + i) * 0.1);
      });
      
      // Animar espirales
      spirals.forEach((spiral, i) => {
        spiral.rotation.z += rotationSpeed * 2;
        spiral.material.opacity = 0.7 + Math.sin(kaitenTime * 6 + i) * 0.3;
      });
      
      // Orbitar chakra orbs
      chakraOrbs.forEach((orb, i) => {
        let angle = (i / 8) * Math.PI * 2 + kaitenTime * rotationSpeed * 4;
        orb.position.set(
          Math.cos(angle) * 3.5,
          Math.sin(angle * 2 + kaitenTime) * 0.8,
          Math.sin(angle) * 3.5
        );
        orb.scale.setScalar(1 + Math.sin(kaitenTime * 10 + i) * 0.4);
      });
      
      // Efecto de pulso en el domo
      mainDome.scale.setScalar(1 + Math.sin(kaitenTime * 4) * 0.15);
      mainDome.material.opacity = 0.4 + Math.sin(kaitenTime * 6) * 0.3;
      
      // Mantener posici√≥n con el jugador
      kaitenSystem.position.copy(player.position);
      
      // Da√±o y repulsi√≥n a enemigos
      enemies.forEach(enemy => {
        let distance = enemy.position.distanceTo(kaitenSystem.position);
        if(distance < 4.5) {
          // Da√±o continuo
          enemy.userData.hp -= 5;
          
          // Efecto de repulsi√≥n
          let repelDirection = enemy.position.clone().sub(kaitenSystem.position).normalize();
          enemy.position.add(repelDirection.multiplyScalar(0.3));
          
          // Efecto visual de impacto
          let impactSpark = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8),
            new THREE.MeshBasicMaterial({
              color: 0xFFFFFF,
              transparent: true,
              opacity: 0.8
            })
          );
          impactSpark.position.copy(enemy.position);
          scene.add(impactSpark);
          
          // Animar chispa de impacto
          let sparkTime = 0;
          let sparkInterval = setInterval(() => {
            sparkTime += 0.3;
            impactSpark.scale.setScalar(1 + sparkTime * 2);
            impactSpark.material.opacity = Math.max(0, 0.8 - sparkTime);
            
            if(sparkTime > 0.8) {
              clearInterval(sparkInterval);
              scene.remove(impactSpark);
            }
          }, 50);
          
          // Hacer que el enemigo gire por el impacto
          enemy.rotation.y += rotationSpeed * 0.5;
        }
      });
      
    }, 40);
    
    // Crear ondas de choque peri√≥dicas
    let shockwaveInterval = setInterval(() => {
      let shockwave = new THREE.Mesh(
        new THREE.RingGeometry(0.5, 1, 32),
        new THREE.MeshBasicMaterial({
          color: 0x00FFFF,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        })
      );
      shockwave.position.copy(kaitenSystem.position);
      shockwave.rotation.x = -Math.PI/2;
      scene.add(shockwave);
      
      // Animar onda de choque
      let shockTime = 0;
      let shockInterval = setInterval(() => {
        shockTime += 0.2;
        shockwave.scale.setScalar(1 + shockTime * 8);
        shockwave.material.opacity = Math.max(0, 0.8 - shockTime);
        
        if(shockTime > 1) {
          clearInterval(shockInterval);
          scene.remove(shockwave);
        }
      }, 50);
    }, 800);
    
    // Duraci√≥n total del Kaiten
    setTimeout(() => {
      clearInterval(kaitenInterval);
      clearInterval(shockwaveInterval);
      
      // Efecto de finalizaci√≥n
      let finalBurst = new THREE.Mesh(
        new THREE.SphereGeometry(6, 32, 32),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.6,
          wireframe: true
        })
      );
      finalBurst.position.copy(kaitenSystem.position);
      scene.add(finalBurst);
      
      // Animar explosi√≥n final
      let burstTime = 0;
      let burstInterval = setInterval(() => {
        burstTime += 0.3;
        finalBurst.scale.setScalar(1 + burstTime * 2);
        finalBurst.material.opacity = Math.max(0, 0.6 - burstTime * 0.5);
        
        if(burstTime > 1.2) {
          clearInterval(burstInterval);
          scene.remove(finalBurst);
        }
      }, 50);
      
      scene.remove(kaitenSystem);
    }, 5000);
  }

  function activateKusho(){
    // ANIMACI√ìN DE KUSHO
    animateCharacterPower('juken');
    // HAKKE K≈™SH≈å - PALMA DE VAC√çO DE LOS 8 TRIGRAMAS
    
    // Crear campo de vac√≠o √©pico
    let vacuumField = new THREE.Group();
    
    // N√∫cleo de vac√≠o
    let vacuumCore = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.9
      })
    );
    vacuumField.add(vacuumCore);
    
    // Anillos de distorsi√≥n espacial
    let distortionRings = [];
    for(let i = 0; i < 8; i++) {
      let ring = new THREE.Mesh(
        new THREE.RingGeometry(1 + i * 0.8, 1.3 + i * 0.8, 32),
        new THREE.MeshBasicMaterial({
          color: i % 2 ? 0xFF00FF : 0x8000FF,
          transparent: true,
          opacity: 0.7 - i * 0.08,
          side: THREE.DoubleSide
        })
      );
      ring.rotation.x = -Math.PI/2 + (Math.random() - 0.5) * 0.4;
      ring.rotation.z = Math.random() * Math.PI * 2;
      vacuumField.add(ring);
      distortionRings.push(ring);
    }
    
    // Espirales de absorci√≥n
    let absorptionSpirals = [];
    for(let i = 0; i < 12; i++) {
      let spiral = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 2),
        new THREE.MeshBasicMaterial({
          color: 0xFF00FF,
          transparent: true,
          opacity: 0.8
        })
      );
      
      let angle = (i / 12) * Math.PI * 2;
      spiral.position.set(
        Math.cos(angle) * 3,
        Math.sin(i * 0.3) * 0.5,
        Math.sin(angle) * 3
      );
      spiral.lookAt(vacuumCore.position);
      
      vacuumField.add(spiral);
      absorptionSpirals.push(spiral);
    }
    
    vacuumField.position.copy(player.position).add(new THREE.Vector3(0, 1, 0));
    scene.add(vacuumField);
    
    // Variables de expansi√≥n
    let expansionScale = 0.5;
    let maxScale = 8;
    let expansionSpeed = 0.3;
    let vacuumTime = 0;
    
    let vacuumInterval = setInterval(() => {
      vacuumTime += 0.1;
      expansionScale += expansionSpeed;
      
      // Expandir anillos de distorsi√≥n
      distortionRings.forEach((ring, i) => {
        let ringScale = expansionScale * (1 + i * 0.1);
        ring.scale.setScalar(ringScale);
        ring.material.opacity = Math.max(0, (0.7 - i * 0.08) * (1 - expansionScale / maxScale));
        
        // Rotaci√≥n de distorsi√≥n
        ring.rotation.z += 0.1 * (i % 2 ? 1 : -1);
      });
      
      // Animar n√∫cleo de vac√≠o
      vacuumCore.scale.setScalar(expansionScale * 0.3);
      vacuumCore.material.opacity = 0.9 + Math.sin(vacuumTime * 10) * 0.1;
      
      // Animar espirales de absorci√≥n
      absorptionSpirals.forEach((spiral, i) => {
        let angle = (i / 12) * Math.PI * 2 + vacuumTime * 2;
        let radius = 4 - (expansionScale * 0.3); // Se acercan al centro
        
        spiral.position.set(
          Math.cos(angle) * Math.max(0.5, radius),
          Math.sin(i * 0.3 + vacuumTime * 3) * 0.8,
          Math.sin(angle) * Math.max(0.5, radius)
        );
        spiral.lookAt(vacuumCore.getWorldPosition(new THREE.Vector3()));
        spiral.material.opacity = 0.8 * (1 - expansionScale / maxScale);
      });
      
      // Efectos en enemigos
      enemies.forEach(enemy => {
        let distance = enemy.position.distanceTo(vacuumField.position);
        let effectRadius = expansionScale * 1.5;
        
        if(distance < effectRadius) {
          // Da√±o basado en proximidad
          let damage = Math.max(1, 8 - Math.floor(distance));
          enemy.userData.hp -= damage;
          
          // Efecto de absorci√≥n - atraer hacia el centro
          let pullDirection = vacuumField.position.clone().sub(enemy.position).normalize();
          let pullStrength = Math.max(0, 1 - distance / effectRadius) * 0.2;
          enemy.position.add(pullDirection.multiplyScalar(pullStrength));
          
          // Efecto visual de absorci√≥n en el enemigo
          if(Math.random() < 0.3) {
            let absorptionEffect = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.2, 0.2),
              new THREE.MeshBasicMaterial({
                color: 0xFF00FF,
                transparent: true,
                opacity: 0.8
              })
            );
            absorptionEffect.position.copy(enemy.position).add(new THREE.Vector3(
              (Math.random() - 0.5) * 2,
              Math.random() * 2,
              (Math.random() - 0.5) * 2
            ));
            scene.add(absorptionEffect);
            
            // Animar part√≠cula hacia el centro
            let particleVel = vacuumField.position.clone().sub(absorptionEffect.position).normalize().multiplyScalar(0.3);
            let particleInterval = setInterval(() => {
              absorptionEffect.position.add(particleVel);
              absorptionEffect.material.opacity -= 0.1;
              absorptionEffect.scale.multiplyScalar(0.95);
              
              if(absorptionEffect.material.opacity <= 0 || 
                 absorptionEffect.position.distanceTo(vacuumField.position) < 0.5) {
                clearInterval(particleInterval);
                scene.remove(absorptionEffect);
              }
            }, 50);
          }
          
          // Distorsi√≥n visual del enemigo
          enemy.rotation.y += 0.2;
          enemy.scale.setScalar(1 + Math.sin(vacuumTime * 8) * 0.1);
        }
      });
      
      // Crear ondas de choque peri√≥dicas
      if(Math.floor(vacuumTime * 10) % 15 === 0) {
        let shockwave = new THREE.Mesh(
          new THREE.RingGeometry(0.2, 0.8, 32),
          new THREE.MeshBasicMaterial({
            color: 0x8000FF,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
          })
        );
        shockwave.position.copy(vacuumField.position);
        shockwave.rotation.x = -Math.PI/2;
        scene.add(shockwave);
        
        let shockTime = 0;
        let shockInterval = setInterval(() => {
          shockTime += 0.4;
          shockwave.scale.setScalar(1 + shockTime * 6);
          shockwave.material.opacity = Math.max(0, 0.9 - shockTime);
          
          if(shockTime > 1) {
            clearInterval(shockInterval);
            scene.remove(shockwave);
          }
        }, 50);
      }
      
      // Terminar cuando alcance el tama√±o m√°ximo
      if(expansionScale >= maxScale) {
        clearInterval(vacuumInterval);
        
        // Efecto de colapso final
        let collapseEffect = new THREE.Mesh(
          new THREE.SphereGeometry(expansionScale * 2, 32, 32),
          new THREE.MeshBasicMaterial({
            color: 0xFF00FF,
            transparent: true,
            opacity: 0.3,
            wireframe: true
          })
        );
        collapseEffect.position.copy(vacuumField.position);
        scene.add(collapseEffect);
        
        // Animar colapso
        let collapseTime = 0;
        let collapseInterval = setInterval(() => {
          collapseTime += 0.5;
          collapseEffect.scale.setScalar(1 - collapseTime * 0.8);
          collapseEffect.material.opacity = Math.max(0, 0.3 + collapseTime * 0.7);
          
          if(collapseTime > 1.2) {
            clearInterval(collapseInterval);
            scene.remove(collapseEffect);
          }
        }, 50);
        
        scene.remove(vacuumField);
      }
    }, 80);
  }

  function activateDetect(){
    // ANIMACI√ìN DE DETECCI√ìN
    animateCharacterPower('byakugan');
    // BYAKUGAN: DETECCI√ìN AVANZADA Y AN√ÅLISIS DE CHAKRA
    
    // Crear pulso de detecci√≥n desde el jugador
    let detectionPulse = new THREE.Group();
    
    // Onda de escaneo principal
    let scanWave = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.3,
        wireframe: true
      })
    );
    detectionPulse.add(scanWave);
    
    // Anillos de an√°lisis
    let analysisRings = [];
    for(let i = 0; i < 5; i++) {
      let ring = new THREE.Mesh(
        new THREE.RingGeometry(2 + i, 2.5 + i, 32),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.6 - i * 0.1,
          side: THREE.DoubleSide
        })
      );
      ring.rotation.x = -Math.PI/2;
      detectionPulse.add(ring);
      analysisRings.push(ring);
    }
    
    detectionPulse.position.copy(player.position);
    scene.add(detectionPulse);
    
    // Expandir pulso de detecci√≥n
    let pulseScale = 1;
    let maxPulseScale = 15;
    let pulseTime = 0;
    
    let pulseInterval = setInterval(() => {
      pulseTime += 0.1;
      pulseScale += 0.8;
      
      // Expandir onda de escaneo
      scanWave.scale.setScalar(pulseScale);
      scanWave.material.opacity = Math.max(0, 0.3 * (1 - pulseScale / maxPulseScale));
      
      // Animar anillos de an√°lisis
      analysisRings.forEach((ring, i) => {
        ring.scale.setScalar(pulseScale * (1 + i * 0.1));
        ring.material.opacity = Math.max(0, (0.6 - i * 0.1) * (1 - pulseScale / maxPulseScale));
        ring.rotation.z += 0.05 * (i % 2 ? 1 : -1);
      });
      
      if(pulseScale >= maxPulseScale) {
        clearInterval(pulseInterval);
        scene.remove(detectionPulse);
      }
    }, 50);
    
    // An√°lisis detallado de cada enemigo
    enemies.forEach((enemy, index) => {
      setTimeout(() => {
        // Sistema de an√°lisis completo
        let analysisSystem = new THREE.Group();
        
        // Holograma de an√°lisis
        let hologram = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 4, 2.5),
          new THREE.MeshBasicMaterial({
            color: 0x00FFFF,
            transparent: true,
            opacity: 0.2,
            wireframe: true
          })
        );
        analysisSystem.add(hologram);
        
        // L√≠neas de escaneo
        for(let i = 0; i < 8; i++) {
          let scanLine = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 4, 0.05),
            new THREE.MeshBasicMaterial({
              color: 0xFFFF00,
              transparent: true,
              opacity: 0.8
            })
          );
          
          let angle = (i / 8) * Math.PI * 2;
          scanLine.position.set(
            Math.cos(angle) * 1.2,
            0,
            Math.sin(angle) * 1.2
          );
          analysisSystem.add(scanLine);
        }
        
        // Puntos de chakra detectados
        let chakraPoints = [
          {pos: [0, 1.5, 0], color: 0xFF0000, size: 0.2}, // Cabeza
          {pos: [0, 0.8, 0], color: 0x00FF00, size: 0.25}, // Coraz√≥n
          {pos: [0, 0.2, 0], color: 0x0000FF, size: 0.2}, // Dantian
          {pos: [-0.5, 0.8, 0], color: 0xFFFF00, size: 0.15}, // Brazo izq
          {pos: [0.5, 0.8, 0], color: 0xFFFF00, size: 0.15}, // Brazo der
          {pos: [-0.2, -0.5, 0], color: 0xFF00FF, size: 0.15}, // Pierna izq
          {pos: [0.2, -0.5, 0], color: 0xFF00FF, size: 0.15}  // Pierna der
        ];
        
        chakraPoints.forEach(point => {
          let chakraPoint = new THREE.Mesh(
            new THREE.SphereGeometry(point.size, 8, 8),
            new THREE.MeshBasicMaterial({
              color: point.color,
              transparent: true,
              opacity: 0.9
            })
          );
          chakraPoint.position.set(...point.pos);
          analysisSystem.add(chakraPoint);
          
          // Conexiones de chakra
          if(point !== chakraPoints[0]) {
            let connection = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(...chakraPoints[1].pos), // Coraz√≥n como centro
              new THREE.Vector3(...point.pos)
            ]);
            let line = new THREE.Line(
              connection,
              new THREE.LineBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.6
              })
            );
            analysisSystem.add(line);
          }
        });
        
        // Informaci√≥n de estado flotante
        let statusDisplay = document.createElement('div');
        statusDisplay.style.cssText = `
          position: fixed;
          background: rgba(0,0,0,0.8);
          color: #00FFFF;
          font-family: 'Press Start 2P', cursive;
          font-size: 8px;
          padding: 8px;
          border: 2px solid #00FFFF;
          border-radius: 0px;
          z-index: 1000;
          pointer-events: none;
          box-shadow: 0 0 10px rgba(0,255,255,0.5);
        `;
        
        statusDisplay.innerHTML = `
          OBJETIVO: ENEMIGO ${index + 1}<br>
          HP: ${enemy.userData.hp}/${WORLD_CONFIG.enemyHealth}<br>
          ESTADO: ${enemy.userData.hp > 50 ? 'ACTIVO' : 'DA√ëADO'}<br>
          CHAKRA: ${Math.floor(Math.random() * 100)}%<br>
          DISTANCIA: ${Math.floor(enemy.position.distanceTo(player.position))}m
        `;
        
        document.body.appendChild(statusDisplay);
        
        analysisSystem.position.copy(enemy.position);
        scene.add(analysisSystem);
        
        // Animaci√≥n del sistema de an√°lisis
        let analysisTime = 0;
        let analysisInterval = setInterval(() => {
          analysisTime += 0.1;
          
          // Rotar holograma
          hologram.rotation.y += 0.05;
          hologram.material.opacity = 0.2 + Math.sin(analysisTime * 6) * 0.1;
          
          // Animar l√≠neas de escaneo
          analysisSystem.children.forEach((child, i) => {
            if(child.geometry && child.geometry.parameters && child.geometry.parameters.height === 4) {
              child.position.y = Math.sin(analysisTime * 4 + i) * 0.3;
              child.material.opacity = 0.6 + Math.sin(analysisTime * 8 + i) * 0.3;
            }
          });
          
          // Pulso de puntos de chakra
          chakraPoints.forEach((point, i) => {
            let chakraNode = analysisSystem.children.find(child => 
              child.geometry && child.geometry.type === 'SphereGeometry' && 
              child.position.equals(new THREE.Vector3(...point.pos))
            );
            if(chakraNode) {
              chakraNode.scale.setScalar(1 + Math.sin(analysisTime * 8 + i) * 0.4);
            }
          });
          
          // Actualizar posici√≥n del display
          let screenPos = enemy.position.clone().project(camera);
          let x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
          let y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight - 100;
          statusDisplay.style.transform = `translate(${x}px, ${y}px)`;
          
        }, 50);
        
        // Limpiar an√°lisis despu√©s de 5 segundos
        setTimeout(() => {
          clearInterval(analysisInterval);
          scene.remove(analysisSystem);
          statusDisplay.remove();
        }, 5000);
        
        // Efecto de marcado permanente
        let marker = new THREE.Mesh(
          new THREE.RingGeometry(1.5, 2, 16),
          new THREE.MeshBasicMaterial({
            color: 0xFFFF00,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
          })
        );
        marker.rotation.x = -Math.PI/2;
        marker.position.copy(enemy.position);
        marker.position.y += 0.1;
        scene.add(marker);
        
        // Animar marcador
        let markerTime = 0;
        let markerInterval = setInterval(() => {
          markerTime += 0.1;
          marker.rotation.z += 0.1;
          marker.scale.setScalar(1 + Math.sin(markerTime * 4) * 0.2);
          marker.material.opacity = 0.5 + Math.sin(markerTime * 6) * 0.3;
          
          // Mantener posici√≥n con el enemigo
          marker.position.copy(enemy.position);
          marker.position.y += 0.1;
        }, 50);
        
        // Limpiar marcador despu√©s de 10 segundos
        setTimeout(() => {
          clearInterval(markerInterval);
          scene.remove(marker);
        }, 10000);
        
      }, index * 300); // Escalonar el an√°lisis de cada enemigo
    });
    
    // Efecto de mejora temporal de percepci√≥n
    let perceptionBoost = document.createElement('div');
    perceptionBoost.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,255,255,0.2);
      color: #FFFFFF;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      padding: 10px 20px;
      border: 2px solid #00FFFF;
      z-index: 1000;
      animation: pixelBlink 1s steps(2) infinite;
    `;
    perceptionBoost.textContent = 'BYAKUGAN: PERCEPCI√ìN MEJORADA ACTIVA';
    document.body.appendChild(perceptionBoost);
    
    setTimeout(() => {
      perceptionBoost.remove();
    }, 8000);
  }

  // Nuevos poderes de Itachi
  function activateSharingan() {
    // ANIMACI√ìN √âPICA DE SHARINGAN
    animateCharacterPower('sharingan');
    
    // Pausar YouTube mientras suena el Sharingan
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Sharingan con video HTML5
    let sharinganSound = document.createElement('video');
    sharinganSound.id = 'sharingan-sound';
    sharinganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    sharinganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/4094554501659701029.mp4?updatedAt=1748454278815';
    sharinganSound.autoplay = true;
    sharinganSound.muted = false;
    sharinganSound.volume = 1.0;
    sharinganSound.preload = 'auto';

    // Forzar reproducci√≥n inmediata
    document.body.appendChild(sharinganSound);

    sharinganSound.play().then(() => {
      console.log('Sharingan sound playing!');
    }).catch(e => {
      console.log('Sharingan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      sharinganSound.muted = true;
      sharinganSound.play().then(() => {
        sharinganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      sharinganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Sharingan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 2500);

    // Efecto visual mejorado del Sharingan pixelado
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:
        repeating-conic-gradient(from 0deg,
          rgba(255,0,0,0.2) 0deg 45deg,
          rgba(0,0,0,0.4) 45deg 90deg);
      background-size: 32px 32px;
      pointer-events:none;
      animation: pixel-sharingan 2s steps(4) infinite;
    `;

    // A√±adir tomoes giratorios pixelados
    let tomoe = document.createElement('div');
    tomoe.style.cssText = `
      position:fixed;top:50%;left:50%;
      width:200px;height:200px;
      transform:translate(-50%,-50%);
      background:
        repeating-conic-gradient(from 0deg,
          #ff0000 0deg 30deg,
          #000000 30deg 60deg);
      background-size: 32px 32px;
      animation: pixel-spin 4s steps(8) infinite;
      pointer-events:none;
      z-index:1000;
      image-rendering: pixelated;
    `;

    document.body.appendChild(overlay);
    document.body.appendChild(tomoe);

    // Aumentar velocidad y precisi√≥n temporalmente
    let originalSpeed = playerSpeed;
    playerSpeed *= 1.5;

    // Marcar enemigos con auras m√°s visibles
    enemies.forEach(e => {
      let aura = new THREE.Mesh(
        new THREE.BoxGeometry(5,0.2,5),
        new THREE.MeshBasicMaterial({
          color:0xff0000,
          side:THREE.DoubleSide,
          transparent:true,
          opacity:0.5
        })
      );

      // A√±adir marcadores pixelados alrededor del enemigo
      for(let i = 0; i < 3; i++) {
        let marker = new THREE.Mesh(
          new THREE.BoxGeometry(0.4,0.4,0.4),
          new THREE.MeshBasicMaterial({color:0xff0000})
        );
        marker.position.copy(e.position).add(new THREE.Vector3(
          Math.cos(i * Math.PI * 2/3) * 2,
          1,
          Math.sin(i * Math.PI * 2/3) * 2
        ));
        scene.add(marker);
        setTimeout(() => scene.remove(marker), 5000);
      }

      aura.rotation.x = -Math.PI/2;
      aura.position.copy(e.position).add(new THREE.Vector3(0,1,0));
      scene.add(aura);

      // Animar aura
      let pulseInterval = setInterval(() => {
        aura.scale.x = 1 + Math.sin(Date.now() * 0.005) * 0.2;
        aura.scale.y = aura.scale.x;
      }, 50);

      setTimeout(() => {
        clearInterval(pulseInterval);
        scene.remove(aura);
      }, 5000);

      // Marcar enemigo como visible a trav√©s de paredes
      e.material.transparent = true;
      e.material.opacity = 0.7;
      setTimeout(() => {
        e.material.transparent = false;
        e.material.opacity = 1;
      }, 5000);
    });

    // Restaurar velocidad normal despu√©s de 5 segundos
    setTimeout(() => {
      playerSpeed = originalSpeed;
      overlay.remove();
      tomoe.remove();
    }, 5000);
  }

  function activateAmaterasu() {
    // ANIMACI√ìN √âPICA DE AMATERASU
    animateCharacterPower('amaterasu');
    
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    // LLAMAS NEGRAS DE AMATERASU
    let amaterasuFlame = new THREE.Group();
    
    // N√∫cleo de llama negra
    let flameCore = new THREE.Mesh(
      new THREE.BoxGeometry(1.5, 1.5, 1.5),
      new THREE.MeshBasicMaterial({color: 0x000000})
    );
    amaterasuFlame.add(flameCore);
    
    // Llamas exteriores
    for(let i = 0; i < 6; i++) {
      let outerFlame = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 2, 0.8),
        new THREE.MeshBasicMaterial({color: 0x330000, transparent: true, opacity: 0.8})
      );
      let angle = (i / 6) * Math.PI * 2;
      outerFlame.position.set(
        Math.cos(angle) * 1.2,
        Math.sin(i * 0.5) * 0.5,
        Math.sin(angle) * 1.2
      );
      amaterasuFlame.add(outerFlame);
    }
    
    amaterasuFlame.position.copy(player.position).add(new THREE.Vector3(0, 1, 0));
    scene.add(amaterasuFlame);
    
    powers.push({
      mesh: amaterasuFlame,
      vel: new THREE.Vector3(0, 0, -1.5),
      life: 80,
      damage: 150
    });
  }

  function activateTsukuyomi() {
    // ANIMACI√ìN √âPICA DE TSUKUYOMI
    animateCharacterPower('tsukuyomi');
    
    // Efecto visual mejorado de Tsukuyomi pixelado
    let overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100%;height:100%;
      background: 
        repeating-linear-gradient(45deg,
          rgba(0,0,0,0.95) 0px, rgba(0,0,0,0.95) 8px,
          rgba(128,0,0,0.95) 8px, rgba(128,0,0,0.95) 16px);
      background-size: 16px 16px;
      opacity:0;pointer-events:none;
      transition:all 0.5s;
      animation: pixel-tsukuyomi-world 8s steps(8) forwards;
      image-rendering: pixelated;
    `;

    const style = document.createElement('style');
    style.textContent = `
      @keyframes pixel-tsukuyomi-world {
        0% { filter: hue-rotate(0deg) contrast(100%); transform: scale(1); }
        20% { filter: hue-rotate(180deg) contrast(200%); transform: scale(1.2); }
        100% { filter: hue-rotate(360deg) contrast(150%); transform: scale(1.1); }
      }

      @keyframes pixel-blood-rain {
        from { transform: translateY(-100%); }
        to { transform: translateY(100%); }
      }

      @keyframes pixel-sharingan {
        0% { background-position: 0 0; }
        100% { background-position: 32px 32px; }
      }

      @keyframes pixel-spin {
        from { transform: translate(-50%, -50%) rotate(0deg); }
        to { transform: translate(-50%, -50%) rotate(360deg); }
      }

      @keyframes pixel-scan {
        0% { background-position: 0 0; }
        100% { background-position: 32px 32px; }
      }
    `;
    document.head.appendChild(style);

    // A√±adir Sharingan giratorio pixelado
    let sharingan = document.createElement('div');
    sharingan.style.cssText = `
      position:fixed;
      top:50%;left:50%;
      width:200px;height:200px;
      background: 
        repeating-conic-gradient(from 0deg,
          #ff0000 0deg 30deg,
          #000000 30deg 60deg);
      background-size: 32px 32px;
      animation: pixel-spin 2s steps(8) infinite;
      z-index:1000;
      pointer-events:none;
      image-rendering: pixelated;
    `;

    document.body.appendChild(overlay);
    document.body.appendChild(sharingan);

    setTimeout(() => {
      overlay.style.opacity = '0.95';
      scene.fog = new THREE.FogExp2(0xff0000, 0.1);

      enemies.forEach(enemy => {
        if(enemy.position.distanceTo(player.position) < 10) {
          // Crear cruz pixelada que emerge del suelo
          const cross = document.createElement('div');
          cross.style.cssText = `
            position: fixed;
            width: 200px;
            height: 300px;
            background: 
              repeating-linear-gradient(90deg,
                #8B0000 0px, #8B0000 8px,
                #4B0000 8px, #4B0000 16px);
            top: 50%;
            left: 50%;
            transform: translate(-50%, 100%);
            box-shadow: 0 0 20px #FF0000;
            animation: crossRise 2s steps(4) forwards, crossFloat 2s steps(2) infinite;
            image-rendering: pixelated;
          `;

          // Brazos de la cruz pixelados
          const crossArm = document.createElement('div');
          crossArm.style.cssText = `
            position: absolute;
            width: 150px;
            height: 40px;
            background: 
              repeating-linear-gradient(90deg,
                #8B0000 0px, #8B0000 8px,
                #4B0000 8px, #4B0000 16px);
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 20px #FF0000;
            image-rendering: pixelated;
          `;

          cross.appendChild(crossArm);
          document.body.appendChild(cross);

          // Enemigo flotando con animaci√≥n pixelada
          let floatHeight = 0;
          const floatInterval = setInterval(() => {
            floatHeight += 0.2;
            if(floatHeight <= 5) {
              enemy.position.y += 0.2;
            }
            enemy.rotation.y += 0.1; // Gira mientras flota
          }, 50);
          enemy.userData.inTsukuyomi = true;
          enemy.userData.floatInterval = floatInterval;

          // Lluvia de sangre pixelada
          for(let i = 0; i < 50; i++) {
            const drop = document.createElement('div');
            drop.style.cssText = `
              position: fixed;
              width: 4px;
              height: 20px;
              background: 
                repeating-linear-gradient(180deg,
                  #FF0000 0px, #FF0000 4px,
                  #CC0000 4px, #CC0000 8px);
              left: ${Math.random() * 100}%;
              top: -20px;
              animation: pixel-blood-rain 2s steps(4) infinite;
              animation-delay: ${Math.random() * 2}s;
              image-rendering: pixelated;
            `;
            document.body.appendChild(drop);

            setTimeout(() => drop.remove(), 8000);
          }

          // Da√±o continuo
          const damageInterval = setInterval(() => {
            enemy.userData.hp -= 10;
            flash(enemy.position);
          }, 500);

          setTimeout(() => {
            clearInterval(damageInterval);
            clearInterval(enemy.userData.floatInterval);
            enemy.position.y = 0.75; // Volver a la posici√≥n original
            enemy.userData.inTsukuyomi = false;
            cross.remove();
          }, 7500);
        }
      });

    }, 100);

    setTimeout(() => {
      overlay.style.opacity = '0';
      sharingan.remove();
      scene.fog = null;
      setTimeout(() => {
        overlay.remove();
        style.remove();
      }, 500);
    }, 8000);

    // Da√±o mejorado a enemigos
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < 5) {
        e.userData.hp -= 150;
        // Efecto visual de da√±o
        let flash = new THREE.Mesh(
          new THREE.BoxGeometry(4,4,4),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
          })
        );
        flash.position.copy(e.position);
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 500);
      }
    });
  }

  function activateSusanoo() {
    // ANIMACI√ìN √âPICA DE SUSANOO
    animateCharacterPower('susanoo');
    
    let susanoo = new THREE.Group();
    // Crear forma b√°sica del Susanoo pixelado
    let body = new THREE.Mesh(
      new THREE.BoxGeometry(4,8,4),
      new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.3})
    );
    susanoo.add(body);
    player.add(susanoo);

    let cnt = 0, iv = setInterval(() => {
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < 4) {
          e.userData.hp -= 5;
        }
      });
      if(++cnt > 50) {
        clearInterval(iv);
        player.remove(susanoo);
      }
    }, 100);
  }

  // HABILIDADES √âPICAS DE INO YAMANAKA
  function activateMindTransfer() {
    // ANIMACI√ìN √âPICA DE TRANSFERENCIA MENTAL
    animateCharacterPower('mind-transfer');
    
    // SHINTENSHIN NO JUTSU - Transferencia de Mente
    let mindBeam = new THREE.Group();
    
    // Rayo principal de transferencia mental
    let mainBeam = new THREE.Mesh(
      new THREE.BoxGeometry(0.3, 0.3, 25),
      new THREE.MeshBasicMaterial({
        color: 0x9932CC,
        transparent: true,
        opacity: 0.8
      })
    );
    mainBeam.rotation.x = Math.PI/2;
    mindBeam.add(mainBeam);
    
    // Espirales de energ√≠a mental
    for(let i = 0; i < 8; i++) {
      let spiral = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 25),
        new THREE.MeshBasicMaterial({
          color: 0xFF69B4,
          transparent: true,
          opacity: 0.6
        })
      );
      let angle = (i / 8) * Math.PI * 2;
      spiral.position.set(
        Math.cos(angle) * 0.5,
        0,
        Math.sin(angle) * 0.5
      );
      spiral.rotation.x = Math.PI/2;
      spiral.rotation.z = angle;
      mindBeam.add(spiral);
    }
    
    mindBeam.position.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));
    scene.add(mindBeam);
    
    // Animar espirales
    let spiralTime = 0;
    let spiralInterval = setInterval(() => {
      spiralTime += 0.2;
      mindBeam.children.forEach((child, i) => {
        if(i > 0) {
          child.rotation.z += 0.3;
          child.material.opacity = 0.4 + Math.sin(spiralTime * 6 + i) * 0.3;
        }
      });
    }, 50);
    
    // Efectos en enemigos
    enemies.forEach(enemy => {
      if(enemy.position.distanceTo(player.position) < 15) {
        enemy.userData.hp -= 100;
        
        // Efecto de posesi√≥n
        enemy.material.color.setHex(0x9932CC);
        enemy.userData.possessed = true;
        
        // Part√≠culas de control mental
        let mindParticles = new THREE.Group();
        for(let i = 0; i < 12; i++) {
          let particle = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 6, 6),
            new THREE.MeshBasicMaterial({
              color: 0xFF69B4,
              transparent: true,
              opacity: 0.8
            })
          );
          particle.position.set(
            Math.random() * 4 - 2,
            Math.random() * 3 + 1,
            Math.random() * 4 - 2
          );
          mindParticles.add(particle);
        }
        mindParticles.position.copy(enemy.position);
        scene.add(mindParticles);
        
        setTimeout(() => {
          enemy.material.color.setHex(0xAA0000);
          enemy.userData.possessed = false;
          scene.remove(mindParticles);
        }, 3000);
      }
    });
    
    setTimeout(() => {
      clearInterval(spiralInterval);
      scene.remove(mindBeam);
    }, 2000);
  }

  function activateChakraBomb() {
    // ANIMACI√ìN √âPICA DE BOMBA DE CHAKRA
    animateCharacterPower('chakra-bomb');
    
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    // CHAKRA BAKUDAN - Bomba de Chakra √âpica
    let chakraBomb = new THREE.Group();
    
    // N√∫cleo de la bomba
    let bombCore = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 12, 12),
      new THREE.MeshBasicMaterial({
        color: 0x00FF7F,
        transparent: true,
        opacity: 0.9
      })
    );
    chakraBomb.add(bombCore);
    
    // Anillos de energ√≠a
    for(let i = 0; i < 4; i++) {
      let ring = new THREE.Mesh(
        new THREE.RingGeometry(0.5 + i * 0.2, 0.7 + i * 0.2, 16),
        new THREE.MeshBasicMaterial({
          color: i % 2 ? 0xFF69B4 : 0x9932CC,
          transparent: true,
          opacity: 0.7 - i * 0.1,
          side: THREE.DoubleSide
        })
      );
      ring.rotation.x = Math.random() * Math.PI;
      ring.rotation.y = Math.random() * Math.PI;
      chakraBomb.add(ring);
    }
    
    // Chispas de chakra
    for(let i = 0; i < 8; i++) {
      let spark = new THREE.Mesh(
        new THREE.BoxGeometry(0.05, 0.05, 0.3),
        new THREE.MeshBasicMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        })
      );
      let angle = (i / 8) * Math.PI * 2;
      spark.position.set(
        Math.cos(angle) * 0.8,
        Math.sin(angle) * 0.8,
        0
      );
      spark.rotation.z = angle;
      chakraBomb.add(spark);
    }
    
    chakraBomb.position.copy(player.position).add(new THREE.Vector3(0, 1, 0));
    scene.add(chakraBomb);
    
    // Animar bomba
    let bombTime = 0;
    let bombInterval = setInterval(() => {
      bombTime += 0.2;
      
      // Rotar anillos
      chakraBomb.children.forEach((child, i) => {
        if(child.geometry && child.geometry.type === 'RingGeometry') {
          child.rotation.z += 0.2 * (i % 2 ? 1 : -1);
        }
        if(child.geometry && child.geometry.type === 'BoxGeometry') {
          child.rotation.z += 0.4;
        }
      });
      
      // Pulso del n√∫cleo
      bombCore.scale.setScalar(1 + Math.sin(bombTime * 10) * 0.3);
    }, 50);
    
    powers.push({
      mesh: chakraBomb,
      vel: new THREE.Vector3(0, 0, -1.5),
      life: 40,
      damage: 80,
      onHit: (enemy) => {
        // Explosi√≥n √©pica
        let explosion = new THREE.Group();
        
        // Esfera de explosi√≥n
        let explosionSphere = new THREE.Mesh(
          new THREE.SphereGeometry(3, 16, 16),
          new THREE.MeshBasicMaterial({
            color: 0x00FF7F,
            transparent: true,
            opacity: 0.6,
            wireframe: true
          })
        );
        explosion.add(explosionSphere);
        
        // Ondas de choque
        for(let i = 0; i < 6; i++) {
          let shockwave = new THREE.Mesh(
            new THREE.RingGeometry(1 + i, 2 + i, 24),
            new THREE.MeshBasicMaterial({
              color: 0xFF69B4,
              transparent: true,
              opacity: 0.5 - i * 0.08,
              side: THREE.DoubleSide
            })
          );
          shockwave.rotation.x = -Math.PI/2;
          shockwave.position.y = i * 0.3;
          explosion.add(shockwave);
        }
        
        explosion.position.copy(enemy.position);
        scene.add(explosion);
        
        // Animar explosi√≥n
        let expTime = 0;
        let expInterval = setInterval(() => {
          expTime += 0.3;
          
          explosionSphere.scale.setScalar(1 + expTime * 2);
          explosionSphere.material.opacity = Math.max(0, 0.6 - expTime);
          
          explosion.children.forEach((child, i) => {
            if(child.geometry && child.geometry.type === 'RingGeometry') {
              child.scale.setScalar(1 + expTime * (i + 1));
              child.material.opacity = Math.max(0, 0.5 - expTime * (i + 1) * 0.2);
            }
          });
          
          if(expTime > 1.5) {
            clearInterval(expInterval);
            scene.remove(explosion);
          }
        }, 50);
        
        clearInterval(bombInterval);
      }
    });
  }

  function activateMindControl() {
    // ANIMACI√ìN √âPICA DE CONTROL MENTAL
    animateCharacterPower('mind-control');
    
    let circle = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.2, 8),
      new THREE.MeshBasicMaterial({color: 0x9400D3, side: THREE.DoubleSide, transparent: true, opacity: 0.4})
    );
    circle.rotation.x = -Math.PI/2;
    circle.position.copy(player.position);
    scene.add(circle);

    let scale = 1;
    let iv = setInterval(() => {
      scale += 0.2;
      circle.scale.set(scale, scale, scale);
      enemies.forEach(e => {
        if(e.position.distanceTo(player.position) < scale * 2) {
          e.userData.hp -= 3;
          e.rotation.y += 0.2;
        }
      });
      if(scale > 3) {
        clearInterval(iv);
        scene.remove(circle);
      }
    }, 100);
  }

  function activateHealing() {
    // ANIMACI√ìN √âPICA DE CURACI√ìN
    animateCharacterPower('healing');
    
    let healingField = new THREE.Mesh(
      new THREE.BoxGeometry(6, 0.2, 6),
      new THREE.MeshBasicMaterial({color: 0x98FB98, transparent: true, opacity: 0.3, side: THREE.DoubleSide})
    );
    healingField.rotation.x = -Math.PI/2;
    healingField.position.copy(player.position);
    scene.add(healingField);

    let particles = [];
    for(let i = 0; i < 20; i++) {
      let particle = new THREE.Mesh(
        new THREE.BoxGeometry(0.2,0.2,0.2),
        new THREE.MeshBasicMaterial({color: 0x00FF7F})
      );
      particle.position.copy(player.position);
      scene.add(particle);
      particles.push(particle);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      particles.forEach(p => {
        p.position.y += 0.1;
        p.material.opacity -= 0.05;
      });
      if(++cnt > 20) {
        clearInterval(iv);
        scene.remove(healingField);
        particles.forEach(p => scene.remove(p));
      }
    }, 100);
  }

  // Habilidades de Shikamaru
  function activateShadowPossession() {
    // Animaci√≥n de sombra emergiendo y extendi√©ndose pixelada
    let shadowLength = 0;
    let shadowSegments = [];
    const SEGMENTS = 20;
    const MAX_DISTANCE = 15;

    function createShadowSegment() {
      let segment = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 0.2, 1),
        new THREE.MeshBasicMaterial({
          color: 0x000000, 
          transparent: true, 
          opacity: 0
        })
      );
      segment.position.copy(player.position);
      segment.position.y = 0.01; // Ligeramente sobre el suelo
      scene.add(segment);
      return segment;
    }

    // Crear segmentos iniciales
    for(let i = 0; i < SEGMENTS; i++) {
      shadowSegments.push(createShadowSegment());
    }

    let targetEnemy = null;
    let minDist = Infinity;

    // Encontrar el enemigo m√°s cercano en la direcci√≥n frontal
    enemies.forEach(e => {
      let dirToEnemy = e.position.clone().sub(player.position);
      let angle = dirToEnemy.angleTo(new THREE.Vector3(0, 0, -1));
      if(angle < Math.PI/4 && dirToEnemy.length() < minDist) {
        minDist = dirToEnemy.length();
        targetEnemy = e;
      }
    });

    if(!targetEnemy) {
      shadowSegments.forEach(s => scene.remove(s));
      return;
    }

    let growInterval = setInterval(() => {
      shadowLength += 1;
      let progress = shadowLength / SEGMENTS;

      // Actualizar cada segmento
      shadowSegments.forEach((segment, i) => {
        if(i <= shadowLength) {
          let t = i / SEGMENTS;
          let pos = new THREE.Vector3().lerpVectors(
            player.position,
            targetEnemy.position,
            t
          );
          segment.position.copy(pos);
          segment.lookAt(targetEnemy.position);
          segment.material.opacity = Math.min(0.7, (1 - t) * 0.7);

          // Efecto de emergencia pixelado
          segment.position.y = Math.sin(t * Math.PI) * 0.5;
          segment.scale.y = 1 + Math.sin(t * Math.PI) * 0.5;
        }
      });

      // Cuando la sombra alcanza al enemigo
      if(shadowLength >= SEGMENTS) {
        clearInterval(growInterval);
        targetEnemy.userData.frozen = true;
        targetEnemy.userData.controlled = true;
        targetEnemy.userData.originalPosition = targetEnemy.position.clone();
        targetEnemy.material.color.set(0x000000);

        // Limpiar despu√©s de 5 segundos
        setTimeout(() => {
          shadowSegments.forEach(s => scene.remove(s));
          targetEnemy.userData.frozen = false;
          targetEnemy.userData.controlled = false;
          targetEnemy.material.color.set(0xAA0000);
        }, 5000);
      }
    }, 50);

    // Mantener enemigos paralizados
    let controlInterval = setInterval(() => {
      enemies.forEach(e => {
        if(e.userData.controlled) {
          e.position.copy(e.userData.originalPosition);
          // Efecto visual de par√°lisis pixelado
          let sparkle = new THREE.Mesh(
            new THREE.BoxGeometry(0.2,0.2,0.2),
            new THREE.MeshBasicMaterial({color: 0x000000})
          );
          sparkle.position.copy(e.position).add(new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() * 2,
            Math.random() - 0.5
          ));
          scene.add(sparkle);
          setTimeout(() => scene.remove(sparkle), 500);
        }
      });
    }, 100);

    setTimeout(() => {
      clearInterval(controlInterval);
      enemies.forEach(e => {
        e.userData.frozen = false;
        e.userData.controlled = false;
        e.material.color.set(0xAA0000);
      });
    }, 5000);
  }

  function activateShadowStrangle() {
    let range = 8;
    enemies.forEach(e => {
      if(e.position.distanceTo(player.position) < range) {
        e.userData.hp -= 70;
        let shadow = new THREE.Mesh(
          new THREE.BoxGeometry(1, 0.2, 1),
          new THREE.MeshBasicMaterial({color: 0x000000})
        );
        shadow.position.copy(e.position).add(new THREE.Vector3(0, 1, 0));
        scene.add(shadow);
        setTimeout(() => scene.remove(shadow), 1000);
      }
    });
  }

  // Habilidades de Tenten
  function activateWeaponSummoning() {
    // Pergamino giratorio pixelado
    let scroll = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.2, 4),
      new THREE.MeshBasicMaterial({color: 0xF5DEB3})
    );
    scroll.position.copy(player.position).add(new THREE.Vector3(0, 2, 0));
    scroll.rotation.x = Math.PI/2;
    scene.add(scroll);

    // Diferentes tipos de armas pixeladas
    const weaponTypes = [
      {geo: new THREE.BoxGeometry(0.2, 1.2, 0.2), color: 0x808080, name: 'kunai'}, // Kunai
      {geo: new THREE.BoxGeometry(0.2, 1.4, 0.2), color: 0x4A4A4A, name: 'sword'}, // Espada
      {geo: new THREE.BoxGeometry(0.3, 0.3, 0.3), color: 0x696969, name: 'shuriken'} // Shuriken
    ];

    let cnt = 0;
    let weaponInterval = setInterval(() => {
      if(cnt > 15) {
        clearInterval(weaponInterval);
        scene.remove(scroll);
        return;
      }

      let weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
      let weapon = new THREE.Mesh(
        weaponType.geo,
        new THREE.MeshBasicMaterial({color: weaponType.color})
      );

      // Aparecer desde el pergamino
      weapon.position.copy(scroll.position);
      weapon.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );

      scene.add(weapon);
      powers.push({
        mesh: weapon,
        vel: new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 0.5,
          -1
        ).normalize().multiplyScalar(0.3),
        life: 40,
        damage: weaponType.name === 'sword' ? 40 : 25,
        spin: new THREE.Vector3(
          Math.random() * 0.2,
          Math.random() * 0.2,
          Math.random() * 0.2
        )
      });

      cnt++;
    }, 100);

    // Actualizar la funci√≥n animate para hacer girar las armas
    let originalAnimate = animate;
    animate = function() {
      originalAnimate();
      powers.forEach(p => {
        if(p.spin) {
          p.mesh.rotation.x += p.spin.x;
          p.mesh.rotation.y += p.spin.y;
          p.mesh.rotation.z += p.spin.z;
        }
      });
    };
  }

  function activateKunaiRain() {
    for(let i = 0; i < 30; i++) {
      setTimeout(() => {
        let kunai = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.8, 0.2),
          new THREE.MeshBasicMaterial({color: 0x606060})
        );
        kunai.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 10 - 5,
          5,
          Math.random() * 10 - 5
        ));
        scene.add(kunai);
        powers.push({
          mesh: kunai,
          vel: new THREE.Vector3(0, -0.3, 0),
          life: 20,
          damage: 15
        });
      }, i * 100);
    }
  }

  // Habilidades de Hinata
  function activateGentleFist() {
    // Pausar YouTube mientras suena el Byakugan de Hinata
    if(youtubePlayer && youtubePlayer.pauseVideo) {
      youtubePlayer.pauseVideo();
      youtubePlayer.mute();
    }

    // Efecto de sonido del Byakugan mejorado para Hinata con video HTML5
    let byakuganSound = document.createElement('video');
    byakuganSound.id = 'hinata-byakugan-sound';
    byakuganSound.style.cssText = 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;';
    byakuganSound.src = 'https://ik.imagekit.io/lcpvlmgbf/-4196672225765940788.mp4?updatedAt=1748454278148';
    byakuganSound.autoplay = true;
    byakuganSound.muted = false;
    byakuganSound.volume = 1.0;
    byakuganSound.preload = 'auto';

    // Forzar reproducci√≥n inmediata
    document.body.appendChild(byakuganSound);

    byakuganSound.play().then(() => {
      console.log('Hinata Byakugan sound playing!');
    }).catch(e => {
      console.log('Hinata Byakugan autoplay error:', e);
      // Si falla el autoplay, intentar con interacci√≥n del usuario
      byakuganSound.muted = true;
      byakuganSound.play().then(() => {
        byakuganSound.muted = false;
      });
    });

    // Remover despu√©s de que termine el sonido y reanudar YouTube
    setTimeout(() => {
      byakuganSound.remove();
      // Reanudar YouTube despu√©s del sonido del Byakugan
      if(youtubePlayer && youtubePlayer.playVideo) {
        youtubePlayer.unMute();
        youtubePlayer.playVideo();
      }
    }, 3000);

    // Animaci√≥n de Byakugan activ√°ndose pixelado
    let byakuganRing = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.2, 2),
      new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.5})
    );
    byakuganRing.rotation.x = -Math.PI/2;
    byakuganRing.position.copy(player.position);
    scene.add(byakuganRing);

    // Reproducir sonido de poder a distancia para los proyectiles
    playProjectileSound();

    // M√∫ltiples golpes de Pu√±o Suave pixelados
    for(let i = 0; i < 5; i++) {
      setTimeout(() => {
        let chakra = new THREE.Mesh(
          new THREE.BoxGeometry(0.6,0.6,0.6),
          new THREE.MeshBasicMaterial({color: 0x4169E1, transparent: true, opacity: 0.8})
        );
        chakra.position.copy(player.position).add(new THREE.Vector3(
          Math.random() * 2 - 1,
          1,
          Math.random() * 2 - 1
        ));
        scene.add(chakra);
        powers.push({
          mesh: chakra,
          vel: new THREE.Vector3(Math.random() - 0.5, 0, -1).normalize(),
          life: 25,
          damage: 35
        });
      }, i * 200);
    }

    setTimeout(() => scene.remove(byakuganRing), 1000);
  }

  // Temari's Powers
  function activateFanDance() {
    let fan = new THREE.Mesh(
      new THREE.BoxGeometry(6, 3, 0.2),
      new THREE.MeshBasicMaterial({color: 0xF5F5F5})
    );
    fan.position.copy(player.position).add(new THREE.Vector3(0, 1, 1));
    scene.add(fan);

    let angle = 0;
    let iv = setInterval(() => {
      angle += 0.3;
      fan.rotation.y = Math.sin(angle) * 2;

      // M√∫ltiples ondas de viento pixeladas
      if(angle > Math.PI) {
        for(let i = 0; i < 3; i++) {
          let wind = new THREE.Mesh(
            new THREE.BoxGeometry(1, 6, 20),
            new THREE.MeshBasicMaterial({color: 0xADD8E6, transparent: true, opacity: 0.4})
          );
          wind.position.copy(player.position).add(new THREE.Vector3(i*2-2, 1, -4));
          wind.rotation.x = Math.PI/2;
          scene.add(wind);
          powers.push({
            mesh: wind,
            vel: new THREE.Vector3(0, 0, -1.5),
            life: 40,
            damage: 120
          });
        }
        clearInterval(iv);
        scene.remove(fan);
      }
    }, 50);
  }

  function activateWhirlwind() {
    let tornado = new THREE.Group();
    for(let i = 0; i < 5; i++) {
      let ring = new THREE.Mesh(
        new THREE.BoxGeometry(2 + i*0.6, 0.4, 2 + i*0.6),
        new THREE.MeshBasicMaterial({color: 0x87CEEB, transparent: true, opacity: 0.4})
      );
      ring.position.y = i;
      tornado.add(ring);
    }
    tornado.position.copy(player.position);
    scene.add(tornado);

    let cnt = 0;
    let iv = setInterval(() => {
      tornado.rotation.y += 0.2;
      tornado.position.z -= 0.3;
      tornado.children.forEach(ring => {
        ring.scale.x = 1 + Math.sin(cnt * 0.2) * 0.2;
      });

      enemies.forEach(e => {
        if(e.position.distanceTo(tornado.position) < 3) {
          e.userData.hp -= 5;
          e.position.add(new THREE.Vector3(Math.random()-0.5, 0.2, Math.random()-0.5));
        }
      });

      if(++cnt > 50) {
        clearInterval(iv);
        scene.remove(tornado);
      }
    }, 50);
  }

  // Sasuke's Powers
  function activateChidori() {
    // Reproducir sonido de poder a distancia
    playProjectileSound();

    let lightning = new THREE.Group();
    for(let i = 0; i < 20; i++) {
      let bolt = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 1),
        new THREE.MeshBasicMaterial({color: 0x00FFFF})
      );
      bolt.position.set(
        Math.random() * 2 - 1,
        Math.random() * 2,
        Math.random() * 2 - 1
      );
      lightning.add(bolt);
    }

    lightning.position.copy(player.position).add(new THREE.Vector3(0, 1, 0));
    scene.add(lightning);

    let vel = new THREE.Vector3(0, 0, -1);
    powers.push({
      mesh: lightning,
      vel: vel,
      life: 30,
      damage: 150
    });
  }

  function activateKirin() {
    // Efecto de rayo en el cielo pixelado
    let skyLightning = new THREE.Mesh(
      new THREE.BoxGeometry(200, 0.4, 200),
      new THREE.MeshBasicMaterial({color: 0x4169E1, transparent: true, opacity: 0.3})
    );
    skyLightning.position.y = 50;
    skyLightning.rotation.x = -Math.PI/2;
    scene.add(skyLightning);

    setTimeout(() => {
      let dragon = new THREE.Group();
      // Crear forma de drag√≥n el√©ctrico pixelado
      for(let i = 0; i < 30; i++) {
        let segment = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 2),
          new THREE.MeshBasicMaterial({color: 0x00FFFF})
        );
        segment.position.z = -i * 2;
        dragon.add(segment);
      }
      dragon.position.set(0, 40, 0);
      scene.add(dragon);

      let cnt = 0;
      let iv = setInterval(() => {
        dragon.position.y -= 2;
        dragon.children.forEach((segment, i) => {
          segment.rotation.z = Math.sin(cnt * 0.3 + i * 0.2) * 0.3;
        });

        if(dragon.position.y < 0) {
          clearInterval(iv);
          scene.remove(dragon);
          scene.remove(skyLightning);

          // Explosi√≥n
          enemies.forEach(e => {
            if(e.position.distanceTo(player.position) < 10) {
              e.userData.hp -= 200;
              flash(e.position);
            }
          });
        }
        cnt++;
      }, 50);
    }, 1000);
  }

  function activateTwinLionFists() {
    let lions = [];
    // Leones pixelados m√°s grandes y m√°s detallados
    for(let i = 0; i < 2; i++) {
      let lionGroup = new THREE.Group();

      // Cuerpo del le√≥n pixelado
      let body = new THREE.Mesh(
        new THREE.BoxGeometry(1.4,1.4,1.4),
        new THREE.MeshBasicMaterial({color: 0x4B0082})
      );

      // Melena pixelada
      for(let j = 0; j < 8; j++) {
        let hair = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.8, 0.4),
          new THREE.MeshBasicMaterial({color: 0x6A5ACD})
        );
        hair.position.set(
          Math.cos(j * Math.PI/4) * 0.4,
          Math.sin(j * Math.PI/4) * 0.4,
          0
        );
        hair.lookAt(new THREE.Vector3(0, 0, 1));
        lionGroup.add(hair);
      }

      lionGroup.add(body);
      lionGroup.position.copy(player.position).add(new THREE.Vector3(i ? 1.5 : -1.5, 1, 0));
      scene.add(lionGroup);
      lions.push(lionGroup);
    }

    let cnt = 0;
    let iv = setInterval(() => {
      lions.forEach((lion, i) => {
        // Movimiento m√°s fluido
        let angle = cnt * 0.2 + i * Math.PI;
        let target = new THREE.Vector3(
          Math.cos(angle) * 2,
          Math.sin(angle * 0.5) * 0.5,
          -1
        );
        lion.position.add(target.multiplyScalar(0.15));
        lion.rotation.z = Math.sin(cnt * 0.1) * 0.2;

        // Efecto de chakra pixelado
        if(cnt % 3 === 0) {
          let chakraSpark = new THREE.Mesh(
            new THREE.BoxGeometry(0.2,0.2,0.2),
            new THREE.MeshBasicMaterial({color: 0x4B0082, transparent: true, opacity: 0.6})
          );
          chakraSpark.position.copy(lion.position);
          scene.add(chakraSpark);
          setTimeout(() => scene.remove(chakraSpark), 300);
        }
      });

      enemies.forEach(e => {
        lions.forEach(lion => {
          if(lion.position.distanceTo(e.position) < 1.5) {
            e.userData.hp -= 8;
            // Efecto de impacto pixelado
            let impact = new THREE.Mesh(
              new THREE.BoxGeometry(0.8, 0.8, 0.8),
              new THREE.MeshBasicMaterial({color: 0x4B0082, side: THREE.DoubleSide})
            );
            impact.position.copy(e.position);
            impact.lookAt(camera.position);
            scene.add(impact);
            setTimeout(() => scene.remove(impact), 200);
          }
        });
      });

      if(++cnt > 40) {
        clearInterval(iv);
        lions.forEach(lion => scene.remove(lion));
      }
    }, 50);
  }

  // Funci√≥n para actualizar la c√°mara libre 360¬∞
  function updateFreeCamera() {
    // Calcular posici√≥n de la c√°mara basada en los √°ngulos
    let cameraX = player.position.x + Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
    let cameraY = player.position.y + Math.sin(cameraAngleY) * cameraDistance + 4;
    let cameraZ = player.position.z + Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;

    camera.position.set(cameraX, cameraY, cameraZ);
    camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
  }

  // Controles de mouse para PC
  document.addEventListener('mousedown', (event) => {
    if(event.button === 0) { // Solo bot√≥n izquierdo
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }
  });

  document.addEventListener('mouseup', (event) => {
    if(event.button === 0) {
      isDragging = false;
    }
  });

  document.addEventListener('mousemove', (event) => {
    if(isDragging) {
      let deltaX = event.clientX - lastMouseX;
      let deltaY = event.clientY - lastMouseY;

      // Actualizar √°ngulos de c√°mara - CORREGIDOS los controles
      cameraAngleX += deltaX * 0.005; // Sensibilidad horizontal reducida
      cameraAngleY += deltaY * 0.005; // CORREGIDO: + en lugar de - para movimiento natural

      // Limitar rotaci√≥n vertical para evitar que se voltee completamente
      cameraAngleY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleY));

      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }
  });

  // Controles t√°ctiles para m√≥viles
  document.addEventListener('touchstart', (event) => {
    if(event.touches.length === 1) {
      isDragging = true;
      lastMouseX = event.touches[0].clientX;
      lastMouseY = event.touches[0].clientY;
    }
  });

  document.addEventListener('touchend', () => {
    isDragging = false;
  });

  document.addEventListener('touchmove', (event) => {
    if(isDragging && event.touches.length === 1) {
      let deltaX = event.touches[0].clientX - lastMouseX;
      let deltaY = event.touches[0].clientY - lastMouseY;

      // Actualizar √°ngulos de c√°mara - CORREGIDOS los controles t√°ctiles
      cameraAngleX += deltaX * 0.005; // Sensibilidad reducida
      cameraAngleY += deltaY * 0.005; // CORREGIDO: + en lugar de - para movimiento natural

      // Limitar rotaci√≥n vertical
      cameraAngleY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleY));

      lastMouseX = event.touches[0].clientX;
      lastMouseY = event.touches[0].clientY;
    }
  });

  // Control de zoom con rueda del mouse
  document.addEventListener('wheel', (event) => {
    cameraDistance += event.deltaY * 0.01;
    cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Limitar zoom
    event.preventDefault();
  });

  // CONTROLES DE TECLADO PARA PC
  let keys = {};

  document.addEventListener('keydown', (event) => {
    keys[event.code] = true;

    // Prevenir comportamiento por defecto
    if(['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space', 'Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7'].includes(event.code)) {
      event.preventDefault();
    }

    // SALTO MEJORADO
    if(event.code === 'Space' && onGround) {
      velY = 0.6; // Aumentar fuerza de salto
      onGround = false;
      console.log('Salto activado! velY:', velY);
    }

    // Poderes seg√∫n el personaje seleccionado
    if(currentCharacter === 'neji') {
      switch(event.code) {
        case 'Digit1': activateByakugan(); break;
        case 'Digit2': activateJuken(); break;
        case 'Digit3': activate64Palms(); break;
        case 'Digit4': activate128Palms(); break;
        case 'Digit5': activateKaiten(); break;
        case 'Digit6': activateKusho(); break;
        case 'Digit7': activateDetect(); break;
      }
    } else if(currentCharacter === 'itachi') {
      switch(event.code) {
        case 'Digit1': activateSharingan(); break;
        case 'Digit2': activateAmaterasu(); break;
        case 'Digit3': activateTsukuyomi(); break;
        case 'Digit4': activateSusanoo(); break;
      }
    } else if(currentCharacter === 'ino') {
      switch(event.code) {
        case 'Digit1': activateMindTransfer(); break;
        case 'Digit2': activateChakraBomb(); break;
        case 'Digit3': activateMindControl(); break;
        case 'Digit4': activateHealing(); break;
      }
    } else if(currentCharacter === 'shikamaru') {
      switch(event.code) {
        case 'Digit1': activateShadowPossession(); break;
        case 'Digit2': activateShadowStrangle(); break;
      }
    } else if(currentCharacter === 'tenten') {
      switch(event.code) {
        case 'Digit1': activateWeaponSummoning(); break;
        case 'Digit2': activateKunaiRain(); break;
      }
    } else if(currentCharacter === 'hinata') {
      switch(event.code) {
        case 'Digit1': activateGentleFist(); break;
        case 'Digit2': activateTwinLionFists(); break;
      }
    } else if(currentCharacter === 'temari') {
      switch(event.code) {
        case 'Digit1': activateFanDance(); break;
        case 'Digit2': activateWhirlwind(); break;
      }
    } else if(currentCharacter === 'sasuke') {
      switch(event.code) {
        case 'Digit1': activateChidori(); break;
        case 'Digit2': activateKirin(); break;
        case 'Digit3': activateSharingan(); break;
        case 'Digit4': activateAmaterasu(); break;
      }
    } else if(currentCharacter === 'hashirama') {
      switch(event.code) {
        case 'Digit1': activateMokuton(); break;
        case 'Digit2': activateSenjutsu(); break;
        case 'Digit3': activateRegeneration(); break;
        case 'Digit4': activateGojuMokuton(); break;
      }
    }
  });

  document.addEventListener('keyup', (event) => {
    keys[event.code] = false;
  });

  // Funci√≥n para actualizar movimiento con teclado
  function updateKeyboardMovement() {
    // Resetear movimiento
    moveDir = {x: 0, z: 0};

    // WASD para movimiento
    if(keys['KeyW']) moveDir.z = -1; // Adelante
    if(keys['KeyS']) moveDir.z = 1;  // Atr√°s
    if(keys['KeyA']) moveDir.x = -1; // Izquierda
    if(keys['KeyD']) moveDir.x = 1;  // Derecha

    // Normalizar movimiento diagonal
    if(moveDir.x !== 0 && moveDir.z !== 0) {
      let length = Math.sqrt(moveDir.x * moveDir.x + moveDir.z * moveDir.z);
      moveDir.x /= length;
      moveDir.z /= length;
    }

    // Aplicar velocidad
    moveDir.x *= playerSpeed;
    moveDir.z *= playerSpeed;
  }

  // Movimiento relativo a la c√°mara
  function updateMovementDirection() {
    if(moveDir.x !== 0 || moveDir.z !== 0) {
      // Calcular direcci√≥n basada en la orientaci√≥n de la c√°mara
      let forward = new THREE.Vector3(
        Math.sin(cameraAngleX),
        0,
        Math.cos(cameraAngleX)
      ).normalize();

      let right = new THREE.Vector3(
        Math.cos(cameraAngleX),
        0,
        -Math.sin(cameraAngleX)
      ).normalize();

      // Aplicar movimiento relativo a la c√°mara - CORREGIDO
      let moveVector = new THREE.Vector3();
      moveVector.add(forward.clone().multiplyScalar(moveDir.z * playerSpeed)); // Removido el negativo
      moveVector.add(right.clone().multiplyScalar(moveDir.x * playerSpeed));

      // L√≠mites naturales del mundo expandido
      const WORLD_LIMIT = 450;
      let nextX = player.position.x + moveVector.x;
      let nextZ = player.position.z + moveVector.z;

      if(Math.abs(nextX) < WORLD_LIMIT) player.position.x = nextX;
      if(Math.abs(nextZ) < WORLD_LIMIT) player.position.z = nextZ;

      // Rotar el jugador hacia la direcci√≥n de movimiento
      if(moveVector.length() > 0) {
        player.lookAt(player.position.x + moveVector.x, player.position.y, player.position.z + moveVector.z);
      }
    }
  }

  // Funci√≥n para mostrar pantalla de Game Over
  function showGameOverScreen() {
    // Prevenir m√∫ltiples pantallas de Game Over
    if(document.getElementById('game-over-screen')) {
      return;
    }

    // Detener m√∫sica de batalla si existe
    const battleMusic = document.getElementById('battle-music-video');
    if(battleMusic) {
      battleMusic.pause();
      battleMusic.muted = true;
    }

    // Crear pantalla de Game Over
    let gameOverScreen = document.createElement('div');
    gameOverScreen.id = 'game-over-screen';
    gameOverScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 50% 50%, rgba(255,0,0,0.3) 2px, transparent 3px),
        repeating-linear-gradient(45deg, 
          rgba(0,0,0,0.95) 0px, rgba(0,0,0,0.95) 4px,
          rgba(128,0,0,0.95) 4px, rgba(128,0,0,0.95) 8px);
      background-size: 32px 32px, 16px 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      font-family: 'Press Start 2P', cursive;
      animation: gameOverFade 1s ease-in-out;
    `;

    gameOverScreen.innerHTML = `
      <h1 style="
        color: #FF0000;
        font-size: 32px;
        text-shadow: 
          3px 3px 0px #000,
          6px 6px 0px rgba(255,0,0,0.5),
          0 0 20px #FF0000;
        margin: 0 0 20px 0;
        letter-spacing: 4px;
        animation: pixelBlink 1s steps(2) infinite;
        text-align: center;
      ">GAME OVER</h1>

      <h2 style="
        color: #FFD700;
        font-size: 16px;
        text-shadow: 2px 2px 0px #000;
        margin: 0 0 40px 0;
        text-align: center;
      ">MUNDO ABIERTO - ${WORLD_CONFIG.name}</h2>

      <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
        <button id="retry-btn" style="
          background: 
            repeating-conic-gradient(from 0deg, 
              rgba(0,255,0,0.8) 0deg 90deg, 
              rgba(0,200,0,0.8) 90deg 180deg);
          border: 3px solid #00FF00;
          color: #ffffff;
          font-family: 'Press Start 2P', cursive;
          font-size: 12px;
          padding: 15px 25px;
          cursor: pointer;
          transition: all 0.2s steps(2);
          box-shadow: 
            0 0 0 1px #000,
            3px 3px 0px #000,
            0 0 15px rgba(0,255,0,0.5);
          text-shadow: 2px 2px 0px #000;
        ">INTENTAR DE NUEVO</button>

        <button id="menu-btn" style="
          background: 
            repeating-conic-gradient(from 0deg, 
              rgba(255,69,0,0.8) 0deg 90deg, 
              rgba(255,140,0,0.8) 90deg 180deg);
          border: 3px solid #FF4500;
          color: #ffffff;
          font-family: 'Press Start 2P', cursive;
          font-size: 12px;
          padding: 15px 25px;
          cursor: pointer;
          transition: all 0.2s steps(2);
          box-shadow: 
            0 0 0 1px #000,
            3px 3px 0px #000,
            0 0 15px rgba(255,69,0,0.5);
          text-shadow: 2px 2px 0px #000;
        ">VOLVER AL MEN√ö</button>
      </div>
    `;

    // A√±adir efectos de part√≠culas
    for(let i = 0; i < 20; i++) {
      let particle = document.createElement('div');
      particle.style.cssText = `
        position: absolute;
        width: 4px;
        height: 4px;
        background: #FF0000;
        left: ${Math.random() * 100}%;
        top: ${Math.random() * 100}%;
        animation: particleFall ${2 + Math.random() * 3}s linear infinite;
        animation-delay: ${Math.random() * 2}s;
      `;
      gameOverScreen.appendChild(particle);
    }

    // A√±adir estilos de animaci√≥n
    const gameOverStyles = document.createElement('style');
    gameOverStyles.textContent = `
      @keyframes gameOverFade {
        0% { opacity: 0; transform: scale(0.8); }
        100% { opacity: 1; transform: scale(1); }
      }

      @keyframes particleFall {
        0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
        100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
      }
    `;
    document.head.appendChild(gameOverStyles);

    document.body.appendChild(gameOverScreen);

    // Event listeners para los botones
    document.getElementById('retry-btn').addEventListener('click', () => {
      gameOverScreen.remove();
      gameOverStyles.remove();
      retryLevel();
    });

    document.getElementById('menu-btn').addEventListener('click', () => {
      gameOverScreen.remove();
      gameOverStyles.remove();
      returnToCharacterSelect();
    });

    // Efectos hover para botones
    document.getElementById('retry-btn').addEventListener('mouseover', function() {
      this.style.transform = 'scale(1.1)';
      this.style.borderColor = '#00FFFF';
    });
    document.getElementById('retry-btn').addEventListener('mouseout', function() {
      this.style.transform = 'scale(1)';
      this.style.borderColor = '#00FF00';
    });

    document.getElementById('menu-btn').addEventListener('mouseover', function() {
      this.style.transform = 'scale(1.1)';
      this.style.borderColor = '#FFFF00';
    });
    document.getElementById('menu-btn').addEventListener('mouseout', function() {
      this.style.transform = 'scale(1)';
      this.style.borderColor = '#FF4500';
    });
  }

  // Funci√≥n para reintentar el nivel actual
  function retryLevel() {
    // Reiniciar detector de muerte
    gameOver = false;

    // Reiniciar vida del jugador
    playerHealth = MAX_HEALTH;
    updatePlayerHUD();

    // Reiniciar posici√≥n del jugador
    player.position.set(0, 1.25, 0);

    // Limpiar enemigos actuales
    enemies.forEach(e => {
      scene.remove(e);
      if(enemyHUD[e.userData.id]) {
        enemyHUD[e.userData.id].remove();
        delete enemyHUD[e.userData.id];
      }
    });
    enemies = [];

    // Limpiar poderes
    powers.forEach(p => scene.remove(p.mesh));
    powers = [];

    // Respawn de enemigos
    respawnEnemies();

    console.log('üîÑ Mundo reiniciado - ' + WORLD_CONFIG.name);
  }

  // Funci√≥n para volver a la selecci√≥n de personajes
  function returnToCharacterSelect() {
    // Detener todas las m√∫sicas
    const battleMusic = document.getElementById('battle-music-video');
    if(battleMusic) {
      battleMusic.pause();
      battleMusic.remove();
    }

    // Limpiar escena
    enemies.forEach(e => {
      scene.remove(e);
      if(enemyHUD[e.userData.id]) {
        enemyHUD[e.userData.id].remove();
        delete enemyHUD[e.userData.id];
      }
    });
    enemies = [];
    powers.forEach(p => scene.remove(p.mesh));
    powers = [];

    // Remover canvas y elementos del juego
    if(renderer && renderer.domElement) {
      renderer.domElement.remove();
    }

    // Remover controles
    const joystick = document.getElementById('joystick');
    const actions = document.getElementById('actions');
    const playerHud = document.getElementById('player-hud');

    if(joystick) joystick.style.display = 'none';
    if(actions) actions.style.display = 'none';
    if(playerHud) playerHud.style.display = 'none';

    // Reiniciar variables
    gameOver = false; // Reiniciar detector de muerte
    playerHealth = MAX_HEALTH;
    currentCharacter = '';

    // Mostrar pantalla de selecci√≥n de personajes
    document.getElementById('char-select').style.display = 'flex';

    console.log('üè† Volviendo al men√∫ de selecci√≥n de personajes');
  }

  // SISTEMA DE ANIMACIONES √âPICAS PARA TODOS LOS PERSONAJES
  
  function animateCharacterPower(powerType) {
    if(!player.userData.leftArm || !player.userData.rightArm) return;
    
    // Rotar personaje hacia la direcci√≥n del enemigo m√°s cercano
    rotatePlayerToTarget();
    
    switch(currentCharacter) {
      case 'neji':
        animateNejiPower(powerType);
        break;
      case 'itachi':
        animateItachiPower(powerType);
        break;
      case 'ino':
        animateInoPower(powerType);
        break;
      default:
        animateGenericPower(powerType);
    }
  }
  
  function rotatePlayerToTarget() {
    if(enemies.length > 0) {
      let closestEnemy = enemies[0];
      let minDist = player.position.distanceTo(closestEnemy.position);
      
      enemies.forEach(enemy => {
        let dist = player.position.distanceTo(enemy.position);
        if(dist < minDist) {
          minDist = dist;
          closestEnemy = enemy;
        }
      });
      
      // Rotar hacia el enemigo
      let direction = closestEnemy.position.clone().sub(player.position);
      let angle = Math.atan2(direction.x, direction.z);
      player.rotation.y = angle;
    }
  }
  
  function animateNejiPower(powerType) {
    let animTime = 0;
    let duration = powerType === 'kaiten' ? 2.5 : (powerType === '64palms' || powerType === '128palms' ? 3 : 1.5);
    
    let poseInterval = setInterval(() => {
      animTime += 0.1;
      
      switch(powerType) {
        case 'byakugan':
          // Pose de concentraci√≥n con sellos
          player.userData.leftArm.rotation.x = -Math.PI/3;
          player.userData.leftArm.rotation.z = Math.PI/6;
          player.userData.rightArm.rotation.x = -Math.PI/3;
          player.userData.rightArm.rotation.z = -Math.PI/6;
          if(player.userData.head) player.userData.head.rotation.x = -0.2;
          break;
          
        case 'juken':
          // Pose de Juken - palma extendida
          player.userData.rightArm.rotation.x = -Math.PI/2;
          player.userData.rightArm.rotation.z = 0;
          player.userData.leftArm.rotation.x = -Math.PI/4;
          player.userData.leftArm.rotation.z = Math.PI/4;
          if(player.userData.rightLeg) player.userData.rightLeg.rotation.x = Math.PI/6;
          break;
          
        case '64palms':
        case '128palms':
          // Movimiento r√°pido de palmas
          let speed = animTime * 25;
          player.userData.leftArm.rotation.x = Math.sin(speed) * 0.8 - Math.PI/4;
          player.userData.rightArm.rotation.x = Math.sin(speed + Math.PI) * 0.8 - Math.PI/4;
          player.userData.leftArm.rotation.z = Math.sin(speed * 2) * 0.4;
          player.userData.rightArm.rotation.z = Math.sin(speed * 2 + Math.PI) * 0.4;
          break;
          
        case 'kaiten':
          // Rotaci√≥n completa
          player.rotation.y += 0.3;
          player.userData.leftArm.rotation.z = Math.PI/2;
          player.userData.rightArm.rotation.z = -Math.PI/2;
          break;
      }
      
      if(animTime > duration) {
        clearInterval(poseInterval);
        resetCharacterPose();
      }
    }, 50);
  }
  
  function animateItachiPower(powerType) {
    let animTime = 0;
    let duration = powerType === 'tsukuyomi' ? 4 : (powerType === 'susanoo' ? 3 : 2);
    
    let poseInterval = setInterval(() => {
      animTime += 0.1;
      
      switch(powerType) {
        case 'sharingan':
          // Pose de concentraci√≥n Sharingan
          player.userData.leftArm.rotation.x = -Math.PI/6;
          player.userData.rightArm.rotation.x = -Math.PI/6;
          if(player.userData.head) {
            player.userData.head.rotation.x = -0.3;
            player.userData.head.rotation.y = Math.sin(animTime * 8) * 0.1;
          }
          break;
          
        case 'amaterasu':
          // Pose de Amaterasu - mano extendida
          player.userData.rightArm.rotation.x = -Math.PI/3;
          player.userData.rightArm.rotation.y = Math.PI/6;
          player.userData.leftArm.rotation.x = -Math.PI/4;
          if(player.userData.head) player.userData.head.rotation.x = -0.4;
          break;
          
        case 'tsukuyomi':
          // Pose de Tsukuyomi - dedo apuntando
          player.userData.rightArm.rotation.x = -Math.PI/2;
          player.userData.rightArm.rotation.y = 0;
          player.userData.leftArm.rotation.x = -Math.PI/3;
          if(player.userData.body) {
            player.userData.body.rotation.x = Math.sin(animTime * 6) * 0.1;
          }
          break;
          
        case 'susanoo':
          // Pose de Susanoo - brazos cruzados
          player.userData.leftArm.rotation.x = -Math.PI/4;
          player.userData.leftArm.rotation.z = Math.PI/3;
          player.userData.rightArm.rotation.x = -Math.PI/4;
          player.userData.rightArm.rotation.z = -Math.PI/3;
          player.scale.setScalar(1 + Math.sin(animTime * 4) * 0.1);
          break;
      }
      
      if(animTime > duration) {
        clearInterval(poseInterval);
        resetCharacterPose();
      }
    }, 50);
  }
  
  function animateInoPower(powerType) {
    let animTime = 0;
    let duration = powerType === 'mind-control' ? 3 : 2;
    
    let poseInterval = setInterval(() => {
      animTime += 0.1;
      
      switch(powerType) {
        case 'mind-transfer':
          // Pose de transferencia mental - manos en la cabeza
          player.userData.leftArm.rotation.x = -Math.PI/2;
          player.userData.leftArm.rotation.z = Math.PI/4;
          player.userData.rightArm.rotation.x = -Math.PI/2;
          player.userData.rightArm.rotation.z = -Math.PI/4;
          if(player.userData.head) {
            player.userData.head.rotation.x = Math.sin(animTime * 8) * 0.2;
          }
          break;
          
        case 'chakra-bomb':
          // Pose de bomba de chakra - manos juntas
          player.userData.leftArm.rotation.x = -Math.PI/3;
          player.userData.leftArm.rotation.y = Math.PI/6;
          player.userData.rightArm.rotation.x = -Math.PI/3;
          player.userData.rightArm.rotation.y = -Math.PI/6;
          break;
          
        case 'mind-control':
          // Pose de control mental - brazos extendidos
          player.userData.leftArm.rotation.x = -Math.PI/6;
          player.userData.leftArm.rotation.z = Math.PI/3;
          player.userData.rightArm.rotation.x = -Math.PI/6;
          player.userData.rightArm.rotation.z = -Math.PI/3;
          if(player.userData.body) {
            player.userData.body.rotation.y = Math.sin(animTime * 4) * 0.2;
          }
          break;
          
        case 'healing':
          // Pose de curaci√≥n - manos brillantes
          player.userData.leftArm.rotation.x = -Math.PI/4;
          player.userData.rightArm.rotation.x = -Math.PI/4;
          player.userData.leftArm.rotation.z = Math.PI/8;
          player.userData.rightArm.rotation.z = -Math.PI/8;
          break;
      }
      
      if(animTime > duration) {
        clearInterval(poseInterval);
        resetCharacterPose();
      }
    }, 50);
  }
  
  function animateNejiKaitenPose() {
    if(!player.userData.body) return;
    
    // Pose de Kaiten - rotaci√≥n completa
    let animTime = 0;
    let rotationSpeed = 0.1;
    let poseInterval = setInterval(() => {
      animTime += 0.1;
      rotationSpeed += 0.05;
      
      // Rotaci√≥n completa del cuerpo
      player.rotation.y += rotationSpeed;
      
      // Brazos extendidos horizontalmente
      if(player.userData.leftArm && player.userData.rightArm) {
        player.userData.leftArm.rotation.x = 0;
        player.userData.leftArm.rotation.z = Math.PI/2;
        player.userData.rightArm.rotation.x = 0;
        player.userData.rightArm.rotation.z = -Math.PI/2;
      }
      
      // Ligera inclinaci√≥n
      if(player.userData.body) {
        player.userData.body.rotation.x = Math.sin(animTime * 4) * 0.1;
      }
      
      if(animTime > 2.5) {
        clearInterval(poseInterval);
        player.rotation.y = 0;
        resetCharacterPose();
      }
    }, 40);
  }
  
  function animateGenericPower(powerType) {
    let animTime = 0;
    let poseInterval = setInterval(() => {
      animTime += 0.1;
      
      // Animaci√≥n gen√©rica - brazos extendidos
      player.userData.leftArm.rotation.x = -Math.PI/4;
      player.userData.rightArm.rotation.x = -Math.PI/4;
      
      if(animTime > 1.5) {
        clearInterval(poseInterval);
        resetCharacterPose();
      }
    }, 50);
  }
  
  function resetCharacterPose() {
    // Resetear todas las rotaciones a la posici√≥n neutral
    if(player.userData.leftArm) {
      player.userData.leftArm.rotation.set(0, 0, 0);
    }
    if(player.userData.rightArm) {
      player.userData.rightArm.rotation.set(0, 0, 0);
    }
    if(player.userData.leftLeg) {
      player.userData.leftLeg.rotation.set(0, 0, 0);
    }
    if(player.userData.rightLeg) {
      player.userData.rightLeg.rotation.set(0, 0, 0);
    }
    if(player.userData.body) {
      player.userData.body.rotation.set(0, 0, 0);
    }
    if(player.userData.head) {
      player.userData.head.rotation.set(0, 0, 0);
    }
    player.scale.setScalar(1);
  }

  // Add Speed Button
  let speedButton = document.createElement('div');
  speedButton.id = 'speed-button';
  speedButton.className = 'action-btn';
  speedButton.textContent = 'SPEED';
  speedButton.addEventListener('touchstart', function() {
    playerSpeed = 0.6;
    setTimeout(function() {
      playerSpeed = 0.25;
    }, 5000);
  });

  document.getElementById('actions').appendChild(speedButton);

  </script>
</body>
</html>
